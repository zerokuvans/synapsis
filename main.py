#!/usr/bin/env python3
from flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify, send_file, make_response, Response
import mysql.connector
from mysql.connector import Error
from dotenv import load_dotenv
import os
from functools import wraps
import bcrypt
from datetime import datetime, timedelta
import json
import csv
import io
from collections import defaultdict
import calendar
import pytz
import logging
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.colors import blue
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image as RLImage
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_CENTER, TA_LEFT
from io import BytesIO
import jwt
import logging
import base64
import re
import tempfile
from PIL import Image as PILImage
import secrets
import string
import hashlib
import uuid
import pandas as pd
import json
from datetime import datetime, timedelta
import io
import time
import zipfile
import re
import logging
from decimal import Decimal
from pywebpush import webpush, WebPushException
from werkzeug.utils import secure_filename
#from models import Suministro  # Asegúrate de importar el modelo correcto
from flask_login import LoginManager, UserMixin, login_user, logout_user, current_user, login_required
from flask_caching import Cache

load_dotenv()

TIMEZONE = pytz.timezone('America/Bogota')

# Remove debug print statements for environment variables
# print(f"MYSQL_HOST: {os.getenv('MYSQL_HOST')}")
# print(f"MYSQL_USER: {os.getenv('MYSQL_USER')}")
# print(f"MYSQL_PASSWORD: {os.getenv('MYSQL_PASSWORD')}")
# print(f"MYSQL_DB: {os.getenv('MYSQL_DB')}")
# print(f"MYSQL_PORT: {os.getenv('MYSQL_PORT')}")

app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY')
app.config['UPLOAD_FOLDER'] = 'static/uploads'
app.config.setdefault('PREFERRED_URL_SCHEME', 'http')

cache = Cache(app, config={'CACHE_TYPE': 'SimpleCache', 'CACHE_DEFAULT_TIMEOUT': 60})


# Configuración de logging
logging.basicConfig(level=logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
))
app.logger.addHandler(handler)
app.logger.setLevel(logging.INFO)

# Configuración de Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

@login_manager.unauthorized_handler
def unauthorized():
    """Manejador para usuarios no autorizados"""
    try:
        # Devolver JSON para endpoints de API
        api_endpoints = ['/api/', '/preoperacional', '/login']
        if any(request.path.startswith(endpoint) for endpoint in api_endpoints):
            return jsonify({'error': 'No autorizado', 'message': 'Debe iniciar sesión'}), 401
        else:
            # Redirigir a login para páginas web
            return redirect(url_for('login'))
    except Exception as e:
        app.logger.error(f"Error en unauthorized_handler: {e}")
        return jsonify({'error': 'Error de autorización'}), 401

# Definición de la clase User para Flask-Login
class User(UserMixin):
    def __init__(self, id, nombre, role):
        self.id = id
        self.nombre = nombre
        self.role = role
    
    def has_role(self, role):
        return self.role == role

# Función para cargar usuario para Flask-Login
@login_manager.user_loader
def load_user(user_id):
    connection = get_db_connection()
    if connection is None:
        return None
        
    cursor = connection.cursor(dictionary=True)
    cursor.execute("SELECT id_codigo_consumidor, nombre, id_roles FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
    user_data = cursor.fetchone()
    cursor.close()
    connection.close()
    
    if user_data:
        return User(
            id=user_data['id_codigo_consumidor'],
            nombre=user_data['nombre'],
            role=ROLES.get(str(user_data['id_roles']))
        )
    return None

# Importar rutas desde app.py
from app import administrativo_asistencia, obtener_supervisores, obtener_tecnicos_por_supervisor, guardar_asistencia_administrativa
from app import api_asistencia_resumen_categorias
from app import api_asistencia_listado_por_carpeta_dia, api_asistencia_listado_por_tipificacion

# Importar rutas del módulo analistas desde app.py
from app import analistas_index, analistas_causas, analistas_dashboard, api_grupos_causas_cierre, api_tecnologias_causas_cierre, api_agrupaciones_causas_cierre, api_estadisticas_causas_cierre

# Importar rutas del módulo MPA desde app.py
from app import mpa_dashboard, mpa_dashboard_stats, mpa_vehiculos, mpa_soat, mpa_tecnico_mecanica, mpa_licencias, mpa_licencias_conducir, mpa_inspecciones, mpa_siniestros, mpa_mantenimientos, mpa_cronograma, mpa_simit, mpa_kit_carretera
from app import api_get_vehiculos, api_create_vehiculo, api_get_vehiculo, api_update_vehiculo, api_delete_vehiculo, api_get_tecnicos, api_export_vehiculos
from app import api_get_mantenimientos, api_create_mantenimiento, api_get_mantenimiento, api_update_mantenimiento, api_delete_mantenimiento, api_get_placas, api_get_categorias_mantenimiento, api_upload_mantenimiento_image, api_cronograma_list_create, api_cronograma_detalle, api_cronograma_cumplir, api_cronograma_historial
from app import api_get_soat, api_get_soat_by_id, api_create_soat, api_update_soat, api_delete_soat
from app import api_list_tecnico_mecanica, api_get_tecnico_mecanica, api_create_tecnico_mecanica, api_update_tecnico_mecanica, api_delete_tecnico_mecanica
from app import api_list_licencias_conducir, api_get_licencia_conducir, api_create_licencia_conducir, api_update_licencia_conducir, api_delete_licencia_conducir
from app import api_import_vehiculos_excel, api_import_tecnico_mecanica_excel, api_import_soat_excel, api_import_licencias_excel
from app import api_cronograma_alerts_my
from app import api_list_inspecciones, api_get_inspeccion, api_create_inspeccion, api_inspecciones_firma_trabajador, api_inspecciones_firma_inspector, api_inspeccion_pdf, api_inspecciones_pendientes_mes, api_inspecciones_resumen_mes
from app import mpa_rutas, api_import_rutas_excel, api_rutas_tecnicos, api_rutas_por_tecnico, api_google_directions_route, api_riesgo_motos, api_riesgo_por_localidad, api_localidades, api_riesgo_importar, api_rutas_estados, api_riesgo_debug
from app import api_simit_resultados, api_list_kitcarretera, api_get_kitcarretera, api_create_kitcarretera, api_kitcarretera_firma_trabajador, api_kitcarretera_firma_inspector
from app import api_mpa_simit_consultar_playwright
from app import api_mpa_simit_job_run, api_mpa_simit_job_status, api_mpa_simit_job_stop
from app import api_mpa_simit_export
from app import api_cronograma_indicadores
from app import api_cronograma_indicadores_detalle
from app import api_cronograma_indicadores_detalle_trimestre

# Importar solo la función de actualización por claves para SSTT desde app.py
from app import api_sstt_vencimientos_cursos_update_by
from app import api_sstt_vencimientos_cursos_resumen
from app import api_sstt_vencimientos_cursos_delete_by

# Importar módulo de dotaciones
from dotaciones_api import registrar_rutas_dotaciones
from encuestas_api import registrar_rutas_encuestas
from avisos_api import registrar_rutas_avisos

# Registrar rutas de app.py
app.route('/administrativo/asistencia')(administrativo_asistencia)
app.route('/api/supervisores', methods=['GET'])(obtener_supervisores)
app.route('/api/tecnicos_por_supervisor', methods=['GET'])(obtener_tecnicos_por_supervisor)
app.route('/api/asistencia/guardar', methods=['POST'])(guardar_asistencia_administrativa)
app.route('/api/asistencia/resumen_categorias', methods=['GET'])(api_asistencia_resumen_categorias)
app.route('/api/asistencia/listado_por_carpeta_dia', methods=['GET'])(api_asistencia_listado_por_carpeta_dia)
app.route('/api/asistencia/listado_por_tipificacion', methods=['GET'])(api_asistencia_listado_por_tipificacion)

# Registrar rutas del módulo analistas
app.route('/analistas')(analistas_index)
app.route('/analistas/causas')(analistas_causas)
app.route('/analistas/dashboard')(analistas_dashboard)
app.route('/api/analistas/grupos', methods=['GET'])(api_grupos_causas_cierre)
app.route('/api/analistas/tecnologias', methods=['GET'])(api_tecnologias_causas_cierre)
app.route('/api/analistas/agrupaciones', methods=['GET'])(api_agrupaciones_causas_cierre)
app.route('/api/analistas/estadisticas', methods=['GET'])(api_estadisticas_causas_cierre)

# Registrar rutas del módulo MPA
app.route('/mpa')(mpa_dashboard)
app.route('/api/mpa/dashboard-stats')(mpa_dashboard_stats)
app.route('/mpa/vehiculos')(mpa_vehiculos)
app.route('/mpa/soat')(mpa_soat)
app.route('/mpa/tecnico-mecanica')(mpa_tecnico_mecanica)
app.route('/mpa/licencias')(mpa_licencias)
app.route('/mpa/licencias-conducir')(mpa_licencias_conducir)
app.route('/mpa/inspecciones')(mpa_inspecciones)
app.route('/mpa/kit-carretera')(mpa_kit_carretera)
app.route('/mpa/kitcarretera')(mpa_kit_carretera)
app.route('/mpa/kit-carretera/')(mpa_kit_carretera)
app.route('/mpa/siniestros')(mpa_siniestros)
app.route('/mpa/mantenimientos')(mpa_mantenimientos)
app.route('/mpa/cronograma')(mpa_cronograma)
app.route('/mpa/rutas')(mpa_rutas)
app.route('/mpa/simit')(mpa_simit)

# Registrar rutas de la API de vehículos MPA
app.route('/api/mpa/vehiculos', methods=['GET'])(api_get_vehiculos)
app.route('/api/mpa/vehiculos/export', methods=['GET'])(api_export_vehiculos)
app.route('/api/mpa/vehiculos', methods=['POST'])(api_create_vehiculo)
app.route('/api/mpa/vehiculos/<int:vehiculo_id>', methods=['GET'])(api_get_vehiculo)
app.route('/api/mpa/vehiculos/<int:vehiculo_id>', methods=['PUT'])(api_update_vehiculo)
app.route('/api/mpa/vehiculos/<int:vehiculo_id>', methods=['DELETE'])(api_delete_vehiculo)
app.route('/api/mpa/tecnicos', methods=['GET'])(api_get_tecnicos)

# Registrar rutas de la API de mantenimientos MPA
app.route('/api/mpa/mantenimientos', methods=['GET'])(api_get_mantenimientos)
app.route('/api/mpa/mantenimientos', methods=['POST'])(api_create_mantenimiento)
app.route('/api/mpa/mantenimientos/<int:mantenimiento_id>', methods=['GET'])(api_get_mantenimiento)
app.route('/api/mpa/mantenimientos/<int:mantenimiento_id>', methods=['PUT'])(api_update_mantenimiento)
app.route('/api/mpa/mantenimientos/<int:mantenimiento_id>', methods=['DELETE'])(api_delete_mantenimiento)
app.route('/api/mpa/vehiculos/placas', methods=['GET'])(api_get_placas)
app.route('/api/mpa/simit/resultados', methods=['GET'])(api_simit_resultados)
app.route('/api/mpa/kitcarretera', methods=['GET'])(api_list_kitcarretera)
app.route('/api/mpa/kitcarretera/<int:item_id>', methods=['GET'])(api_get_kitcarretera)
app.route('/api/mpa/kitcarretera', methods=['POST'])(api_create_kitcarretera)
app.route('/api/mpa/kitcarretera/<int:item_id>/firma-trabajador', methods=['PUT'])(api_kitcarretera_firma_trabajador)
app.route('/api/mpa/kitcarretera/<int:item_id>/firma-inspector', methods=['PUT'])(api_kitcarretera_firma_inspector)
app.route('/api/mpa/simit/consultar-playwright', methods=['POST'])(api_mpa_simit_consultar_playwright)
app.route('/api/mpa/simit/export', methods=['GET'])(api_mpa_simit_export)
app.route('/api/mpa/simit/job/run', methods=['POST'])(api_mpa_simit_job_run)
app.route('/api/mpa/simit/job/status', methods=['GET'])(api_mpa_simit_job_status)
app.route('/api/mpa/simit/job/stop', methods=['POST','GET'])(api_mpa_simit_job_stop)
app.route('/api/mpa/cronograma', methods=['GET','POST'])(api_cronograma_list_create)
app.route('/api/mpa/cronograma/<placa>', methods=['GET'])(api_cronograma_detalle)
app.route('/api/mpa/cronograma/<placa>/cumplir', methods=['POST'])(api_cronograma_cumplir)
app.route('/api/mpa/cronograma/<placa>/historial', methods=['GET'])(api_cronograma_historial)
app.route('/api/mpa/cronograma/alerts-my', methods=['GET'])(api_cronograma_alerts_my)
app.route('/api/mpa/cronograma/indicadores', methods=['GET'])(api_cronograma_indicadores)
app.route('/api/mpa/cronograma/indicadores/detalle', methods=['GET'])(api_cronograma_indicadores_detalle)
app.route('/api/mpa/cronograma/indicadores/detalle-trimestre', methods=['GET'])(api_cronograma_indicadores_detalle_trimestre)
app.route('/api/mpa/categorias-mantenimiento/<tipo_vehiculo>', methods=['GET'])(api_get_categorias_mantenimiento)
app.route('/api/mpa/mantenimientos/upload-image', methods=['POST'])(api_upload_mantenimiento_image)
app.route('/api/mpa/vehiculos/import-excel', methods=['POST'])(api_import_vehiculos_excel)
app.route('/api/mpa/rutas/estados', methods=['GET'])(api_rutas_estados)
app.route('/api/mpa/tecnico_mecanica/import-excel', methods=['POST'])(api_import_tecnico_mecanica_excel)
app.route('/api/mpa/soat/import-excel', methods=['POST'])(api_import_soat_excel)
app.route('/api/mpa/licencias-conducir/import-excel', methods=['POST'])(api_import_licencias_excel)
app.route('/api/mpa/rutas/import-excel', methods=['POST'])(api_import_rutas_excel)
app.route('/api/mpa/rutas/tecnicos', methods=['GET'])(api_rutas_tecnicos)
app.route('/api/mpa/rutas/por-tecnico', methods=['GET'])(api_rutas_por_tecnico)
app.route('/api/mpa/rutas/google-directions', methods=['GET'])(api_google_directions_route)
app.route('/api/mpa/rutas/riesgo-motos', methods=['GET'])(api_riesgo_motos)
app.route('/api/mpa/rutas/riesgo-por-localidad', methods=['GET'])(api_riesgo_por_localidad)
app.route('/api/mpa/localidades', methods=['GET'])(api_localidades)
app.route('/api/mpa/rutas/riesgo-importar', methods=['POST'])(api_riesgo_importar)
app.route('/api/mpa/rutas/riesgo-debug', methods=['GET'])(api_riesgo_debug)

app.route('/api/mpa/inspecciones', methods=['GET'])(api_list_inspecciones)
app.route('/api/mpa/inspecciones/<int:inspeccion_id>', methods=['GET'])(api_get_inspeccion)
app.route('/api/mpa/inspecciones', methods=['POST'])(api_create_inspeccion)
app.route('/api/mpa/inspecciones/<int:inspeccion_id>/firma-trabajador', methods=['PUT'])(api_inspecciones_firma_trabajador)
app.route('/api/mpa/inspecciones/<int:inspeccion_id>/firma-inspector', methods=['PUT'])(api_inspecciones_firma_inspector)
app.route('/api/mpa/inspecciones/<int:inspeccion_id>/pdf', methods=['GET'])(api_inspeccion_pdf)
app.route('/api/mpa/inspecciones/pendientes-mes', methods=['GET'])(api_inspecciones_pendientes_mes)
app.route('/api/mpa/inspecciones/resumen-mes', methods=['GET'])(api_inspecciones_resumen_mes)

# Registrar rutas de la API de SOAT MPA
app.route('/api/mpa/soat', methods=['GET'])(api_get_soat)
app.route('/api/mpa/soat', methods=['POST'])(api_create_soat)
app.route('/api/mpa/soat/<int:soat_id>', methods=['GET'])(api_get_soat_by_id)
app.route('/api/mpa/soat/<int:soat_id>', methods=['PUT'])(api_update_soat)
app.route('/api/mpa/soat/<int:soat_id>', methods=['DELETE'])(api_delete_soat)

# Registrar rutas de la API de Técnico Mecánica MPA
app.route('/api/mpa/tecnico_mecanica', methods=['GET'])(api_list_tecnico_mecanica)
app.route('/api/mpa/tecnico_mecanica', methods=['POST'])(api_create_tecnico_mecanica)
app.route('/api/mpa/tecnico_mecanica/<int:tm_id>', methods=['GET'])(api_get_tecnico_mecanica)
app.route('/api/mpa/tecnico_mecanica/<int:tm_id>', methods=['PUT'])(api_update_tecnico_mecanica)
app.route('/api/mpa/tecnico_mecanica/<int:tm_id>', methods=['DELETE'])(api_delete_tecnico_mecanica)

# Registrar rutas de la API de Licencias de Conducir MPA
app.route('/api/mpa/licencias-conducir', methods=['GET'])(api_list_licencias_conducir)
app.route('/api/mpa/licencias-conducir', methods=['POST'])(api_create_licencia_conducir)
app.route('/api/mpa/licencias-conducir/<int:licencia_id>', methods=['GET'])(api_get_licencia_conducir)
app.route('/api/mpa/licencias-conducir/<int:licencia_id>', methods=['PUT'])(api_update_licencia_conducir)
app.route('/api/mpa/licencias-conducir/<int:licencia_id>', methods=['DELETE'])(api_delete_licencia_conducir)

# Registrar rutas del módulo de dotaciones
registrar_rutas_dotaciones(app)

# Registrar rutas del módulo de encuestas
registrar_rutas_encuestas(app)
registrar_rutas_avisos(app)

# Registrar rutas faltantes del módulo SSTT
app.route('/api/sstt/vencimientos-cursos/update-by', methods=['PUT'])(api_sstt_vencimientos_cursos_update_by)
app.route('/api/sstt/vencimientos-cursos/resumen', methods=['GET'])(api_sstt_vencimientos_cursos_resumen)
app.route('/api/sstt/vencimientos-cursos/delete-by', methods=['DELETE'])(api_sstt_vencimientos_cursos_delete_by)

@app.route('/api/sgis/debug-urlmap', methods=['GET'])
def api_sgis_debug_urlmap():
    try:
        return jsonify({'success': True, 'routes': [r.rule for r in app.url_map.iter_rules() if '/api/sgis/' in r.rule]})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/debug/urlmap', methods=['GET'])
def debug_urlmap_general():
    try:
        return jsonify({'success': True, 'routes': [r.rule for r in app.url_map.iter_rules()]})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sgis/permiso-trabajo', methods=['POST'])
@login_required
def api_sgis_permiso_trabajo_crear():
    u = session.get('user_id') or session.get('id_codigo_consumidor')
    if not u:
        return jsonify({'success': False, 'message': 'No autenticado'}), 401
    payload = request.get_json(silent=True) or {}
    conn = get_db_connection()
    if conn is None:
        return jsonify({'success': False, 'message': 'BD no disponible'}), 500
    try:
        cur = conn.cursor(dictionary=True)
        try:
            cur.execute(
                """
                SELECT nombre, cargo, recurso_operativo_cedula, super, cliente, ciudad
                FROM recurso_operativo
                WHERE id_codigo_consumidor = %s AND estado = 'Activo'
                """,
                (u,)
            )
            ro = cur.fetchone() or {}
        except Exception:
            cur.execute(
                """
                SELECT *
                FROM recurso_operativo
                WHERE id_codigo_consumidor = %s AND estado = 'Activo'
                """,
                (u,)
            )
            ro = cur.fetchone() or {}
        hoy = get_bogota_datetime().date()
        from datetime import timedelta
        w = hoy.weekday()
        fin = hoy + timedelta(days=6 - w)
        try:
            cur.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
        except Exception:
            table_cols = set()

        inicio_semana = hoy - timedelta(days=w)
        fin_semana = inicio_semana + timedelta(days=6)
        existing = None
        try:
            where_parts = []
            params = []
            if 'sgis_permiso_trabajo_fecha_finalizacion' in table_cols:
                where_parts.append('sgis_permiso_trabajo_fecha_finalizacion = %s')
                params.append(fin_semana)
            if 'sgis_permiso_trabajo_fecha_emision' in table_cols:
                where_parts.append('sgis_permiso_trabajo_fecha_emision BETWEEN %s AND %s')
                params.extend([inicio_semana, fin_semana])
            user_filters = []
            uc = session.get('user_cedula')
            if 'id_codigo_consumidor' in table_cols:
                user_filters.append('id_codigo_consumidor = %s')
                params.append(u)
            if uc:
                if 'recurso_operativo_cedula' in table_cols:
                    user_filters.append('recurso_operativo_cedula = %s')
                    params.append(uc)
                if 'cedula' in table_cols:
                    user_filters.append('cedula = %s')
                    params.append(uc)
            if user_filters:
                where_parts.append('(' + ' OR '.join(user_filters) + ')')
            sql = 'SELECT id_sgis_permiso_trabajo FROM sgis_permiso_trabajo'
            if where_parts:
                sql += ' WHERE ' + ' AND '.join(where_parts)
            if 'id_sgis_permiso_trabajo' in table_cols:
                sql += ' ORDER BY id_sgis_permiso_trabajo DESC'
            sql += ' LIMIT 1'
            cur.execute(sql, tuple(params))
            existing = cur.fetchone()
        except Exception:
            try:
                cur.execute(
                    """
                    SELECT id_sgis_permiso_trabajo
                    FROM sgis_permiso_trabajo
                    WHERE sgis_permiso_trabajo_fecha_finalizacion = %s
                    ORDER BY id_sgis_permiso_trabajo DESC
                    LIMIT 1
                    """,
                    (fin_semana,)
                )
                existing = cur.fetchone()
            except Exception:
                existing = None
        def _tri(v):
            if v is None:
                return None
            s = str(v).strip().upper()
            if s in ('C','NC','NA','N.A','N/A'):
                return 'NA' if s in ('NA','N.A','N/A') else s
            return None
        def _yn(v):
            if v is None:
                return None
            s = str(v).strip().upper()
            if s in ('SI','NO'):
                return s
            return None
        def _ap(v):
            if v is None:
                return None
            s = str(v).strip().upper().replace(' ','_')
            if s in ('APLICA','NO_APLICA'):
                return s
            return None
        fields = {
            'id_codigo_consumidor': u,
            'sgis_permiso_trabajo_fecha_emision': inicio_semana,
            'sgis_permiso_trabajo_fecha_finalizacion': fin_semana,
            'sgis_permiso_trabajo_trabajadores': 1,
            'sgis_permiso_trabajo_emitido_por': ro.get('super'),
            'sgis_permiso_trabajo_proyecto': ro.get('cliente'),
            'sgis_permiso_trabajo_ciudad': ro.get('ciudad'),
            'sgis_permiso_trabajo_responsable_trabajo': ro.get('nombre'),
            'sgis_permiso_trabajo_cargo': ro.get('cargo'),
            'nombre': ro.get('nombre'),
            'cargo': ro.get('cargo'),
            'cedula': ro.get('recurso_operativo_cedula'),
            'recurso_operativo_cedula': ro.get('recurso_operativo_cedula'),
            'sgis_permiso_trabajo_trabajo_ejecutar': payload.get('sgis_permiso_trabajo_trabajo_ejecutar'),
            'sgis_permiso_trabajo_descripcion_tarea': payload.get('sgis_permiso_trabajo_descripcion_tarea'),
            'sgis_permiso_trabajo_herramienta': payload.get('sgis_permiso_trabajo_herramienta'),
            'sgis_permiso_trabajo_herramienta_electrica': _tri(payload.get('sgis_permiso_trabajo_herramienta_electrica')),
            'sgis_permiso_trabajo_herramienta_manual': _tri(payload.get('sgis_permiso_trabajo_herramienta_manual')),
            'sgis_permiso_trabajo_equipos_alturas': _tri(payload.get('sgis_permiso_trabajo_equipos_alturas')),
            'sgis_permiso_trabajo_otros_herramientas': payload.get('sgis_permiso_trabajo_otros_herramientas'),
            'sgis_permiso_trabajo_iluminacion': _tri(payload.get('sgis_permiso_trabajo_iluminacion')),
            'sgis_permiso_trabajo_animales': _tri(payload.get('sgis_permiso_trabajo_animales')),
            'sgis_permiso_trabajo_izaje_alturas': _tri(payload.get('sgis_permiso_trabajo_izaje_alturas')),
            'sgis_permiso_trabajo_obstaculos_evacuacion': _tri(payload.get('sgis_permiso_trabajo_obstaculos_evacuacion')),
            'sgis_permiso_trabajo_vehiculos_area': _tri(payload.get('sgis_permiso_trabajo_vehiculos_area')),
            'sgis_permiso_trabajo_trabajo_alturas': _tri(payload.get('sgis_permiso_trabajo_trabajo_alturas')),
            'sgis_permiso_trabajo_trabajo_piso_humedo': _tri(payload.get('sgis_permiso_trabajo_trabajo_piso_humedo')),
            'sgis_permiso_trabajo_manejo_energia_peligrosa': _tri(payload.get('sgis_permiso_trabajo_manejo_energia_peligrosa')),
            'sgis_permiso_trabajo_trabajo_manual': _tri(payload.get('sgis_permiso_trabajo_trabajo_manual')),
            'sgis_permiso_trabajo_caida_objetos': _tri(payload.get('sgis_permiso_trabajo_caida_objetos')),
            'sgis_permiso_trabajo_otros_area': payload.get('sgis_permiso_trabajo_otros_area'),
            'sgis_permiso_trabajo_proyeccion_particulas': _tri(payload.get('sgis_permiso_trabajo_proyeccion_particulas')),
            'sgis_permiso_trabajo_caidas_menor_2m': _tri(payload.get('sgis_permiso_trabajo_caidas_menor_2m')),
            'sgis_permiso_trabajo_caidas_mayor_2m': _tri(payload.get('sgis_permiso_trabajo_caidas_mayor_2m')),
            'sgis_permiso_trabajo_acceso_mal_estado': _tri(payload.get('sgis_permiso_trabajo_acceso_mal_estado')),
            'sgis_permiso_trabajo_levantamiento_carga_mecanica': _tri(payload.get('sgis_permiso_trabajo_levantamiento_carga_mecanica')),
            'sgis_permiso_trabajo_condicion_clima': _tri(payload.get('sgis_permiso_trabajo_condicion_clima')),
            'sgis_permiso_trabajo_clima': payload.get('sgis_permiso_trabajo_clima'),
            'sgis_permiso_trabajo_proxi_red_energizasa': _tri(payload.get('sgis_permiso_trabajo_proxi_red_energizasa')),
            'sgis_permiso_trabajo_proxi_red': payload.get('sgis_permiso_trabajo_proxi_red'),
            'sgis_permiso_trabajo_vibraciones': _tri(payload.get('sgis_permiso_trabajo_vibraciones')),
            'sgis_permiso_trabajo_contacto_electrico': _tri(payload.get('sgis_permiso_trabajo_contacto_electrico')),
            'sgis_permiso_trabajo_atrapamiento': _tri(payload.get('sgis_permiso_trabajo_atrapamiento')),
            'sgis_permiso_trabajo_cable_expuesto': _tri(payload.get('sgis_permiso_trabajo_cable_expuesto')),
            'sgis_permiso_trabajo_corte_no_visible': _tri(payload.get('sgis_permiso_trabajo_corte_no_visible')),
            'sgis_permiso_trabajo_atmosfera_explosiva': _tri(payload.get('sgis_permiso_trabajo_atmosfera_explosiva')),
            'sgis_permiso_trabajo_fuentes_ignicion': _tri(payload.get('sgis_permiso_trabajo_fuentes_ignicion')),
            'sgis_permiso_trabajo_vapores': _tri(payload.get('sgis_permiso_trabajo_vapores')),
            'sgis_permiso_trabajo_alta_temperatura': _tri(payload.get('sgis_permiso_trabajo_alta_temperatura')),
            'sgis_permiso_trabajo_baja_temperatura': _tri(payload.get('sgis_permiso_trabajo_baja_temperatura')),
            'sgis_permiso_trabajo_iluminacion_deficiente': _tri(payload.get('sgis_permiso_trabajo_iluminacion_deficiente')),
            'sgis_permiso_trabajo_quemaduras': _tri(payload.get('sgis_permiso_trabajo_quemaduras')),
            'sgis_permiso_trabajo_almacenamientos_quimicos': _tri(payload.get('sgis_permiso_trabajo_almacenamientos_quimicos')),
            'sgis_permiso_trabajo_extensiones_mal_estado': _tri(payload.get('sgis_permiso_trabajo_extensiones_mal_estado')),
            'sgis_permiso_trabajo_ruido': _tri(payload.get('sgis_permiso_trabajo_ruido')),
            'sgis_permiso_trabajo_contacto_directo_indirecto': _tri(payload.get('sgis_permiso_trabajo_contacto_directo_indirecto')),
            'sgis_permiso_trabajo_caida_objeto': _tri(payload.get('sgis_permiso_trabajo_caida_objeto')),
            'sgis_permiso_trabajo_espacio_reducido': _tri(payload.get('sgis_permiso_trabajo_espacio_reducido')),
            'sgis_permiso_trabajo_levantamiento_manual_cargas': _tri(payload.get('sgis_permiso_trabajo_levantamiento_manual_cargas')),
            'sgis_permiso_trabajo_subestacion_inundada': _tri(payload.get('sgis_permiso_trabajo_subestacion_inundada')),
            'sgis_permiso_trabajo_excavaciones': _tri(payload.get('sgis_permiso_trabajo_excavaciones')),
            'sgis_permiso_trabajo_otros': payload.get('sgis_permiso_trabajo_otros'),
            'sgis_permiso_trabajo_calzado_dielectrico': _tri(payload.get('sgis_permiso_trabajo_calzado_dielectrico')),
            'sgis_permiso_trabajo_guantes_nitrilo': _tri(payload.get('sgis_permiso_trabajo_guantes_nitrilo')),
            'sgis_permiso_trabajo_guantes_vaqueta': _tri(payload.get('sgis_permiso_trabajo_guantes_vaqueta')),
            'sgis_permiso_trabajo_gafas_proteccion': _tri(payload.get('sgis_permiso_trabajo_gafas_proteccion')),
            'sgis_permiso_trabajo_casco_dielectrico': _tri(payload.get('sgis_permiso_trabajo_casco_dielectrico')),
            'sgis_permiso_trabajo_tie_off': _tri(payload.get('sgis_permiso_trabajo_tie_off')),
            'sgis_permiso_trabajo_mosqueton': _tri(payload.get('sgis_permiso_trabajo_mosqueton')),
            'sgis_permiso_trabajo_eslinga': _tri(payload.get('sgis_permiso_trabajo_eslinga')),
            'sgis_permiso_trabajo_arrestador': _tri(payload.get('sgis_permiso_trabajo_arrestador')),
            'sgis_permiso_trabajo_arnes': _tri(payload.get('sgis_permiso_trabajo_arnes')),
            'sgis_permiso_trabajo_linea_vida': _tri(payload.get('sgis_permiso_trabajo_linea_vida')),
            'sgis_permiso_trabajo_escalera_tijera': _tri(payload.get('sgis_permiso_trabajo_escalera_tijera')),
            'sgis_permiso_trabajo_escalera_extensible': _tri(payload.get('sgis_permiso_trabajo_escalera_extensible')),
            'sgis_permiso_trabajo_cinta_precaucion': _tri(payload.get('sgis_permiso_trabajo_cinta_precaucion')),
            'sgis_permiso_trabajo_conos': _tri(payload.get('sgis_permiso_trabajo_conos')),
            'sgis_permiso_trabajo_botiquin': _tri(payload.get('sgis_permiso_trabajo_botiquin')),
            'sgis_permiso_trabajo_notificacion_trabajo': _yn(payload.get('sgis_permiso_trabajo_notificacion_trabajo')),
            'sgis_permiso_trabajo_responsabilidades_permiso': _yn(payload.get('sgis_permiso_trabajo_responsabilidades_permiso')),
            'sgis_permiso_trabajo_condicion_interrupcion': _yn(payload.get('sgis_permiso_trabajo_condicion_interrupcion')),
            'sgis_permiso_trabajo_cambios_seguridad_trabajo': _yn(payload.get('sgis_permiso_trabajo_cambios_seguridad_trabajo')),
            'sgis_permiso_trabajo_induccion_seguridad': _yn(payload.get('sgis_permiso_trabajo_induccion_seguridad')),
            'sgis_permiso_trabajo_capacitacion_tema': _yn(payload.get('sgis_permiso_trabajo_capacitacion_tema')),
            'sgis_permiso_trabajo_metodos_inspeccion': _yn(payload.get('sgis_permiso_trabajo_metodos_inspeccion')),
            'sgis_permiso_trabajo_responsables_area': _yn(payload.get('sgis_permiso_trabajo_responsables_area')),
            'sgis_permiso_trabajo_mecanismo_control_riesgo': _yn(payload.get('sgis_permiso_trabajo_mecanismo_control_riesgo')),
            'sgis_permiso_trabajo_alarmas_puntos_reunion': _yn(payload.get('sgis_permiso_trabajo_alarmas_puntos_reunion')),
            'sgis_permiso_trabajo_ubicacion_equipos_incendio': _yn(payload.get('sgis_permiso_trabajo_ubicacion_equipos_incendio')),
            'sgis_permiso_trabajo_riesgos_trabajo_area': _yn(payload.get('sgis_permiso_trabajo_riesgos_trabajo_area')),
            'sgis_permiso_trabajo_impacto_ambiental': _yn(payload.get('sgis_permiso_trabajo_impacto_ambiental')),
            'sgis_permiso_trabajo_ats': _tri(payload.get('sgis_permiso_trabajo_ats')),
            'sgis_permiso_trabajo_inspecciones_relizadas': _tri(payload.get('sgis_permiso_trabajo_inspecciones_relizadas')),
            'sgis_permiso_trabajo_procedimientos_trabajo': _tri(payload.get('sgis_permiso_trabajo_procedimientos_trabajo')),
            'sgis_permiso_trabajo_arl_afp_eps': _tri(payload.get('sgis_permiso_trabajo_arl_afp_eps')),
            'sgis_permiso_trabajo_confinado_aplica': _ap(payload.get('sgis_permiso_trabajo_confinado_aplica')),
            'sgis_permiso_trabajo_altura_aplica': _ap(payload.get('sgis_permiso_trabajo_altura_aplica'))
        }
        # Filtrar solo columnas existentes en la tabla para evitar errores 500 por columnas faltantes
        cur.execute("""
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
        """)
        existing_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
        filtered_items = [(k, v) for k, v in fields.items() if k in existing_cols]
        cols = ",".join([k for k, _ in filtered_items])
        vals = tuple([v for _, v in filtered_items])
        if existing:
            pid = existing['id_sgis_permiso_trabajo']
            set_stmt = ",".join([f"{k}=%s" for k, _ in filtered_items])
            try:
                cur.execute(
                    """
                    SELECT COLUMN_NAME
                    FROM INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                    """
                )
                table_cols2 = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
            except Exception:
                table_cols2 = set()
            if 'updated_at' in table_cols2:
                set_stmt = set_stmt + ", updated_at=NOW()"
            cur.execute(f"UPDATE sgis_permiso_trabajo SET {set_stmt} WHERE id_sgis_permiso_trabajo=%s", vals + (pid,))
            conn.commit()
            return jsonify({'success': True, 'id_sgis_permiso_trabajo': pid, 'message': 'Actualizado'}), 200
        cur.execute(f"INSERT INTO sgis_permiso_trabajo ({cols}) VALUES ({','.join(['%s']*len(filtered_items))})", vals)
        conn.commit()
        pid = cur.lastrowid
        return jsonify({'success': True, 'id_sgis_permiso_trabajo': pid, 'message': 'Creado'}), 201
    except Exception as e:
        try:
            conn.rollback()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        try:
            cur.close(); conn.close()
        except Exception:
            pass

@app.route('/api/sgis/permiso-trabajo/current', methods=['GET'])
@login_required
def api_sgis_permiso_trabajo_actual():
    u = session.get('user_id') or session.get('id_codigo_consumidor')
    if not u:
        return jsonify({'success': False, 'message': 'No autenticado'}), 401
    conn = get_db_connection()
    if conn is None:
        return jsonify({'success': False, 'message': 'BD no disponible'}), 500
    try:
        cur = conn.cursor(dictionary=True)
        hoy = get_bogota_datetime().date()
        from datetime import timedelta
        w = hoy.weekday()
        inicio_semana = hoy - timedelta(days=w)
        fin_semana = inicio_semana + timedelta(days=6)
        try:
            cur.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
        except Exception:
            table_cols = set()
        row = None
        try:
            where_parts = []
            params = []
            if 'sgis_permiso_trabajo_fecha_finalizacion' in table_cols:
                where_parts.append('sgis_permiso_trabajo_fecha_finalizacion = %s')
                params.append(fin_semana)
            if 'sgis_permiso_trabajo_fecha_emision' in table_cols:
                where_parts.append('sgis_permiso_trabajo_fecha_emision BETWEEN %s AND %s')
                params.extend([inicio_semana, fin_semana])
            user_filters = []
            uc = session.get('user_cedula')
            if 'id_codigo_consumidor' in table_cols:
                user_filters.append('id_codigo_consumidor = %s')
                params.append(u)
            if uc:
                if 'recurso_operativo_cedula' in table_cols:
                    user_filters.append('recurso_operativo_cedula = %s')
                    params.append(uc)
                if 'cedula' in table_cols:
                    user_filters.append('cedula = %s')
                    params.append(uc)
            if user_filters:
                where_parts.append('(' + ' OR '.join(user_filters) + ')')
            sql = 'SELECT * FROM sgis_permiso_trabajo'
            if where_parts:
                sql += ' WHERE ' + ' AND '.join(where_parts)
            if 'id_sgis_permiso_trabajo' in table_cols:
                sql += ' ORDER BY id_sgis_permiso_trabajo DESC'
            sql += ' LIMIT 1'
            cur.execute(sql, tuple(params))
            row = cur.fetchone()
        except Exception:
            try:
                cur.execute(
                    """
                    SELECT * FROM sgis_permiso_trabajo
                    WHERE sgis_permiso_trabajo_fecha_finalizacion=%s
                    ORDER BY id_sgis_permiso_trabajo DESC
                    LIMIT 1
                    """,
                    (fin_semana,)
                )
                row = cur.fetchone()
            except Exception:
                row = None
        if not row:
            try:
                cur.execute(
                    """
                    SELECT nombre, cargo, recurso_operativo_cedula, super, cliente, ciudad
                    FROM recurso_operativo
                    WHERE id_codigo_consumidor = %s AND estado = 'Activo'
                    """,
                    (u,)
                )
                ro = cur.fetchone() or {}
            except Exception:
                cur.execute(
                    """
                    SELECT *
                    FROM recurso_operativo
                    WHERE id_codigo_consumidor = %s AND estado = 'Activo'
                    """,
                    (u,)
                )
                ro = cur.fetchone() or {}
            row = {
                'sgis_permiso_trabajo_emitido_por': ro.get('super'),
                'sgis_permiso_trabajo_proyecto': ro.get('cliente'),
                'sgis_permiso_trabajo_ciudad': ro.get('ciudad'),
                'sgis_permiso_trabajo_responsable_trabajo': ro.get('nombre'),
                'sgis_permiso_trabajo_cargo': ro.get('cargo'),
                'recurso_operativo_cedula': ro.get('recurso_operativo_cedula'),
                'nombre': ro.get('nombre'),
                'cargo': ro.get('cargo'),
                'cedula': ro.get('recurso_operativo_cedula')
            }
        return jsonify({'success': True, 'data': row})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        try:
            cur.close(); conn.close()
        except Exception:
            pass

@app.route('/api/sgis/permiso-trabajo/historial/confinado', methods=['POST','GET'])
@login_required
def api_sgis_historial_confinado():
    u = session.get('user_id') or session.get('id_codigo_consumidor')
    if not u:
        return jsonify({'success': False, 'message': 'No autenticado'}), 401
    conn = get_db_connection()
    if conn is None:
        return jsonify({'success': False, 'message': 'BD no disponible'}), 500
    try:
        cur = conn.cursor(dictionary=True)
        if request.method == 'GET':
            pid = request.args.get('id_sgis_permiso_trabajo', type=int)
            if not pid:
                return jsonify({'success': False, 'message': 'id_sgis_permiso_trabajo requerido'}), 400
            cur.execute("""SELECT * FROM sgis_permiso_trabajo_historial_semanal_confinado WHERE id_sgis_permiso_trabajo=%s ORDER BY sgis_permiso_trabajo_historial_confinado_fecha ASC""", (pid,))
            rows = cur.fetchall()
            return jsonify({'success': True, 'data': rows})
        data = request.get_json(silent=True) or {}
        pid = data.get('id_sgis_permiso_trabajo')
        if not pid:
            return jsonify({'success': False, 'message': 'id_sgis_permiso_trabajo requerido'}), 400
        fecha = data.get('sgis_permiso_trabajo_historial_confinado_fecha') or get_bogota_datetime().date()
        try:
            from datetime import datetime as _dt
            if isinstance(fecha, str):
                fecha_cmp = _dt.strptime(fecha, '%Y-%m-%d').date()
            else:
                fecha_cmp = fecha
        except Exception:
            fecha_cmp = get_bogota_datetime().date()
        hoy_bogota = get_bogota_datetime().date()
        if fecha_cmp != hoy_bogota:
            return jsonify({'success': False, 'message': 'Solo se puede firmar el día actual'}), 400
        # Obtener nombre del técnico para firma automática si no viene en payload
        cur.execute("""
            SELECT nombre
            FROM recurso_operativo
            WHERE id_codigo_consumidor = %s AND estado = 'Activo'
        """, (u,))
        ro = cur.fetchone() or {}
        firma_tecnico = (data.get('sgis_permiso_trabajo_historial_confinado_firma_tecnico') or ro.get('nombre') or '')
        fields = {
            'id_sgis_permiso_trabajo': pid,
            'id_codigo_consumidor': u,
            'sgis_permiso_trabajo_historial_confinado_1': data.get('sgis_permiso_trabajo_historial_confinado_1'),
            'sgis_permiso_trabajo_historial_confinado_2': data.get('sgis_permiso_trabajo_historial_confinado_2'),
            'sgis_permiso_trabajo_historial_confinado_3': data.get('sgis_permiso_trabajo_historial_confinado_3'),
            'sgis_permiso_trabajo_historial_confinado_4': data.get('sgis_permiso_trabajo_historial_confinado_4'),
            'sgis_permiso_trabajo_historial_confinado_5': data.get('sgis_permiso_trabajo_historial_confinado_5'),
            'sgis_permiso_trabajo_historial_confinado_6': data.get('sgis_permiso_trabajo_historial_confinado_6'),
            'sgis_permiso_trabajo_historial_confinado_7': data.get('sgis_permiso_trabajo_historial_confinado_7'),
            'sgis_permiso_trabajo_historial_confinado_8': data.get('sgis_permiso_trabajo_historial_confinado_8'),
            'sgis_permiso_trabajo_historial_confinado_9': data.get('sgis_permiso_trabajo_historial_confinado_9'),
            'sgis_permiso_trabajo_historial_confinado_10': data.get('sgis_permiso_trabajo_historial_confinado_10'),
            'sgis_permiso_trabajo_historial_confinado_11': data.get('sgis_permiso_trabajo_historial_confinado_11'),
            'sgis_permiso_trabajo_historial_confinado_fecha': fecha,
            'sgis_permiso_trabajo_historial_confinado_firma_tecnico': firma_tecnico,
            'sgis_permiso_trabajo_historial_confinado_firma_supervisor': data.get('sgis_permiso_trabajo_historial_confinado_firma_supervisor')
        }
        # Detectar si la petición es solo firma de supervisor (sin ítems del día)
        try:
            is_signature_only = (
                data.get('sgis_permiso_trabajo_historial_confinado_firma_supervisor') is not None and
                all(data.get(f'sgis_permiso_trabajo_historial_confinado_{i}') is None for i in range(1, 12))
            )
        except Exception:
            is_signature_only = False
        # Si ya existe registro para ese día, actualizar solo la firma del supervisor
        try:
            cur.execute(
                """
                SELECT id_sgis_permiso_trabajo_historial_semanal_confinado AS id
                FROM sgis_permiso_trabajo_historial_semanal_confinado
                WHERE id_sgis_permiso_trabajo=%s AND DATE(sgis_permiso_trabajo_historial_confinado_fecha)=%s
                ORDER BY id_sgis_permiso_trabajo_historial_semanal_confinado ASC
                LIMIT 1
                """,
                (pid, fecha_cmp)
            )
            existing_day = cur.fetchone()
        except Exception:
            existing_day = None
        # Bloquear firma si no existe registro del día
        if (not existing_day) and is_signature_only:
            return jsonify({'success': False, 'message': 'Solo se puede firmar si ya existe registro del día'}), 400
        if existing_day and (data.get('sgis_permiso_trabajo_historial_confinado_firma_supervisor') is not None):
            try:
                cur.execute(
                    """
                    UPDATE sgis_permiso_trabajo_historial_semanal_confinado
                    SET sgis_permiso_trabajo_historial_confinado_firma_supervisor=%s
                    WHERE id_sgis_permiso_trabajo_historial_semanal_confinado=%s
                    """,
                    (data.get('sgis_permiso_trabajo_historial_confinado_firma_supervisor'), existing_day.get('id') if isinstance(existing_day, dict) else existing_day[0])
                )
                conn.commit()
                return jsonify({'success': True, 'updated': True}), 200
            except Exception:
                pass
        try:
            cur.execute("SELECT COALESCE(MAX(id_sgis_permiso_trabajo_historial_semanal_confinado),0)+1 AS next_id FROM sgis_permiso_trabajo_historial_semanal_confinado")
            next_id_row = cur.fetchone()
            next_id = (next_id_row['next_id'] if isinstance(next_id_row, dict) else next_id_row[0])
        except Exception:
            next_id = None
        cur.execute(
            """
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo_historial_semanal_confinado'
            """
        )
        existing_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
        filtered_items = [(k, v) for k, v in fields.items() if k in existing_cols]
        if 'id_sgis_permiso_trabajo_historial_semanal_confinado' in existing_cols:
            filtered_items = [('id_sgis_permiso_trabajo_historial_semanal_confinado', next_id)] + filtered_items
        cols = ",".join([k for k, _ in filtered_items])
        vals = tuple([v for _, v in filtered_items])
        cur.execute(f"INSERT INTO sgis_permiso_trabajo_historial_semanal_confinado ({cols}) VALUES ({','.join(['%s']*len(filtered_items))})", vals)
        conn.commit()
        return jsonify({'success': True, 'created': True}), 201
    except Exception as e:
        try:
            conn.rollback()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        try:
            cur.close(); conn.close()
        except Exception:
            pass

@app.route('/api/sgis/permiso-trabajo/historial/alturas', methods=['POST','GET'])
@login_required
def api_sgis_historial_alturas():
    u = session.get('user_id') or session.get('id_codigo_consumidor')
    if not u:
        return jsonify({'success': False, 'message': 'No autenticado'}), 401
    conn = get_db_connection()
    if conn is None:
        return jsonify({'success': False, 'message': 'BD no disponible'}), 500
    try:
        cur = conn.cursor(dictionary=True)
        if request.method == 'GET':
            pid = request.args.get('id_sgis_permiso_trabajo', type=int)
            if not pid:
                return jsonify({'success': False, 'message': 'id_sgis_permiso_trabajo requerido'}), 400
            cur.execute("""SELECT * FROM sgis_permiso_trabajo_historial_semanal_altura WHERE id_sgis_permiso_trabajo=%s ORDER BY sgis_permiso_trabajo_historial_altura_fecha ASC""", (pid,))
            rows = cur.fetchall()
            return jsonify({'success': True, 'data': rows})
        data = request.get_json(silent=True) or {}
        pid = data.get('id_sgis_permiso_trabajo')
        if not pid:
            return jsonify({'success': False, 'message': 'id_sgis_permiso_trabajo requerido'}), 400
        fecha = data.get('sgis_permiso_trabajo_historial_altura_fecha') or get_bogota_datetime().date()
        try:
            from datetime import datetime as _dt
            if isinstance(fecha, str):
                fecha_cmp = _dt.strptime(fecha, '%Y-%m-%d').date()
            else:
                fecha_cmp = fecha
        except Exception:
            fecha_cmp = get_bogota_datetime().date()
        hoy_bogota = get_bogota_datetime().date()
        if fecha_cmp != hoy_bogota:
            return jsonify({'success': False, 'message': 'Solo se puede firmar el día actual'}), 400
        # Obtener nombre del técnico para firma automática si no viene en payload
        cur.execute("""
            SELECT nombre
            FROM recurso_operativo
            WHERE id_codigo_consumidor = %s AND estado = 'Activo'
        """, (u,))
        ro = cur.fetchone() or {}
        firma_tecnico_alt = (data.get('sgis_permiso_trabajo_historial_semanal_altura_firma_tecnico') or ro.get('nombre') or '')
        fields = {
            'id_sgis_permiso_trabajo': pid,
            'id_codigo_consumidor': u,
            'sgis_permiso_trabajo_historial_altura_1': data.get('sgis_permiso_trabajo_historial_altura_1'),
            'sgis_permiso_trabajo_historial_altura_2': data.get('sgis_permiso_trabajo_historial_altura_2'),
            'sgis_permiso_trabajo_historial_altura_3': data.get('sgis_permiso_trabajo_historial_altura_3'),
            'sgis_permiso_trabajo_historial_altura_4': data.get('sgis_permiso_trabajo_historial_altura_4'),
            'sgis_permiso_trabajo_historial_altura_5': data.get('sgis_permiso_trabajo_historial_altura_5'),
            'sgis_permiso_trabajo_historial_altura_6': data.get('sgis_permiso_trabajo_historial_altura_6'),
            'sgis_permiso_trabajo_historial_altura_7': data.get('sgis_permiso_trabajo_historial_altura_7'),
            'sgis_permiso_trabajo_historial_altura_8': data.get('sgis_permiso_trabajo_historial_altura_8'),
            'sgis_permiso_trabajo_historial_altura_9': data.get('sgis_permiso_trabajo_historial_altura_9'),
            'sgis_permiso_trabajo_historial_altura_10': data.get('sgis_permiso_trabajo_historial_altura_10'),
            'sgis_permiso_trabajo_historial_altura_11': data.get('sgis_permiso_trabajo_historial_altura_11'),
            'sgis_permiso_trabajo_historial_altura_12': data.get('sgis_permiso_trabajo_historial_altura_12'),
            'sgis_permiso_trabajo_historial_altura_13': data.get('sgis_permiso_trabajo_historial_altura_13'),
            'sgis_permiso_trabajo_historial_altura_14': data.get('sgis_permiso_trabajo_historial_altura_14'),
            'sgis_permiso_trabajo_historial_altura_15': data.get('sgis_permiso_trabajo_historial_altura_15'),
            'sgis_permiso_trabajo_historial_altura_16': data.get('sgis_permiso_trabajo_historial_altura_16'),
            'sgis_permiso_trabajo_historial_altura_17': data.get('sgis_permiso_trabajo_historial_altura_17'),
            'sgis_permiso_trabajo_historial_altura_18': data.get('sgis_permiso_trabajo_historial_altura_18'),
            'sgis_permiso_trabajo_historial_altura_19': data.get('sgis_permiso_trabajo_historial_altura_19'),
            'sgis_permiso_trabajo_historial_altura_20': data.get('sgis_permiso_trabajo_historial_altura_20'),
            'sgis_permiso_trabajo_historial_altura_21': data.get('sgis_permiso_trabajo_historial_altura_21'),
            'sgis_permiso_trabajo_historial_altura_22': data.get('sgis_permiso_trabajo_historial_altura_22'),
            'sgis_permiso_trabajo_historial_altura_23': data.get('sgis_permiso_trabajo_historial_altura_23'),
            'sgis_permiso_trabajo_historial_altura_24': data.get('sgis_permiso_trabajo_historial_altura_24'),
            'sgis_permiso_trabajo_historial_altura_fecha': fecha,
            'sgis_permiso_trabajo_historial_semanal_altura_firma_tecnico': firma_tecnico_alt,
            'sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor': data.get('sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor')
        }
        # Detectar si la petición es solo firma de supervisor (sin ítems del día)
        try:
            is_signature_only_alt = (
                data.get('sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor') is not None and
                all(data.get(f'sgis_permiso_trabajo_historial_altura_{i}') is None for i in range(1, 25))
            )
        except Exception:
            is_signature_only_alt = False
        try:
            cur.execute(
                """
                SELECT id_sgis_permiso_trabajo_historial_semanal_altura AS id
                FROM sgis_permiso_trabajo_historial_semanal_altura
                WHERE id_sgis_permiso_trabajo=%s AND DATE(sgis_permiso_trabajo_historial_altura_fecha)=%s
                ORDER BY id_sgis_permiso_trabajo_historial_semanal_altura ASC
                LIMIT 1
                """,
                (pid, fecha_cmp)
            )
            existing_day = cur.fetchone()
        except Exception:
            existing_day = None
        # Bloquear firma si no existe registro del día
        if (not existing_day) and is_signature_only_alt:
            return jsonify({'success': False, 'message': 'Solo se puede firmar si ya existe registro del día'}), 400
        if existing_day and (data.get('sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor') is not None):
            try:
                cur.execute(
                    """
                    UPDATE sgis_permiso_trabajo_historial_semanal_altura
                    SET sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor=%s
                    WHERE id_sgis_permiso_trabajo_historial_semanal_altura=%s
                    """,
                    (data.get('sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor'), existing_day.get('id') if isinstance(existing_day, dict) else existing_day[0])
                )
                conn.commit()
                return jsonify({'success': True, 'updated': True}), 200
            except Exception:
                pass
        cur.execute(
            """
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.COLUMNS
            WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo_historial_semanal_altura'
            """
        )
        existing_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cur.fetchall()}
        filtered_items = [(k, v) for k, v in fields.items() if k in existing_cols]
        cols = ",".join([k for k, _ in filtered_items])
        vals = tuple([v for _, v in filtered_items])
        cur.execute(f"INSERT INTO sgis_permiso_trabajo_historial_semanal_altura ({cols}) VALUES ({','.join(['%s']*len(filtered_items))})", vals)
        conn.commit()
        return jsonify({'success': True, 'created': True}), 201
    except Exception as e:
        try:
            conn.rollback()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        try:
            cur.close(); conn.close()
        except Exception:
            pass

# Registro explícito de rutas SGIS Permiso de Trabajo
try:
    app.add_url_rule('/api/sgis/permiso-trabajo', view_func=api_sgis_permiso_trabajo_crear, methods=['POST'])
    app.add_url_rule('/api/sgis/permiso-trabajo/current', view_func=api_sgis_permiso_trabajo_actual, methods=['GET'])
    app.add_url_rule('/api/sgis/permiso-trabajo/historial/confinado', view_func=api_sgis_historial_confinado, methods=['POST','GET'])
    app.add_url_rule('/api/sgis/permiso-trabajo/historial/alturas', view_func=api_sgis_historial_alturas, methods=['POST','GET'])
except Exception:
    pass

# Database configuration
db_config = {
    'host': os.getenv('MYSQL_HOST'),
    'user': os.getenv('MYSQL_USER'),
    'password': os.getenv('MYSQL_PASSWORD'),
    'database': os.getenv('MYSQL_DB'),
    'port': (int(os.getenv('MYSQL_PORT')) if os.getenv('MYSQL_PORT') else None),
    'time_zone': '+00:00'
}

VAPID_PUBLIC_KEY = os.getenv('VAPID_PUBLIC_KEY')
VAPID_PRIVATE_KEY = os.getenv('VAPID_PRIVATE_KEY')
VAPID_SUBJECT = os.getenv('VAPID_SUBJECT') or 'mailto:notificaciones@synapsis.local'

def ensure_webpush_tables():
    try:
        conn = get_db_connection()
        if not conn:
            return
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS webpush_subscriptions (
                id INT AUTO_INCREMENT PRIMARY KEY,
                user_id VARCHAR(64) NOT NULL,
                role VARCHAR(32) NULL,
                subscription_json TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_user (user_id),
                INDEX idx_role (role)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        conn.commit()
        cur.close(); conn.close()
    except Exception:
        pass

ensure_webpush_tables()

# Función para obtener conexión a la base de datos
def get_db_connection():
    try:
        host = os.getenv('MYSQL_HOST') or (db_config.get('host') or 'localhost')
        user = os.getenv('MYSQL_USER') or (db_config.get('user') or 'root')
        password = os.getenv('MYSQL_PASSWORD') or (db_config.get('password') or '732137A031E4b@')
        database = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
        try:
            port = int(os.getenv('MYSQL_PORT') or (db_config.get('port') or 3306))
        except Exception:
            port = 3306
        connection = mysql.connector.connect(
            host=host,
            user=user,
            password=password,
            database=database,
            port=port
        )
        try:
            cur = connection.cursor()
            tz = os.getenv('MYSQL_TIME_ZONE') or '+00:00'
            cur.execute("SET time_zone = %s", (tz,))
            cur.close()
        except Exception:
            pass
        return connection
    except Error as e:
        app.logger.error(f"Error de conexión a MySQL: {str(e)}")
        print(f"Error de conexión a MySQL: {str(e)}")
        return None

# Función para obtener la fecha y hora actual en Bogotá
def get_bogota_datetime():
    return datetime.now(TIMEZONE)

# Función para convertir una fecha UTC a fecha de Bogotá
def convert_to_bogota_time(utc_dt):
    if utc_dt.tzinfo is None:
        utc_dt = pytz.UTC.localize(utc_dt)
    return utc_dt.astimezone(TIMEZONE)

INDICATOR_INDEXES_ENSURED = False

def ensure_indicator_indexes():
    global INDICATOR_INDEXES_ENSURED
    if INDICATOR_INDEXES_ENSURED:
        return
    conn = get_db_connection()
    if conn is None:
        return
    try:
        cur = conn.cursor()
        try:
            cur.execute("SELECT DATABASE()")
            schema_row = cur.fetchone()
            schema = schema_row[0] if schema_row else None
        except Exception:
            schema = None
        def idx_exists(table, index):
            try:
                if schema:
                    cur.execute("SELECT COUNT(*) FROM information_schema.STATISTICS WHERE table_schema=%s AND table_name=%s AND index_name=%s", (schema, table, index))
                else:
                    cur.execute("SELECT COUNT(*) FROM information_schema.STATISTICS WHERE table_name=%s AND index_name=%s", (table, index))
                return (cur.fetchone() or [0])[0] > 0
            except Exception:
                return True
        try:
            if not idx_exists('asistencia', 'idx_asistencia_fecha'):
                cur.execute("CREATE INDEX idx_asistencia_fecha ON asistencia (fecha_asistencia)")
            if not idx_exists('asistencia', 'idx_asistencia_consumidor_fecha'):
                cur.execute("CREATE INDEX idx_asistencia_consumidor_fecha ON asistencia (id_codigo_consumidor, fecha_asistencia)")
            if not idx_exists('preoperacional', 'idx_preop_fecha'):
                cur.execute("CREATE INDEX idx_preop_fecha ON preoperacional (fecha)")
            if not idx_exists('preoperacional', 'idx_preop_consumidor_fecha'):
                cur.execute("CREATE INDEX idx_preop_consumidor_fecha ON preoperacional (id_codigo_consumidor, fecha)")
            if not idx_exists('tipificacion_asistencia', 'idx_tipificacion_codigo'):
                cur.execute("CREATE INDEX idx_tipificacion_codigo ON tipificacion_asistencia (codigo_tipificacion)")
            conn.commit()
        except Exception:
            try:
                conn.rollback()
            except Exception:
                pass
        try:
            cur.close()
        except Exception:
            pass
    finally:
        try:
            conn.close()
        except Exception:
            pass
    INDICATOR_INDEXES_ENSURED = True

# Probar la conexión a la base de datos
try:
    connection = get_db_connection()
    if connection is None:
        raise Exception('Failed to establish a database connection.')
    connection.close()
except Exception as e:
    pass

# Roles definition
ROLES = {
    '1': 'administrativo',
    '2': 'tecnicos',
    '3': 'operativo',
    '4': 'contabilidad',
    '5': 'logistica',
    '6': 'analista',
    '7': 'lider'
}

# Decorador para requerir rol específico
def role_required(role):
    def role_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_role' not in session:
                flash('Por favor inicia sesión para acceder a esta página.', 'warning')
                return redirect(url_for('login'))
            if session.get('user_role') != role and session.get('user_role') != 'administrativo':
                flash('No tienes permisos para acceder a esta página.', 'danger')
                return redirect(url_for('dashboard'))
            return f(*args, **kwargs)
        return decorated_function
    return role_decorator

# Login required decorator personalizado para roles
def role_required_login(role=None):
    def role_login_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if role and not current_user.has_role(role) and current_user.role != 'administrativo':
                flash("No tienes permisos para acceder a esta página.", 'danger')
                return redirect(url_for('login'))
            return f(*args, **kwargs)
        return decorated_function
    return role_login_decorator

# Mantener el decorador original para compatibilidad con código existente
def login_required(role=None):
    """Decorador de autenticación compatible con dos modos:
    - Uso directo: @login_required
    - Uso con argumentos: @login_required() o @login_required(role='...')
    """
    # Modo directo: @login_required
    if callable(role):
        f = role
        role = None

        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                flash('Please log in to access this page.', 'warning')
                return redirect(url_for('login'))

            return f(*args, **kwargs)

        return decorated_function

    # Modo con argumentos: @login_required(...) 
    def login_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                flash('Please log in to access this page.', 'warning')
                return redirect(url_for('login'))

            user_role = session.get('user_role')

            # Si hay un rol requerido y el usuario no es administrativo
            if role and (str(user_role or '').strip().lower() != 'administrativo'):
                if isinstance(role, list):
                    roles_norm = [str(r).strip().lower() for r in role]
                    if str(user_role or '').strip().lower() not in roles_norm:
                        flash("No tienes permisos para acceder a esta página.", 'danger')
                        return redirect(url_for('login'))
                elif str(user_role or '').strip().lower() != str(role or '').strip().lower():
                    flash("No tienes permisos para acceder a esta página.", 'danger')
                    return redirect(url_for('login'))

            return f(*args, **kwargs)

        return decorated_function

    return login_decorator

def login_required_api(role=None):
    """Decorador para requerir autenticación en APIs"""
    def api_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                return jsonify({'error': 'Autenticación requerida', 'code': 'AUTH_REQUIRED'}), 401
            
            if role:
                user_role = session.get('user_role')
                ur = str(user_role or '').strip().lower()
                if isinstance(role, (list, tuple, set)):
                    roles_norm = {str(r).strip().lower() for r in role}
                    if ur not in roles_norm and ur != 'administrativo':
                        return jsonify({'error': 'Permisos insuficientes', 'code': 'INSUFFICIENT_PERMISSIONS'}), 403
                else:
                    req_role = str(role or '').strip().lower()
                    if ur != req_role and ur != 'administrativo':
                        return jsonify({'error': 'Permisos insuficientes', 'code': 'INSUFFICIENT_PERMISSIONS'}), 403
            
            return f(*args, **kwargs)
        return decorated_function
    return api_decorator

def login_required_lider():
    """Decorador específico para el módulo de Líder: administradores, líderes y Sandra Cecilia (52912112)"""
    def lider_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                flash('Please log in to access this page.', 'warning')
                return redirect(url_for('login'))
            
            user_role = session.get('user_role')
            user_cedula = session.get('user_cedula', '')
            
            # Verificar permisos específicos para el módulo de Líder
            # 1. Administradores tienen acceso completo
            # 2. Usuarios con rol 'lider' tienen acceso
            # 3. Sandra Cecilia Cortes Cuervo (cédula: 52912112) tiene acceso especial
            if (user_role == 'administrativo' or 
                user_role == 'lider' or 
                user_cedula == '52912112'):
                return f(*args, **kwargs)
            else:
                flash("No tienes permisos para acceder al módulo de Líder.", 'danger')
                return redirect(url_for('login'))
        
        return decorated_function
    return lider_decorator

def login_required_lider_api():
    """Decorador específico para APIs del módulo de Líder: administradores, líderes y Sandra Cecilia (52912112)"""
    def lider_api_decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                return jsonify({'error': 'Autenticación requerida', 'code': 'AUTH_REQUIRED'}), 401
            
            user_role = session.get('user_role')
            user_cedula = session.get('user_cedula', '')
            
            # Verificar permisos específicos para APIs del módulo de Líder
            # 1. Administradores tienen acceso completo
            # 2. Usuarios con rol 'lider' tienen acceso
            # 3. Sandra Cecilia Cortes Cuervo (cédula: 52912112) tiene acceso especial
            if (user_role == 'administrativo' or 
                user_role == 'lider' or 
                user_cedula == '52912112'):
                return f(*args, **kwargs)
            else:
                return jsonify({'error': 'Permisos insuficientes para el módulo de Líder', 'code': 'INSUFFICIENT_PERMISSIONS'}), 403
        
        return decorated_function
    return lider_api_decorator

def login_required_analistas_or_lider_api():
    def dec(f):
        @wraps(f)
        def inner(*args, **kwargs):
            if 'user_id' not in session:
                return jsonify({'error': 'Autenticación requerida', 'code': 'AUTH_REQUIRED'}), 401
            ur = session.get('user_role')
            uc = session.get('user_cedula', '')
            if (ur in ('analistas', 'analista', 'lider') or ur == 'administrativo' or uc == '52912112'):
                return f(*args, **kwargs)
            return jsonify({'error': 'Permisos insuficientes', 'code': 'INSUFFICIENT_PERMISSIONS'}), 403
        return inner
    return dec

# Detalle de calidades aplicadas (mensual)
@app.route('/api/analistas/actividades-diarias/calidad-detalle', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_actividades_diarias_calidad_detalle():
    user_name = session.get('user_name', '')
    analista_override = request.args.get('analista', '').strip()
    if analista_override:
        ur = session.get('user_role')
        uid = str(session.get('id_codigo_consumidor', ''))
        uc = str(session.get('user_cedula', ''))
        if (ur in ('administrativo','lider')) or uid == '26' or uc == '52912112':
            user_name = analista_override
    fecha = (request.args.get('fecha') or '').strip()
    fecha_norm = fecha
    if fecha:
        for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
            try:
                fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                break
            except Exception:
                pass
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in c.fetchall()}
        def pick(names, approx=None):
            if approx is None:
                approx = []
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            if approx:
                import re
                def norm(s):
                    return re.sub(r"[^a-z0-9]", "", s.lower())
                aset = {norm(x) for x in approx}
                for k0,v0 in cols.items():
                    if norm(k0) in aset:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'], approx=['orden_de_trabajo','ordentrabajo','ot'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'], approx=['numerodecuenta','cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'], approx=['fechaactividad','fechaorden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'], approx=['external_id','exetrnal_id','idexterno','id_externo','cedula'])
        col_estado = pick(['estado'])
        col_cierre = pick(['cierre_ciclo'])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': True, 'items': []})
        c.execute(
            """
            SELECT COLLATION_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='recurso_operativo' AND column_name='analista'
            """,
            (db_config.get('database'),)
        )
        row = c.fetchone()
        coll = row[0] if row and row[0] else 'utf8mb4_general_ci'
        c.execute(
            f"""
            SELECT recurso_operativo_cedula
            FROM recurso_operativo
            WHERE LOWER(TRIM(analista)) COLLATE {coll} = LOWER(TRIM(CAST(%s AS CHAR CHARACTER SET utf8mb4))) COLLATE {coll}
            """,
            (user_name,)
        )
        cedulas = [r[0] for r in c.fetchall()]
        base_date = None
        try:
            base_date = datetime.strptime(fecha_norm or '', '%Y-%m-%d') if fecha_norm else None
        except Exception:
            base_date = None
        if base_date is None:
            try:
                now_str = datetime.now(TIMEZONE).strftime('%Y-%m-%d')
                base_date = datetime.strptime(now_str, '%Y-%m-%d')
            except Exception:
                base_date = datetime.now()
        month_year = base_date.year
        month_month = base_date.month
        items = []
        if cedulas:
            placeholders = ','.join(['%s'] * len(cedulas))
            filtro_mes_sql = ''
            mes_params = []
            try:
                c2 = connection.cursor()
                c2.execute(
                    """
                    SELECT DATA_TYPE FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                    """,
                    (db_config.get('database'), col_fecha)
                )
                rowt = c2.fetchone()
                tipo_fecha2 = str(rowt[0]).lower() if rowt else None
                c2.close()
            except Exception:
                tipo_fecha2 = None
            if tipo_fecha2 in ('datetime','timestamp','date'):
                filtro_mes_sql = f" AND DATE(o.`{col_fecha}`) BETWEEN %s AND %s"
                import calendar as _cal
                month_start = base_date.replace(day=1).strftime('%Y-%m-%d')
                last_day = _cal.monthrange(base_date.year, base_date.month)[1]
                month_end = base_date.replace(day=last_day).strftime('%Y-%m-%d')
                mes_params.extend([month_start, month_end])
            else:
                pref = base_date.strftime('%Y-%m-')
                filtro_mes_sql = f" AND o.`{col_fecha}` LIKE %s"
                mes_params.append(pref + '%')
            sql_det = (
                "SELECT oc.cedula, oc.carpeta, oc.tecnico_nombre AS tecnico, oc.ot, oc.cuenta, oc.agenda, oc.fecha, oc.causa "
                "FROM operaciones_calidad oc "
                "WHERE oc.periodo_year = %s AND oc.periodo_month = %s "
                "AND EXISTS (SELECT 1 FROM operaciones_actividades_diarias o "
                "WHERE CAST(o.`" + col_ext + "` AS CHAR) IN (" + placeholders + ") " + filtro_mes_sql +
                " AND o.`" + col_cuenta + "` IS NOT NULL"
                " AND CAST(o.`" + col_cuenta + "` AS CHAR) <> ''"
                " AND o.`" + col_cuenta + "` REGEXP '^[0-9]+'"
                " AND CAST(o.`" + col_cuenta + "` AS SIGNED) > 0"
                " AND CHAR_LENGTH(CAST(o.`" + col_cuenta + "` AS CHAR)) >= 6"
                " AND LOWER(TRIM(o.`" + col_estado + "`)) = 'completado'"
                " AND CAST(o.`" + col_cierre + "` AS SIGNED) = 1"
                " AND oc.ot = CAST(o.`" + col_ot + "` AS CHAR)"
                ")"
            )
            c3 = connection.cursor(dictionary=True)
            c3.execute(sql_det, (month_year, month_month) + tuple(cedulas) + tuple(mes_params))
            items = c3.fetchall() or []
            c3.close()
        c.close()
        connection.close()
        return jsonify({'success': True, 'items': items})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/register', methods=['GET', 'POST'])
@login_required(role='administrativo')  # Solo los administrativos pueden registrar usuarios
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        role_id = request.form['role_id']

        # Generar salt y hash
        salt = bcrypt.gensalt()
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt).decode('utf-8')

        try:
            connection = get_db_connection()
            if connection is None:
                flash('Error de conexión a la base de datos.', 'error')
                return redirect(url_for('dashboard'))
                
            cursor = connection.cursor(dictionary=True, buffered=True)
            cursor.execute("INSERT INTO recurso_operativo (recurso_operativo_cedula, recurso_operativo_password, id_roles) VALUES (%s, %s, %s)",
                        (username, hashed_password, role_id))
            connection.commit()
            cursor.close()
            connection.close()
            flash('Usuario registrado exitosamente.', 'success')
            return redirect(url_for('dashboard'))
        except Error as e:
            flash(f'Error al registrar usuario: {str(e)}', 'error')
            return redirect(url_for('dashboard'))

    return redirect(url_for('dashboard'))

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        # Añadir logging para depuración
        app.logger.info("Intento de inicio de sesión recibido")
        
        # Obtener credenciales del formulario
        username = request.form.get('username', '')
        password = request.form.get('password', '').encode('utf-8')
        
        # Validación básica
        if not username or not password:
            app.logger.warning("Intento de inicio de sesión con campos vacíos")
            return jsonify({
                'status': 'error', 
                'message': 'Por favor ingrese usuario y contraseña'
            }), 400

        connection = None
        cursor = None
        try:
            # Intentar conexión a la base de datos
            app.logger.info(f"Intentando conectar a la base de datos para usuario: {username}")
            connection = get_db_connection()
            
            if connection is None:
                app.logger.error("Error al conectar con la base de datos")
                return jsonify({
                    'status': 'error', 
                    'message': 'Error de conexión a la base de datos. Por favor intente más tarde.'
                }), 500
                
            cursor = connection.cursor(dictionary=True, buffered=True)
            
            # Buscar usuario
            app.logger.info(f"Consultando usuario con cedula: {username}")
            cursor.execute("SELECT id_codigo_consumidor, id_roles, recurso_operativo_password, nombre, estado, carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (username,))
            user_data = cursor.fetchone()

            # Verificar si el usuario existe
            if not user_data:
                app.logger.warning(f"Usuario no encontrado: {username}")
                return jsonify({
                    'status': 'error', 
                    'message': 'Usuario o contraseña inválidos'
                }), 401
            
            # Verificar si el usuario está activo
            if user_data['estado'] != 'Activo':
                app.logger.warning(f"Intento de acceso de usuario inactivo: {username} - Estado: {user_data['estado']}")
                return jsonify({
                    'status': 'error', 
                    'message': 'Su cuenta se encuentra inactiva. Contacte al administrador para más información.'
                }), 403
            
            # Verificar contraseña
            app.logger.info("Verificando contraseña")
            stored_password = user_data['recurso_operativo_password']
            
            # Asegurar que stored_password es bytes
            if isinstance(stored_password, str):
                stored_password = stored_password.encode('utf-8')
            
            # Verificar si el hash está en formato correcto
            if not stored_password.startswith(b'$2b$') and not stored_password.startswith(b'$2a$'):
                app.logger.error(f"Formato de contraseña inválido para usuario: {username}")
                return jsonify({
                    'status': 'error', 
                    'message': 'Error en el formato de la contraseña almacenada. Contacte al administrador.'
                }), 500
            
            try:
                # Verificar contraseña con bcrypt
                if bcrypt.checkpw(password, stored_password):
                    app.logger.info(f"Inicio de sesión exitoso para: {username}")
                    
                    # Crear objeto User para Flask-Login
                    role_calc = ROLES.get(str(user_data['id_roles']))
                    if str(user_data.get('carpeta') or '').strip().upper() == 'SUPERVISORES':
                        role_calc = 'operativo'
                    user = User(
                        id=user_data['id_codigo_consumidor'],
                        nombre=user_data['nombre'],
                        role=role_calc
                    )
                    
                    # Iniciar sesión con Flask-Login
                    login_user(user)
                    
                    # Mantener también las variables de sesión para compatibilidad
                    session['user_id'] = user_data['id_codigo_consumidor']
                    session['id_codigo_consumidor'] = user_data['id_codigo_consumidor']  # Agregar para compatibilidad
                    session['user_cedula'] = username  # Guardar la cédula del usuario
                    session['user_role'] = role_calc
                    session['user_name'] = user_data['nombre']
                    
                    app.logger.info(f"Sesión establecida: ID={user_data['id_codigo_consumidor']}, Rol={ROLES.get(str(user_data['id_roles']))}")

                    # Verificar vencimientos para el usuario
                    try:
                        cursor.execute("""
                            SELECT 
                                fecha_vencimiento_licencia,
                                fecha_vencimiento_soat,
                                fecha_vencimiento_tecnomecanica
                            FROM preoperacional 
                            WHERE id_codigo_consumidor = %s
                            ORDER BY fecha DESC 
                            LIMIT 1
                        """, (user_data['id_codigo_consumidor'],))
                        
                        ultimo_registro = cursor.fetchone()
                        if ultimo_registro:
                            fecha_actual = datetime.now().date()
                            mensajes_vencimiento = []
                            
                            if ultimo_registro['fecha_vencimiento_licencia']:
                                dias_licencia = (ultimo_registro['fecha_vencimiento_licencia'] - fecha_actual).days
                                if 0 <= dias_licencia <= 30:
                                    mensajes_vencimiento.append(f'Tu licencia de conducción vence en {dias_licencia} días')
                            
                            if ultimo_registro['fecha_vencimiento_soat']:
                                dias_soat = (ultimo_registro['fecha_vencimiento_soat'] - fecha_actual).days
                                if 0 <= dias_soat <= 30:
                                    mensajes_vencimiento.append(f'El SOAT vence en {dias_soat} días')
                            
                            if ultimo_registro['fecha_vencimiento_tecnomecanica']:
                                dias_tecno = (ultimo_registro['fecha_vencimiento_tecnomecanica'] - fecha_actual).days
                                if 0 <= dias_tecno <= 30:
                                    mensajes_vencimiento.append(f'La tecnomecánica vence en {dias_tecno} días')
                            
                            if mensajes_vencimiento:
                                flash('¡ATENCIÓN! ' + '. '.join(mensajes_vencimiento), 'warning')
                    except Exception as e:
                        app.logger.error(f"Error al verificar vencimientos: {str(e)}")
                        # No bloqueamos el inicio de sesión por este error
                    
                    # Cerrar conexión a la base de datos
                    if cursor:
                        cursor.close()
                    if connection:
                        connection.close()

                    # Si la solicitud espera JSON, devolver respuesta JSON
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return jsonify({
                            'status': 'success',
                            'message': 'Inicio de sesión exitoso',
                            'user_id': user_data['id_codigo_consumidor'],
                            'user_role': ROLES.get(str(user_data['id_roles'])),
                            'user_name': user_data['nombre'],
                            'redirect_url': url_for('dashboard')
                        })
                    # Si es una solicitud normal, redirigir
                    return redirect(url_for('dashboard'))
                else:
                    app.logger.warning(f"Contraseña incorrecta para usuario: {username}")
                    return jsonify({
                        'status': 'error', 
                        'message': 'Usuario o contraseña inválidos'
                    }), 401
            except Exception as e:
                app.logger.error(f"Error al verificar contraseña: {str(e)}")
                return jsonify({
                    'status': 'error', 
                    'message': 'Error al verificar credenciales. Intente nuevamente.'
                }), 500

        except mysql.connector.Error as e:
            app.logger.error(f"Error de MySQL: {str(e)}")
            return jsonify({
                'status': 'error', 
                'message': f'Error de base de datos: {str(e)}'
            }), 500
        except Exception as e:
            app.logger.error(f"Error inesperado: {str(e)}")
            # Imprimir stack trace para depuración
            import traceback
            app.logger.error(traceback.format_exc())
            return jsonify({
                'status': 'error', 
                'message': 'Error interno del servidor. Por favor contacte al administrador.'
            }), 500
        finally:
            # Asegurarse de cerrar los recursos
            if cursor:
                cursor.close()
            if connection:
                connection.close()
            app.logger.info("Recursos de base de datos liberados")

    # Para solicitudes GET simplemente mostrar la plantilla de login
    return render_template('login.html')

# Redirigir la ruta raíz a la página de login para consistencia y aceptar POST
@app.route('/', methods=['GET', 'POST'])
def root():
    if request.method == 'POST':
        # Delegar a la misma lógica de login para compatibilidad con clientes que postean a '/'
        return login()
    return redirect(url_for('login'))

@app.route('/logout', methods=['GET', 'POST'])
def logout():
    # Obtener el rol del usuario antes de cerrar sesión para personalizar el mensaje
    user_role = session.get('user_role', '')
    
    # Cerrar sesión con Flask-Login
    logout_user()
    
    # Limpiar todas las variables de sesión
    session.clear()
    
    # Asegurarse de que la sesión se elimine
    if session.get('user_id'):
        session.pop('user_id')
    if session.get('user_role'):
        session.pop('user_role')
    
    # Mensaje personalizado según el rol
    if user_role:
        flash(f'Has cerrado sesión exitosamente. ¡Hasta pronto, {user_role.title()}!', 'info')
    else:
        flash('Has cerrado sesión exitosamente.', 'info')
    
    # Redirigir al login
    return redirect(url_for('login'))

# ============================================================================
# MÓDULO ANALISTAS - RUTAS PRINCIPALES
# ============================================================================

@app.route('/analistas')
@login_required()
def main_analistas_index():
    """Renderizar el dashboard del módulo analistas"""
    return render_template('modulos/analistas/dashboard.html')

@app.route('/analistas/causas')
@login_required()
def main_analistas_causas():
    """Renderizar la página de causas de cierre"""
    return render_template('modulos/analistas/index.html')

@app.route('/analistas/dashboard')
@login_required()
def main_analistas_dashboard():
    """Renderizar el dashboard del módulo analistas"""
    return render_template('modulos/analistas/dashboard.html')

@app.route('/analistas/codigos')
@login_required()
def main_analistas_codigos():
    """Renderizar la página de códigos de facturación"""
    return render_template('modulos/analistas/codigos.html')

@app.route('/analistas/inicio-operacion-tecnicos')
@login_required()
def main_inicio_operacion_tecnicos():
    """Renderizar la página de inicio de operación para técnicos"""
    return render_template('inicio_operacion_tecnicos.html')

@app.route('/analistas/actividades-diarias')
@login_required()
def analistas_actividades_diarias():
    try:
        return render_template('modulos/lider/actividades-diarias.html', api_endpoint='/api/analistas/cargar-actividades', list_endpoint='/api/analistas/actividades-diarias', mostrar_cargue=False)
    except Exception as e:
        flash(f'Error al cargar actividades diarias: {str(e)}', 'danger')
        return redirect(url_for('main_analistas_dashboard'))

# ============================================================================
# MÓDULO ANALISTAS - API ENDPOINTS Códigos de Facturación
# ============================================================================

@app.route('/api/analistas/codigos', methods=['GET'])
@login_required()
def api_codigos_facturacion():
    """Lista de códigos de facturación con filtros opcionales"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS preoperacional_excepciones (
                id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(32),
                id_codigo_consumidor INT NULL,
                fecha DATE NOT NULL,
                fecha_inicio DATE NULL,
                fecha_fin DATE NULL,
                supervisor VARCHAR(255) NULL,
                motivo VARCHAR(255) NULL,
                activo TINYINT(1) NOT NULL DEFAULT 1,
                creado_por VARCHAR(64) NULL,
                creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_fecha_cedula (fecha, cedula),
                INDEX idx_fecha_id (fecha, id_codigo_consumidor)
            )
            """
        )
        connection.commit()

        texto_busqueda = request.args.get('busqueda', '').strip()
        tecnologia = request.args.get('tecnologia', '').strip()
        agrupacion = request.args.get('agrupacion', '').strip()
        grupo = request.args.get('grupo', '').strip()

        query = """
            SELECT 
                id_base_codigos_facturacion AS idbase_codigos_facturacion,
                codigo AS codigo_codigos_facturacion,
                descripcion AS nombre_codigos_facturacion,
                tecnologia,
                '' AS instrucciones_de_uso_codigos_facturacion,
                categoria,
                nombre,
                0 AS facturable_codigos_facturacion
            FROM base_codigos_facturacion
            WHERE 1=1
        """
        params = []

        if texto_busqueda:
            query += """
                AND (
                    codigo LIKE %s OR 
                    descripcion LIKE %s
                )
            """
            busqueda_param = f"%{texto_busqueda}%"
            params.extend([busqueda_param, busqueda_param])
        if tecnologia:
            query += " AND tecnologia = %s"
            params.append(tecnologia)
        if agrupacion:
            query += " AND categoria = %s"
            params.append(agrupacion)
        if grupo:
            query += " AND nombre = %s"
            params.append(grupo)

        query += " ORDER BY codigo ASC"
        cursor.execute(query, params)
        resultados = cursor.fetchall()
        return jsonify(resultados)

    except mysql.connector.Error as e:
        logging.error(f"Error en API codigos: {str(e)}")
        return jsonify({'error': 'Error al consultar la base de datos'}), 500
    except Exception as e:
        logging.error(f"Error inesperado en API codigos: {str(e)}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/analistas/codigos/grupos', methods=['GET'])
@login_required()
def api_grupos_codigos_facturacion():
    """Lista única de grupos en códigos de facturación"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        tecnologia = request.args.get('tecnologia', '').strip()
        agrupacion = request.args.get('agrupacion', '').strip()

        query = """
            SELECT DISTINCT nombre
            FROM base_codigos_facturacion
            WHERE nombre IS NOT NULL 
              AND nombre != ''
        """
        params = []
        if tecnologia:
            query += " AND tecnologia = %s"
            params.append(tecnologia)
        if agrupacion:
            query += " AND categoria = %s"
            params.append(agrupacion)
        query += " ORDER BY nombre ASC"

        cursor.execute(query, params) if params else cursor.execute(query)
        resultados = cursor.fetchall()
        grupos = [row[0] for row in resultados]
        return jsonify(grupos)

    except mysql.connector.Error as e:
        logging.error(f"Error en API grupos codigos: {str(e)}")
        return jsonify({'error': 'Error al consultar la base de datos'}), 500
    except Exception as e:
        logging.error(f"Error inesperado en API grupos codigos: {str(e)}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/analistas/codigos/tecnologias', methods=['GET'])
@login_required()
def api_tecnologias_codigos_facturacion():
    """Lista única de tecnologías en códigos de facturación"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        query = """
            SELECT DISTINCT tecnologia
            FROM base_codigos_facturacion
            WHERE tecnologia IS NOT NULL 
              AND tecnologia != ''
            ORDER BY tecnologia ASC
        """
        cursor.execute(query)
        resultados = cursor.fetchall()
        tecnologias = [row[0] for row in resultados]
        return jsonify(tecnologias)

    except mysql.connector.Error as e:
        logging.error(f"Error en API tecnologias codigos: {str(e)}")
        return jsonify({'error': 'Error al consultar la base de datos'}), 500
    except Exception as e:
        logging.error(f"Error inesperado en API tecnologias codigos: {str(e)}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/analistas/codigos/agrupaciones', methods=['GET'])
@login_required()
def api_agrupaciones_codigos_facturacion():
    """Lista única de agrupaciones en códigos de facturación, opcional por tecnología"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        tecnologia = request.args.get('tecnologia', '').strip()
        if tecnologia:
            query = """
                SELECT DISTINCT categoria
                FROM base_codigos_facturacion
                WHERE categoria IS NOT NULL 
                  AND categoria != ''
                  AND tecnologia = %s
                ORDER BY categoria ASC
            """
            cursor.execute(query, (tecnologia,))
        else:
            query = """
                SELECT DISTINCT categoria
                FROM base_codigos_facturacion
                WHERE categoria IS NOT NULL 
                  AND categoria != ''
                ORDER BY categoria ASC
            """
            cursor.execute(query)

        resultados = cursor.fetchall()
        agrupaciones = [row[0] for row in resultados]
        return jsonify(agrupaciones)

    except mysql.connector.Error as e:
        logging.error(f"Error en API agrupaciones codigos: {str(e)}")
        return jsonify({'error': 'Error al consultar la base de datos'}), 500
    except Exception as e:
        logging.error(f"Error inesperado en API agrupaciones codigos: {str(e)}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/tecnicos')
@login_required(role='tecnicos')
def tecnicos_dashboard():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            resp = make_response(render_template('modulos/tecnicos/dashboard.html', supervisor=None, tiene_asistencia=False, comparendos_resumen=None))
            resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
            resp.headers['Pragma'] = 'no-cache'
            resp.headers['Expires'] = '0'
            return resp
        cursor = connection.cursor(dictionary=True, buffered=True)
        cursor.execute(
            """
            SELECT super FROM capired.recurso_operativo
            WHERE id_codigo_consumidor = %s
            """,
            (session['id_codigo_consumidor'],),
        )
        supervisor_result = cursor.fetchone()
        supervisor_tecnico = supervisor_result['super'] if supervisor_result and supervisor_result['super'] else None
        cursor.execute(
            """
            SELECT recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
            """,
            (session['id_codigo_consumidor'],),
        )
        usuario_actual = cursor.fetchone()
        if usuario_actual and usuario_actual['recurso_operativo_cedula'] == '52912112':
            tiene_asistencia = True
        else:
            fecha_hoy = datetime.now().strftime('%Y-%m-%d')
            cursor.execute(
                """
                SELECT COUNT(*) as registros_hoy
                FROM asistencia 
                WHERE id_codigo_consumidor = %s AND DATE(fecha_asistencia) = %s AND carpeta_dia != '0'
                """,
                (session['id_codigo_consumidor'], fecha_hoy),
            )
            registro_existente = cursor.fetchone()
            tiene_asistencia = registro_existente['registros_hoy'] > 0 if registro_existente else False
        comparendos_resumen = None
        tecnico_id = session.get('id_codigo_consumidor')
        if tecnico_id:
            cursor.execute(
                """
                SELECT placa 
                FROM mpa_vehiculos 
                WHERE tecnico_asignado = %s AND estado = 'Activo' 
                ORDER BY fecha_creacion DESC 
                LIMIT 1
                """,
                (tecnico_id,),
            )
            row_placa = cursor.fetchone()
            placa_tecnico = row_placa['placa'] if row_placa and row_placa.get('placa') else None
            if placa_tecnico:
                cursor.execute(
                    """
                    SELECT placa, cantidad, valor_total, fuente, fecha_ultima_consulta 
                    FROM mpa_comparendos 
                    WHERE UPPER(TRIM(placa)) = %s 
                    ORDER BY fecha_ultima_consulta DESC 
                    LIMIT 1
                    """,
                    (placa_tecnico.strip().upper(),),
                )
                row_cmp = cursor.fetchone()
                if row_cmp:
                    try:
                        valor_total = float(row_cmp.get('valor_total') or 0.0)
                    except Exception:
                        valor_total = 0.0
                    try:
                        cantidad = int(str(row_cmp.get('cantidad') or 0).strip())
                    except Exception:
                        cantidad = 0
                    fecha_ult = row_cmp.get('fecha_ultima_consulta')
                    if fecha_ult:
                        try:
                            fecha_ult = fecha_ult.strftime('%Y-%m-%d %H:%M')
                        except Exception:
                            fecha_ult = str(fecha_ult)
                    comparendos_resumen = {
                        'placa': row_cmp.get('placa') or placa_tecnico,
                        'cantidad': cantidad,
                        'valor_total': valor_total,
                        'fuente': row_cmp.get('fuente'),
                        'fecha_ultima_consulta': fecha_ult,
                    }
        resp = make_response(
            render_template(
                'modulos/tecnicos/dashboard.html',
                supervisor=supervisor_tecnico,
                tiene_asistencia=tiene_asistencia,
                comparendos_resumen=comparendos_resumen,
            )
        )
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
        return resp
    except mysql.connector.Error as e:
        flash(f'Error al cargar datos del supervisor: {str(e)}', 'warning')
        resp = make_response(render_template('modulos/tecnicos/dashboard.html', supervisor=None, tiene_asistencia=False, comparendos_resumen=None))
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
        return resp
    finally:
        if 'cursor' in locals() and cursor:
            try:
                while cursor.nextset():
                    pass
            except Exception:
                pass
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/metas-indicadores', methods=['GET'])
@login_required_lider_api()
def api_get_metas_indicadores():
    connection = None
    cursor = None
    try:
        area = request.args.get('area', '').strip()
        periodo_str = request.args.get('periodo')
        from datetime import datetime
        hoy = datetime.now()
        if not periodo_str:
            periodo_str = f"{hoy.year}-{str(hoy.month).zfill(2)}"
        try:
            anio, mes = periodo_str.split('-')
            periodo_fecha = datetime(int(anio), int(mes), 1).strftime('%Y-%m-%d')
        except Exception:
            return jsonify({'error': 'Periodo inválido'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS metas_indicadores (
                id INT AUTO_INCREMENT PRIMARY KEY,
                area VARCHAR(50) NOT NULL,
                periodo DATE NOT NULL,
                meta_porcentaje DECIMAL(5,2) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uniq_area_periodo (area, periodo)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
        """)
        if not area:
            return jsonify({'error': 'Área requerida'}), 400
        cursor.execute(
            "SELECT meta_porcentaje FROM metas_indicadores WHERE area=%s AND periodo=%s",
            (area, periodo_fecha)
        )
        row = cursor.fetchone()
        meta = row['meta_porcentaje'] if row else None
        try:
            meta = float(meta) if meta is not None else None
        except Exception:
            meta = None
        return jsonify({
            'success': True,
            'area': area,
            'periodo': periodo_str,
            'meta_porcentaje': meta
        })
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/metas-indicadores', methods=['POST'])
@login_required_lider_api()
def api_set_metas_indicadores():
    connection = None
    cursor = None
    try:
        data = request.get_json() or {}
        area = (data.get('area') or '').strip()
        periodo_str = data.get('periodo')
        meta_val = data.get('meta_porcentaje')
        if not area or not periodo_str or meta_val is None:
            return jsonify({'error': 'Datos incompletos'}), 400
        try:
            meta_num = float(meta_val)
        except Exception:
            return jsonify({'error': 'Meta inválida'}), 400
        if meta_num < 0 or meta_num > 100:
            return jsonify({'error': 'Meta fuera de rango'}), 400
        from datetime import datetime
        try:
            anio, mes = periodo_str.split('-')
            periodo_fecha = datetime(int(anio), int(mes), 1).strftime('%Y-%m-%d')
        except Exception:
            return jsonify({'error': 'Periodo inválido'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS metas_indicadores (
                id INT AUTO_INCREMENT PRIMARY KEY,
                area VARCHAR(50) NOT NULL,
                periodo DATE NOT NULL,
                meta_porcentaje DECIMAL(5,2) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uniq_area_periodo (area, periodo)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
        """)
        cursor.execute(
            """
            INSERT INTO metas_indicadores (area, periodo, meta_porcentaje)
            VALUES (%s, %s, %s)
            ON DUPLICATE KEY UPDATE meta_porcentaje = VALUES(meta_porcentaje)
            """,
            (area, periodo_fecha, meta_num)
        )
        connection.commit()
        return jsonify({'success': True})
    except mysql.connector.Error as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()
@app.route('/tecnicos/asignaciones_ferretero')
@login_required(role='tecnicos')
def tecnicos_asignaciones_ferretero():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return render_template('modulos/tecnicos/asignaciones_ferretero.html', asignaciones=[])
            
        cursor = connection.cursor(dictionary=True, buffered=True)
        
        # Obtener las asignaciones de ferretero del técnico logueado
        cursor.execute("""
            SELECT 
                id_ferretero,
                fecha_asignacion,
                silicona,
                amarres_negros,
                amarres_blancos,
                cinta_aislante,
                grapas_negras,
                grapas_blancas,
                id_codigo_consumidor
            FROM ferretero 
            WHERE id_codigo_consumidor = %s
            ORDER BY fecha_asignacion DESC
        """, (session['id_codigo_consumidor'],))
        
        asignaciones = cursor.fetchall()
        
        # Formatear las fechas para mejor visualización
        for asignacion in asignaciones:
            if asignacion['fecha_asignacion']:
                asignacion['fecha_formateada'] = asignacion['fecha_asignacion'].strftime('%d/%m/%Y %H:%M')
            else:
                asignacion['fecha_formateada'] = 'N/A'
        
        return render_template('modulos/tecnicos/asignaciones_ferretero.html', asignaciones=asignaciones)
        
    except mysql.connector.Error as e:
        flash(f'Error al cargar asignaciones: {str(e)}', 'danger')
        return render_template('modulos/tecnicos/asignaciones_ferretero.html', asignaciones=[])
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/tecnicos/ordenes_trabajo')
@login_required(role='tecnicos')
def tecnicos_ordenes_trabajo():
    try:
        return render_template('modulos/tecnicos/ordenes_trabajo.html')
    except Exception as e:
        flash(f'Error al cargar Órdenes de Trabajo: {str(e)}', 'danger')
        return render_template('modulos/tecnicos/ordenes_trabajo.html')

@app.route('/tecnicos/ordenes_trabajo_preview')
@login_required(role='tecnicos')
def tecnicos_ordenes_trabajo_preview():
    try:
        return render_template('modulos/tecnicos/ordenes_trabajo.html')
    except Exception as e:
        flash(f'Error al cargar Órdenes de Trabajo (preview): {str(e)}', 'danger')
        return render_template('modulos/tecnicos/ordenes_trabajo.html')

# Vista de preview de Órdenes de Trabajo para analistas
@app.route('/analistas/ordenes_trabajo_preview')
@login_required(role=['analista','analistas'])
def analistas_ordenes_trabajo_preview():
    try:
        return render_template('modulos/tecnicos/ordenes_trabajo.html', modal_only=True)
    except Exception as e:
        flash(f'Error al cargar Órdenes de Trabajo (analistas): {str(e)}', 'danger')
        return render_template('modulos/tecnicos/ordenes_trabajo.html', modal_only=True)

# ==================== APIs ÓRDENES DE TRABAJO - TÉCNICOS ====================

# Listar órdenes del técnico logueado
@app.route('/tecnicos/ordenes', methods=['GET'])
@app.route('/api/tecnicos/ordenes', methods=['GET'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_list_ordenes():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)

        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        if not user_id:
            return jsonify({'success': False, 'error': 'Usuario no autenticado'}), 401

        # Obtener órdenes desde tabla principal
        cursor.execute(
            """
            SELECT 
                ot,
                MIN(cuenta) AS cuenta,
                MIN(servicio) AS servicio,
                MIN(tecnologia) AS tecnologia,
                MIN(agrupacion) AS categoria,
                SUM(COALESCE(valor, 0) * COALESCE(cantidad, 1)) AS total_valor,
                MIN(fecha_creacion) AS fecha_creacion,
                MAX(fecha_creacion) AS fecha_actualizacion
            FROM gestion_ot_tecnicos
            WHERE id_codigo_consumidor = %s
            GROUP BY ot
            ORDER BY fecha_actualizacion DESC
            """,
            (user_id,)
        )
        rows = cursor.fetchall()

        # Obtener cantidad de códigos por OT desde historial
        ots = [row['ot'] for row in rows if row.get('ot') is not None]
        codigos_por_ot = {}
        if ots:
            format_strings = ','.join(['%s'] * len(ots))
            cursor.execute(
                f"""
                SELECT ot, COUNT(*) as cantidad_codigos
                FROM gestion_ot_tecnicos_historial
                WHERE ot IN ({format_strings})
                GROUP BY ot
                """,
                ots
            )
            codigos_por_ot = {row['ot']: row['cantidad_codigos'] for row in cursor.fetchall()}

        ordenes = []
        for r in rows:
            ordenes.append({
                'id': r.get('id'),
                'ot': r.get('ot'),
                'cuenta': r.get('cuenta'),
                'servicio': r.get('servicio'),
                'tecnologia': r.get('tecnologia'),
                'categoria': r.get('categoria'),
                'tecnico_nombre': r.get('tecnico_nombre'),
                'total_valor': float(r.get('total_valor', 0)),
                'cantidad_codigos': codigos_por_ot.get(r.get('ot'), 0),
                'fecha_creacion': r.get('fecha_creacion').strftime('%Y-%m-%d %H:%M:%S') if r.get('fecha_creacion') else None,
                'fecha_actualizacion': r.get('fecha_actualizacion').strftime('%Y-%m-%d %H:%M:%S') if r.get('fecha_actualizacion') else None
            })

        return jsonify({'success': True, 'ordenes': ordenes})
    except Exception as e:
        try:
            app.logger.error(f"SGIS dashboard-stats error: {e}")
        except Exception:
            pass
        return jsonify({'success': True, 'data': {'total_preop': 0, 'epp_ok': 0, 'epp_alertas': 0, 'reportes': 0}})
    finally:
        try:
            if cursor:
                cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except:
            pass

# Ver detalle de una orden por OT desde tabla historial
@app.route('/tecnicos/ordenes/detalle/<ot>', methods=['GET'])
@app.route('/api/tecnicos/ordenes/detalle/<ot>', methods=['GET'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_get_orden_detalle(ot):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)

        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        if not user_id:
            return jsonify({'success': False, 'error': 'Usuario no autenticado'}), 401

        # Obtener información general de la OT desde tabla principal
        cursor.execute(
            """
            SELECT 
                MIN(id_gestion_ot_tecnicos) AS id,
                ot,
                MIN(cuenta) AS cuenta,
                MIN(servicio) AS servicio,
                MIN(tecnologia) AS tecnologia,
                MIN(agrupacion) AS categoria,
                SUM(COALESCE(valor, 0) * COALESCE(cantidad, 1)) AS total_valor,
                MIN(fecha_creacion) AS fecha_creacion,
                MAX(fecha_creacion) AS fecha_actualizacion
            FROM gestion_ot_tecnicos
            WHERE ot = %s AND id_codigo_consumidor = %s
            GROUP BY ot
            """,
            (ot, user_id)
        )
        ot_info = cursor.fetchone()
        if not ot_info:
            return jsonify({'success': False, 'error': 'OT no encontrada'}), 404

        # Obtener todos los códigos de la OT desde tabla historial
        cursor.execute(
            """
            SELECT 
                id_gestion_ot_tecnicos_historial AS id,
                codigo,
                nombre,
                descripcion,
                cantidad,
                valor AS valor_unitario,
                (COALESCE(valor, 0) * COALESCE(cantidad, 1)) AS valor_total,
                fecha_creacion
            FROM gestion_ot_tecnicos_historial
            WHERE ot = %s AND id_codigo_consumidor = %s
            ORDER BY fecha_creacion ASC
            """,
            (ot, user_id)
        )
        codigos = cursor.fetchall()

        # Obtener nombre del técnico desde recurso_operativo
        cursor.execute(
            """
            SELECT nombre FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
            """,
            (user_id,)
        )
        tecnico_res = cursor.fetchone()
        tecnico_nombre = (tecnico_res.get('nombre') if isinstance(tecnico_res, dict) else (tecnico_res[0] if tecnico_res else None)) or 'Técnico'

        orden_detalle = {
            'id': ot_info.get('id'),
            'ot': ot_info['ot'],
            'cuenta': ot_info['cuenta'],
            'servicio': ot_info['servicio'],
            'tecnologia': ot_info['tecnologia'],
            'categoria': ot_info['categoria'],
            'tecnico_nombre': tecnico_nombre,
            'total_valor': float(ot_info['total_valor']),
            'fecha_creacion': ot_info['fecha_creacion'].strftime('%Y-%m-%d %H:%M:%S') if ot_info['fecha_creacion'] else None,
            'fecha_actualizacion': ot_info['fecha_actualizacion'].strftime('%Y-%m-%d %H:%M:%S') if ot_info['fecha_actualizacion'] else None,
            'codigos': [{
                'id': c['id'],
                'codigo': c['codigo'],
                'nombre': c['nombre'],
                'descripcion': c['descripcion'] or '',
                'cantidad': c['cantidad'],
                'valor_unitario': float(c['valor_unitario']),
                'valor_total': float(c['valor_total']),
                'fecha_creacion': c['fecha_creacion'].strftime('%Y-%m-%d %H:%M:%S') if c['fecha_creacion'] else None
            } for c in codigos]
        }

        return jsonify({'success': True, 'data': orden_detalle})
    except Exception as e:
        app.logger.error('[api_tecnicos_get_orden_detalle] error: %s', e, exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        try:
            if cursor:
                cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except:
            pass

# Crear nueva orden (guarda resumen en principal y detalles en historial)
@app.route('/tecnicos/ordenes', methods=['POST'])
@app.route('/api/tecnicos/ordenes', methods=['POST'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_create_orden():
    import traceback
    try:
        data = request.get_json() or {}
        app.logger.info('[api_tecnicos_create_orden] payload recibido: %s', data)
        required = ['ot', 'cuenta', 'tecnologia', 'codigos']
        for field in required:
            if field not in data or (field == 'codigos' and not isinstance(data['codigos'], list)):
                app.logger.warning('[api_tecnicos_create_orden] faltante/invalid: %s', field)
                return jsonify({'success': False, 'error': f'Campo requerido faltante o inválido: {field}'}), 400

        # Validaciones de tipos básicos
        try:
            ot = int(str(data.get('ot', '')).strip())
            cuenta = int(str(data.get('cuenta', '')).strip())
        except Exception:
            app.logger.error('[api_tecnicos_create_orden] tipos inválidos para ot/cuenta', exc_info=True)
            return jsonify({'success': False, 'error': 'OT/Cuenta deben ser numéricos'}), 400
        # Servicio ya no es requerido: default 0 si no viene
        try:
            servicio = int(str(data.get('servicio', '0')).strip() or '0')
        except Exception:
            servicio = 0

        tecnologia = data.get('tecnologia')
        if not tecnologia:
            return jsonify({'success': False, 'error': 'Tecnología requerida'}), 400

        connection = get_db_connection()
        if connection is None:
            app.logger.error('[api_tecnicos_create_orden] conexión DB es None')
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        if not user_id:
            app.logger.error('[api_tecnicos_create_orden] usuario no autenticado en sesión')
            return jsonify({'success': False, 'error': 'Usuario no autenticado'}), 401

        categoria = data.get('categoria') or None
        observacion = data.get('observacion') or None
        now = datetime.now()

        # Validar unicidad de OT por usuario: si ya existe y pertenece a otro usuario, bloquear
        try:
            cursor.execute(
                """
                SELECT id_codigo_consumidor, nombre, fecha_creacion
                FROM gestion_ot_tecnicos
                WHERE ot = %s
                ORDER BY fecha_creacion DESC
                LIMIT 1
                """,
                (ot,)
            )
            ot_existente = cursor.fetchone()
        except Exception:
            app.logger.error('[api_tecnicos_create_orden] Error consultando existencia de OT', exc_info=True)
            ot_existente = None

        if ot_existente:
            existing_user_id = ot_existente[0]
            if int(existing_user_id) != int(user_id):
                existing_user_name = None
                try:
                    existing_user_name = ot_existente[1]
                except Exception:
                    existing_user_name = None
                app.logger.warning('[api_tecnicos_create_orden] OT %s ya creada por otro técnico (owner_id=%s)', ot, existing_user_id)
                return jsonify({
                    'success': False,
                    'error': 'OT ya creada por otro técnico',
                    'message': 'La OT ya se encuentra registrada por otro usuario.',
                    'owner_id': int(existing_user_id),
                    'owner_name': existing_user_name
                }), 409
            else:
                app.logger.info('[api_tecnicos_create_orden] La OT %s ya pertenece al usuario actual (%s); se permiten agregar más códigos', ot, user_id)

        # Obtener nombre del técnico
        cursor.execute(
            """
            SELECT nombre FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
            """,
            (user_id,)
        )
        tecnico_result = cursor.fetchone()
        tecnico_nombre = tecnico_result[0] if tecnico_result else 'Técnico'

        # Calcular total valor de todos los códigos
        total_valor = 0
        for item in data['codigos']:
            cantidad = int(item.get('cantidad') or 1)
            valor_unitario_raw = item.get('valor_unitario') or item.get('valor') or 0
            try:
                valor_unitario = int(float(valor_unitario_raw))
            except Exception:
                valor_unitario = 0
            total_valor += (valor_unitario or 0) * (cantidad or 1)

        # Insertar cada código como fila principal en gestion_ot_tecnicos (estructura real)
        insert_sql_principal = (
            """
            INSERT INTO gestion_ot_tecnicos (
                ot, cuenta, servicio, codigo, tecnologia, agrupacion,
                nombre, observacion, fecha_creacion, id_codigo_consumidor,
                cantidad, valor, descripcion
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
        )
        # Insertar también en historial (usa `ot`, no `ot_id`)
        insert_sql_historial = (
            """
            INSERT INTO gestion_ot_tecnicos_historial (
                id_codigo_consumidor, ot, cuenta, servicio, codigo, tecnologia, agrupacion,
                nombre, observacion, fecha_creacion, cantidad, valor, descripcion
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
        )
        # Fallback con ID explícito si la columna no es AUTO_INCREMENT
        insert_sql_historial_with_id = (
            """
            INSERT INTO gestion_ot_tecnicos_historial (
                id_gestion_ot_tecnicos_historial, id_codigo_consumidor, ot, cuenta, servicio, codigo, tecnologia, agrupacion,
                nombre, observacion, fecha_creacion, cantidad, valor, descripcion
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
        )
        # Intentar asegurar que el ID del historial sea AUTO_INCREMENT
        try:
            cursor.execute("SHOW COLUMNS FROM gestion_ot_tecnicos_historial LIKE 'id_gestion_ot_tecnicos_historial'")
            col = cursor.fetchone()
            # col formato: Field, Type, Null, Key, Default, Extra
            if col and len(col) >= 6 and (not col[5] or 'auto_increment' not in str(col[5]).lower()):
                app.logger.warning('[api_tecnicos_create_orden] id_gestion_ot_tecnicos_historial no es AUTO_INCREMENT, intentando corregir esquema')
                try:
                    cursor.execute("""
                        ALTER TABLE gestion_ot_tecnicos_historial 
                        MODIFY id_gestion_ot_tecnicos_historial INT NOT NULL AUTO_INCREMENT
                    """)
                    app.logger.info('[api_tecnicos_create_orden] Esquema corregido: id_gestion_ot_tecnicos_historial ahora es AUTO_INCREMENT')
                except Exception as alter_err:
                    app.logger.error('[api_tecnicos_create_orden] No se pudo alterar la tabla historial: %s', str(alter_err))
        except Exception:
            app.logger.error('[api_tecnicos_create_orden] Falló verificación de esquema de historial', exc_info=True)

        created_ids = []
        for idx, item in enumerate(data['codigos']):
            app.logger.info('[api_tecnicos_create_orden] procesando item %s: %s', idx, item)

            # Normalización y truncado preventivo
            codigo_raw = item.get('codigo') or ''
            nombre_raw = item.get('nombre') or ''
            descripcion_raw = item.get('descripcion') or ''

            codigo = str(codigo_raw)[:50]
            nombre = str(nombre_raw or codigo_raw)[:45]
            descripcion = str(descripcion_raw or nombre_raw or codigo_raw)[:255]

            cantidad = int(item.get('cantidad') or 1)
            valor_unitario_raw = item.get('valor_unitario') or item.get('valor') or 0
            try:
                valor_unitario = int(float(valor_unitario_raw))
            except Exception:
                app.logger.warning('[api_tecnicos_create_orden] valor_unitario inválido: %s', valor_unitario_raw)
                valor_unitario = 0

            params_principal = (
                ot, cuenta, servicio, codigo, tecnologia, categoria,
                nombre, observacion, now, user_id,
                cantidad, valor_unitario, descripcion
            )
            app.logger.info('[api_tecnicos_create_orden] INSERT principal: ot=%s, codigo=%s, nombre=%s, cantidad=%s, valor=%s',
                            ot, codigo, nombre, cantidad, valor_unitario)
            cursor.execute(insert_sql_principal, params_principal)
            created_ids.append(cursor.lastrowid)

            params_historial = (
                user_id, ot, cuenta, servicio, codigo, tecnologia, categoria,
                nombre, observacion, now, cantidad, valor_unitario, descripcion
            )
            app.logger.info('[api_tecnicos_create_orden] INSERT historial: ot=%s, codigo=%s, nombre=%s, cantidad=%s, valor=%s',
                            ot, codigo, nombre, cantidad, valor_unitario)
            try:
                cursor.execute(insert_sql_historial, params_historial)
            except Exception as hist_err:
                err_msg = str(hist_err)
                if "doesn't have a default value" in err_msg and 'id_gestion_ot_tecnicos_historial' in err_msg:
                    app.logger.warning('[api_tecnicos_create_orden] Fallback: insertando historial con ID explícito por esquema sin default')
                    # Calcular siguiente ID manualmente
                    try:
                        cursor.execute("SELECT COALESCE(MAX(id_gestion_ot_tecnicos_historial), 0) + 1 FROM gestion_ot_tecnicos_historial")
                        next_id_row = cursor.fetchone()
                        next_id = next_id_row[0] if next_id_row else 1
                    except Exception:
                        app.logger.error('[api_tecnicos_create_orden] Error obteniendo next_id para historial', exc_info=True)
                        next_id = None
                    if next_id is None:
                        raise hist_err
                    params_historial_with_id = (
                        next_id, user_id, ot, cuenta, servicio, codigo, tecnologia, categoria,
                        nombre, observacion, now, cantidad, valor_unitario, descripcion
                    )
                    cursor.execute(insert_sql_historial_with_id, params_historial_with_id)
                else:
                    raise

        connection.commit()
        app.logger.info('[api_tecnicos_create_orden] Filas insertadas en gestion_ot_tecnicos=%s y historial=%s, total_valor=%s', 
                        len(created_ids), len(created_ids), total_valor)

        return jsonify({'success': True, 'ids': created_ids, 'valor_total': total_valor})
    except Exception as e:
        app.logger.error('[api_tecnicos_create_orden] excepción: %s\n%s', str(e), traceback.format_exc())
        if 'connection' in locals() and connection:
            try:
                connection.rollback()
            except Exception:
                app.logger.error('[api_tecnicos_create_orden] rollback falló', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except Exception:
            app.logger.error('[api_tecnicos_create_orden] cierre de recursos falló', exc_info=True)
            pass

# Obtener lista de tecnologías disponibles
@app.route('/tecnicos/tecnologias', methods=['GET'])
@app.route('/api/tecnicos/tecnologias', methods=['GET'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_list_tecnologias():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        cursor.execute("""
            SELECT DISTINCT tecnologia 
            FROM base_codigos_facturacion 
            WHERE tecnologia IS NOT NULL AND tecnologia <> ''
            ORDER BY tecnologia
        """)
        rows = cursor.fetchall()
        tecnologias = [r[0] for r in rows]
        return jsonify({'success': True, 'tecnologias': tecnologias})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        try:
            if cursor:
                cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except:
            pass

# Obtener categorías por tecnología
@app.route('/tecnicos/categorias/<string:tecnologia>', methods=['GET'])
@app.route('/api/tecnicos/categorias/<string:tecnologia>', methods=['GET'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_list_categorias(tecnologia):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()

        cursor.execute(
            """
            SELECT DISTINCT categoria 
            FROM base_codigos_facturacion 
            WHERE tecnologia = %s AND categoria IS NOT NULL AND categoria <> ''
            ORDER BY categoria
            """,
            (tecnologia,)
        )
        rows = cursor.fetchall()
        categorias = [r[0] for r in rows]
        return jsonify({'success': True, 'categorias': categorias})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        try:
            if cursor:
                cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except:
            pass

# Obtener códigos filtrados por tecnología y categoría
@app.route('/tecnicos/codigos/tecnologia/<string:tecnologia>', methods=['GET'])
@app.route('/tecnicos/codigos/tecnologia/<string:tecnologia>/categoria/<path:categoria>', methods=['GET'])
@app.route('/api/tecnicos/codigos', methods=['GET'])
@login_required_api(role=['tecnicos','analista','analistas'])
def api_tecnicos_list_codigos(tecnologia=None, categoria=None):
    try:
        # Permitir también /api/tecnicos/codigos?tecnologia=...&categoria=...
        if request.path.startswith('/api/tecnicos/codigos'):
            tecnologia = request.args.get('tecnologia', tecnologia)
            categoria = request.args.get('categoria', categoria)

        if not tecnologia:
            return jsonify({'success': False, 'error': 'Parámetro tecnologia requerido'}), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)

        sql = (
            """
            SELECT 
                id_base_codigos_facturacion,
                tecnologia,
                categoria,
                codigo,
                nombre,
                descripcion,
                valor
            FROM base_codigos_facturacion
            WHERE tecnologia = %s
            """
        )
        params = [tecnologia]
        if categoria:
            sql += " AND categoria = %s"
            params.append(categoria)
        sql += " ORDER BY categoria, nombre"

        cursor.execute(sql, params)
        rows = cursor.fetchall()
        codigos = []
        for r in rows:
            codigos.append({
                'id': r.get('id_base_codigos_facturacion'),
                'tecnologia': r.get('tecnologia'),
                'categoria': r.get('categoria'),
                'codigo': r.get('codigo'),
                'nombre': r.get('nombre'),
                'descripcion': r.get('descripcion'),
                'valor': r.get('valor')
            })
        return jsonify({'success': True, 'codigos': codigos})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        try:
            if cursor:
                cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except:
            pass

@app.route('/api/tecnicos/asignacion_ferretero/<int:id_ferretero>')
@login_required(role='tecnicos')
def obtener_detalle_asignacion_ferretero(id_ferretero):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener el detalle completo de la asignación
        cursor.execute("""
            SELECT 
                f.id_ferretero,
                f.fecha_asignacion,
                f.silicona,
                f.amarres_negros,
                f.amarres_blancos,
                f.cinta_aislante,
                f.grapas_negras,
                f.grapas_blancas,
                f.id_codigo_consumidor,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula
            FROM ferretero f
            LEFT JOIN capired.recurso_operativo ro ON f.id_codigo_consumidor = ro.id_codigo_consumidor
            WHERE f.id_ferretero = %s AND f.id_codigo_consumidor = %s
        """, (id_ferretero, session['id_codigo_consumidor']))
        
        asignacion = cursor.fetchone()
        
        if not asignacion:
            return jsonify({'error': 'Asignación no encontrada'}), 404
        
        # Formatear la fecha
        if asignacion['fecha_asignacion']:
            asignacion['fecha_formateada'] = asignacion['fecha_asignacion'].strftime('%d/%m/%Y %H:%M')
        else:
            asignacion['fecha_formateada'] = 'N/A'
        
        return jsonify(asignacion)
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error al obtener detalle: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/tecnico/obtener_estado_materiales')
@login_required(role='tecnicos')
def obtener_estado_materiales():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información del técnico logueado
        cursor.execute("""
            SELECT cargo, carpeta 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        tecnico_info = cursor.fetchone()
        if not tecnico_info:
            return jsonify({'error': 'Técnico no encontrado'}), 404
        
        # Definir límites por área para todos los materiales
        limites_por_area = {
            'INSTALACION': {
                'cinta_aislante': {'cantidad': 5, 'periodo': 15},
                'silicona': {'cantidad': 16, 'periodo': 7},
                'amarres_negros': {'cantidad': 50, 'periodo': 15},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15},
                'grapas_blancas': {'cantidad': 200, 'periodo': 15},
                'grapas_negras': {'cantidad': 200, 'periodo': 15}
            },
            'POSTVENTA': {
                'cinta_aislante': {'cantidad': 3, 'periodo': 15},
                'silicona': {'cantidad': 12, 'periodo': 7},
                'amarres_negros': {'cantidad': 30, 'periodo': 15},
                'amarres_blancos': {'cantidad': 30, 'periodo': 15},
                'grapas_blancas': {'cantidad': 100, 'periodo': 15},
                'grapas_negras': {'cantidad': 100, 'periodo': 15}
            },
            'MANTENIMIENTO': {
                'cinta_aislante': {'cantidad': 4, 'periodo': 15},
                'silicona': {'cantidad': 14, 'periodo': 7},
                'amarres_negros': {'cantidad': 40, 'periodo': 15},
                'amarres_blancos': {'cantidad': 40, 'periodo': 15},
                'grapas_blancas': {'cantidad': 150, 'periodo': 15},
                'grapas_negras': {'cantidad': 150, 'periodo': 15}
            },
            'SUPERVISION': {
                'cinta_aislante': {'cantidad': 2, 'periodo': 15},
                'silicona': {'cantidad': 8, 'periodo': 7},
                'amarres_negros': {'cantidad': 20, 'periodo': 15},
                'amarres_blancos': {'cantidad': 20, 'periodo': 15},
                'grapas_blancas': {'cantidad': 50, 'periodo': 15},
                'grapas_negras': {'cantidad': 50, 'periodo': 15}
            },
            'FTTH INSTALACIONES': {
                'cinta_aislante': {'cantidad': 5, 'periodo': 15},
                'silicona': {'cantidad': 16, 'periodo': 7},
                'amarres_negros': {'cantidad': 50, 'periodo': 15},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15},
                'grapas_blancas': {'cantidad': 200, 'periodo': 15},
                'grapas_negras': {'cantidad': 200, 'periodo': 15}
            },
            'CONDUCTOR': {
                'cinta_aislante': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'}
            },
            'SUPERVISORES': {
                'cinta_aislante': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'}
            },
            'BROWNFIELD': {
                'cinta_aislante': {'cantidad': 5, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 200, 'periodo': 15, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 200, 'periodo': 15, 'unidad': 'días'}
            },
        }
        
        # Determinar el área de trabajo basado en el cargo y carpeta
        cargo = tecnico_info.get('cargo', '').upper()
        carpeta = tecnico_info.get('carpeta', '').upper()
        
        # Mapeo mejorado considerando cargo y carpeta
        if 'FTTH INSTALACIONES' in cargo:
            area_trabajo = 'FTTH INSTALACIONES'
        elif 'INSTALACION' in cargo or ('FTTH' in cargo and 'INSTALACION' in carpeta):
            area_trabajo = 'INSTALACION'
        elif 'POSTVENTA' in cargo or 'POSTVENTA' in carpeta:
            area_trabajo = 'POSTVENTA'
        elif 'MANTENIMIENTO' in cargo or 'ARREGLOS' in carpeta or 'MANTENIMIENTO' in carpeta:
            area_trabajo = 'MANTENIMIENTO'
        elif 'SUPERVISION' in cargo or 'SUPERVISOR' in cargo:
            area_trabajo = 'SUPERVISION'
        elif 'TECNICO' in cargo and 'ARREGLOS' in carpeta:
            # Caso específico: técnicos con carpeta de arreglos van a mantenimiento
            area_trabajo = 'MANTENIMIENTO'
        else:
            area_trabajo = 'INSTALACION'  # Default
        
        limite_config = limites_por_area[area_trabajo]
        
        # Calcular estado para cada material
        from datetime import datetime, timedelta
        materiales_estado = {}
        
        for material, config in limite_config.items():
            limite_total = config['cantidad']
            periodo_dias = config['periodo']
            
            # Calcular fecha límite para el período
            fecha_limite = datetime.now() - timedelta(days=periodo_dias)
            
            # Obtener material asignado en el período
            cursor.execute(f"""
                SELECT COALESCE(SUM(CAST({material} AS UNSIGNED)), 0) as total_asignadas
                FROM ferretero 
                WHERE id_codigo_consumidor = %s 
                AND fecha_asignacion >= %s
            """, (session['id_codigo_consumidor'], fecha_limite))
            
            resultado = cursor.fetchone()
            asignadas = resultado['total_asignadas'] if resultado else 0
            
            # Calcular disponible
            disponible = max(0, limite_total - asignadas)
            
            materiales_estado[material] = {
                'asignadas': asignadas,
                'disponible': disponible,
                'limite': limite_total,
                'periodo_dias': periodo_dias
            }
        
        # Retornar los datos en el formato que espera el frontend
        response_data = materiales_estado.copy()
        response_data['area_trabajo'] = area_trabajo
        
        return jsonify(response_data)
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error al obtener estado de materiales: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Nuevos endpoints para el sistema preoperacional mejorado
@app.route('/api/tecnicos/datos-preoperacional', methods=['GET'])
@login_required(role='tecnicos')
def obtener_datos_preoperacional():
    """
    Endpoint para obtener todos los datos del vehículo y licencia del técnico logueado
    """
    try:
        print(f"Iniciando datos_preoperacional para sesión: {session.get('id_codigo_consumidor')}")
        
        connection = get_db_connection()
        if connection is None:
            print("Error: No se pudo conectar a la base de datos")
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True, buffered=True)
        
        # Obtener cédula del técnico logueado
        cursor.execute("""
            SELECT recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        usuario_actual = cursor.fetchone()
        if not usuario_actual:
            print(f"Usuario no encontrado para id_codigo_consumidor: {session['id_codigo_consumidor']}")
            return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404
        
        cedula_tecnico = usuario_actual['recurso_operativo_cedula']
        print(f"Cedula del técnico: {cedula_tecnico}")
        
        # Consulta principal para obtener todos los datos usando id_codigo_consumidor
        cursor.execute("""
            SELECT 
                ro.ciudad,
                mv.placa,
                mv.modelo,
                mv.marca,
                mv.tipo_vehiculo,
                mlc.tipo_licencia,
                mlc.fecha_vencimiento as fecha_venc_licencia,
                ms.fecha_vencimiento as fecha_venc_soat,
                mtm.fecha_vencimiento as fecha_venc_tecnico_mecanica,
                0 as ultimo_kilometraje,
                NULL as fecha_ultimo_kilometraje
            FROM capired.recurso_operativo ro
            LEFT JOIN capired.mpa_vehiculos mv ON ro.id_codigo_consumidor = mv.tecnico_asignado
            LEFT JOIN capired.mpa_licencia_conducir mlc ON ro.id_codigo_consumidor = mlc.tecnico
            LEFT JOIN capired.mpa_soat ms ON mv.placa = ms.placa 
                AND ms.estado = 'Activo'
            LEFT JOIN capired.mpa_tecnico_mecanica mtm ON mv.placa = mtm.placa 
                AND mtm.estado = 'Activo'
            WHERE ro.id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        datos = cursor.fetchone()
        print(f"Datos obtenidos: {datos}")
        
        if not datos:
            print("No se encontraron datos para el técnico")
            return jsonify({'success': False, 'message': 'No se encontraron datos para el técnico'}), 404
        
        # Calcular alertas de documentos próximos a vencer
        alertas = []
        fecha_actual = datetime.now().date()
        
        # Verificar licencia de conducción
        if datos['fecha_venc_licencia']:
            fecha_venc_licencia = datos['fecha_venc_licencia'].date() if hasattr(datos['fecha_venc_licencia'], 'date') else datos['fecha_venc_licencia']
            dias_licencia = (fecha_venc_licencia - fecha_actual).days
            if dias_licencia < 0:
                alertas.append({
                    'tipo': 'error',
                    'mensaje': f'Licencia de conducción vencida desde el {datos["fecha_venc_licencia"].strftime("%d/%m/%Y")}'
                })
            elif dias_licencia <= 30:
                alertas.append({
                    'tipo': 'warning',
                    'mensaje': f'Licencia de conducción próxima a vencer en {dias_licencia} días'
                })
        
        # Verificar SOAT
        if datos['fecha_venc_soat']:
            fecha_venc_soat = datos['fecha_venc_soat'].date() if hasattr(datos['fecha_venc_soat'], 'date') else datos['fecha_venc_soat']
            dias_soat = (fecha_venc_soat - fecha_actual).days
            if dias_soat < 0:
                alertas.append({
                    'tipo': 'error',
                    'mensaje': f'SOAT vencido desde el {datos["fecha_venc_soat"].strftime("%d/%m/%Y")}'
                })
            elif dias_soat <= 30:
                alertas.append({
                    'tipo': 'warning',
                    'mensaje': f'SOAT próximo a vencer en {dias_soat} días'
                })
        
        # Verificar Técnico Mecánica
        if datos['fecha_venc_tecnico_mecanica']:
            fecha_venc_tm = datos['fecha_venc_tecnico_mecanica'].date() if hasattr(datos['fecha_venc_tecnico_mecanica'], 'date') else datos['fecha_venc_tecnico_mecanica']
            dias_tm = (fecha_venc_tm - fecha_actual).days
            if dias_tm < 0:
                alertas.append({
                    'tipo': 'error',
                    'mensaje': f'Técnico mecánica vencida desde el {datos["fecha_venc_tecnico_mecanica"].strftime("%d/%m/%Y")}'
                })
            elif dias_tm <= 30:
                alertas.append({
                    'tipo': 'warning',
                    'mensaje': f'Técnico mecánica próxima a vencer en {dias_tm} días'
                })
        
        # Formatear fechas para el frontend
        response_data = {
            'ciudad': datos['ciudad'] or '',
            'placa': datos['placa'] or '',
            'modelo': datos['modelo'] or '',
            'marca': datos['marca'] or '',
            'tipo_vehiculo': datos['tipo_vehiculo'] or '',
            'tipo_licencia': datos['tipo_licencia'] or '',
            'fecha_venc_licencia': datos['fecha_venc_licencia'].strftime('%Y-%m-%d') if datos['fecha_venc_licencia'] else '',
            'fecha_venc_soat': datos['fecha_venc_soat'].strftime('%Y-%m-%d') if datos['fecha_venc_soat'] else '',
            'fecha_venc_tecnico_mecanica': datos['fecha_venc_tecnico_mecanica'].strftime('%Y-%m-%d') if datos['fecha_venc_tecnico_mecanica'] else '',
            'ultimo_kilometraje': datos['ultimo_kilometraje'],
            'fecha_ultimo_kilometraje': datos['fecha_ultimo_kilometraje'].strftime('%Y-%m-%d') if datos['fecha_ultimo_kilometraje'] else ''
        }
        
        return jsonify({
            'success': True,
            'data': response_data,
            'alertas': alertas
        })
        
    except mysql.connector.Error as e:
        print(f"Error de base de datos: {str(e)}")
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"Error interno: {str(e)}")
        return jsonify({'success': False, 'message': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/tecnicos/validar-kilometraje', methods=['POST'])
@login_required(role='tecnicos')
def validar_kilometraje():
    """
    Endpoint para validar kilometraje en tiempo real
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'No se recibieron datos'}), 400
        
        placa = data.get('placa')
        kilometraje_propuesto = data.get('kilometraje_propuesto')
        
        if not placa or kilometraje_propuesto is None:
            return jsonify({'success': False, 'message': 'Placa y kilometraje son requeridos'}), 400
        
        try:
            kilometraje_propuesto = int(kilometraje_propuesto)
        except ValueError:
            return jsonify({'success': False, 'message': 'El kilometraje debe ser un número entero'}), 400
        
        if kilometraje_propuesto < 0:
            return jsonify({'success': False, 'message': 'El kilometraje no puede ser negativo'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener último kilometraje registrado para la placa (comparación normalizada)
        placa_norm_tecnico = (placa or '').strip().upper().replace('-', '').replace(' ', '')
        cursor.execute("""
            SELECT kilometraje_actual, fecha
            FROM capired.preoperacional 
            WHERE UPPER(REPLACE(REPLACE(TRIM(placa_vehiculo), '-', ''), ' ', '')) = %s 
            ORDER BY fecha DESC 
            LIMIT 1
        """, (placa_norm_tecnico,))
        
        ultimo_registro = cursor.fetchone()
        
        if not ultimo_registro:
            # Primer registro para este vehículo
            return jsonify({
                'success': True,
                'valido': True,
                'ultimo_kilometraje': 0,
                'fecha_ultimo_registro': '',
                'mensaje': 'Primer registro de kilometraje para este vehículo'
            })
        
        ultimo_kilometraje = ultimo_registro['kilometraje_actual']
        fecha_ultimo_registro = ultimo_registro['fecha']
        
        if kilometraje_propuesto < ultimo_kilometraje:
            return jsonify({
                'success': True,
                'valido': False,
                'ultimo_kilometraje': ultimo_kilometraje,
                'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
                'mensaje': f'El kilometraje no puede ser menor al último registrado: {ultimo_kilometraje} km en fecha {fecha_ultimo_registro.strftime("%d/%m/%Y") if fecha_ultimo_registro else "N/A"}'
            })

        # Nueva validación: límite máximo permitido
        if kilometraje_propuesto > 1000000:
            return jsonify({
                'success': True,
                'valido': False,
                'ultimo_kilometraje': ultimo_kilometraje,
                'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
                'mensaje': f'El kilometraje no puede superar los 1,000,000 km. Último kilometraje registrado: {ultimo_kilometraje} km'
            })
        
        return jsonify({
            'success': True,
            'valido': True,
            'ultimo_kilometraje': ultimo_kilometraje,
            'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
            'mensaje': 'Kilometraje válido'
        })
        
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# ==================== MÓDULO MANTENIMIENTOS - TÉCNICOS ====================

@app.route('/tecnicos/mantenimientos')
@login_required(role='tecnicos')
def tecnicos_mantenimientos():
    """Módulo de mantenimientos para técnicos"""
    try:
        return render_template('modulos/tecnicos/mantenimientos.html')
    except Exception as e:
        flash(f'Error al cargar el módulo de mantenimientos: {str(e)}', 'danger')
        return render_template('modulos/tecnicos/mantenimientos.html')

# ==================== MÓDULO PREOPERACIONAL - OPERATIVOS ====================

@app.route('/api/operativo/datos-preoperacional', methods=['GET'])
@login_required(role=['operativo'])
def obtener_datos_preoperacional_operativo():
    """
    Endpoint para obtener datos del vehículo y licencia del operativo logueado
    """
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True, buffered=True)

        # Obtener cédula del operativo logueado
        cursor.execute(
            """
            SELECT recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
            """,
            (session['id_codigo_consumidor'],)
        )

        usuario_actual = cursor.fetchone()
        if not usuario_actual:
            return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404

        # Consulta principal de datos asociado al usuario
        cursor.execute(
            """
            SELECT 
                ro.ciudad,
                ro.super AS supervisor,
                COALESCE(
                    (
                        SELECT mv1.placa 
                        FROM capired.mpa_vehiculos mv1 
                        WHERE mv1.tecnico_asignado = ro.id_codigo_consumidor AND mv1.estado = 'Activo' 
                        ORDER BY mv1.id_mpa_vehiculos DESC 
                        LIMIT 1
                    ),
                    (
                        SELECT p1.placa_vehiculo 
                        FROM capired.preoperacional p1 
                        WHERE p1.id_codigo_consumidor = ro.id_codigo_consumidor 
                        ORDER BY p1.fecha DESC 
                        LIMIT 1
                    )
                ) AS placa,
                (
                    SELECT v1.modelo 
                    FROM capired.mpa_vehiculos v1 
                    WHERE v1.placa = COALESCE(
                        (SELECT mv2.placa FROM capired.mpa_vehiculos mv2 WHERE mv2.tecnico_asignado = ro.id_codigo_consumidor AND mv2.estado = 'Activo' ORDER BY mv2.id_mpa_vehiculos DESC LIMIT 1),
                        (SELECT p2.placa_vehiculo FROM capired.preoperacional p2 WHERE p2.id_codigo_consumidor = ro.id_codigo_consumidor ORDER BY p2.fecha DESC LIMIT 1)
                    )
                    LIMIT 1
                ) AS modelo,
                (
                    SELECT v2.marca 
                    FROM capired.mpa_vehiculos v2 
                    WHERE v2.placa = COALESCE(
                        (SELECT mv3.placa FROM capired.mpa_vehiculos mv3 WHERE mv3.tecnico_asignado = ro.id_codigo_consumidor AND mv3.estado = 'Activo' ORDER BY mv3.id_mpa_vehiculos DESC LIMIT 1),
                        (SELECT p3.placa_vehiculo FROM capired.preoperacional p3 WHERE p3.id_codigo_consumidor = ro.id_codigo_consumidor ORDER BY p3.fecha DESC LIMIT 1)
                    )
                    LIMIT 1
                ) AS marca,
                (
                    SELECT v3.tipo_vehiculo 
                    FROM capired.mpa_vehiculos v3 
                    WHERE v3.placa = COALESCE(
                        (SELECT mv4.placa FROM capired.mpa_vehiculos mv4 WHERE mv4.tecnico_asignado = ro.id_codigo_consumidor AND mv4.estado = 'Activo' ORDER BY mv4.id_mpa_vehiculos DESC LIMIT 1),
                        (SELECT p4.placa_vehiculo FROM capired.preoperacional p4 WHERE p4.id_codigo_consumidor = ro.id_codigo_consumidor ORDER BY p4.fecha DESC LIMIT 1)
                    )
                    LIMIT 1
                ) AS tipo_vehiculo,
                (
                    SELECT sub.tipo_licencia
                    FROM capired.mpa_licencia_conducir sub
                    WHERE sub.tecnico = ro.id_codigo_consumidor
                      AND sub.fecha_vencimiento IS NOT NULL
                      AND sub.fecha_vencimiento > '1900-01-01'
                      AND (sub.estado IS NULL OR sub.estado = 'Activo')
                    ORDER BY sub.fecha_vencimiento DESC
                    LIMIT 1
                ) AS tipo_licencia,
                (
                    SELECT sub.fecha_vencimiento
                    FROM capired.mpa_licencia_conducir sub
                    WHERE sub.tecnico = ro.id_codigo_consumidor
                      AND sub.fecha_vencimiento IS NOT NULL
                      AND sub.fecha_vencimiento > '1900-01-01'
                      AND (sub.estado IS NULL OR sub.estado = 'Activo')
                    ORDER BY sub.fecha_vencimiento DESC
                    LIMIT 1
                ) AS fecha_venc_licencia,
                (
                    SELECT s.fecha_vencimiento
                    FROM capired.mpa_soat s
                    WHERE s.placa = COALESCE(
                        (SELECT mv5.placa FROM capired.mpa_vehiculos mv5 WHERE mv5.tecnico_asignado = ro.id_codigo_consumidor AND mv5.estado = 'Activo' ORDER BY mv5.id_mpa_vehiculos DESC LIMIT 1),
                        (SELECT p5.placa_vehiculo FROM capired.preoperacional p5 WHERE p5.id_codigo_consumidor = ro.id_codigo_consumidor ORDER BY p5.fecha DESC LIMIT 1)
                    )
                      AND s.estado = 'Activo'
                      AND s.fecha_vencimiento IS NOT NULL
                      AND s.fecha_vencimiento > '1900-01-01'
                    ORDER BY s.fecha_vencimiento DESC
                    LIMIT 1
                ) AS fecha_venc_soat,
                (
                    SELECT t.fecha_vencimiento
                    FROM capired.mpa_tecnico_mecanica t
                    WHERE t.placa = COALESCE(
                        (SELECT mv6.placa FROM capired.mpa_vehiculos mv6 WHERE mv6.tecnico_asignado = ro.id_codigo_consumidor AND mv6.estado = 'Activo' ORDER BY mv6.id_mpa_vehiculos DESC LIMIT 1),
                        (SELECT p6.placa_vehiculo FROM capired.preoperacional p6 WHERE p6.id_codigo_consumidor = ro.id_codigo_consumidor ORDER BY p6.fecha DESC LIMIT 1)
                    )
                      AND t.estado = 'Activo'
                      AND t.fecha_vencimiento IS NOT NULL
                      AND t.fecha_vencimiento > '1900-01-01'
                    ORDER BY t.fecha_vencimiento DESC
                    LIMIT 1
                ) AS fecha_venc_tecnico_mecanica,
                (
                    SELECT p7.kilometraje_actual 
                    FROM capired.preoperacional p7 
                    WHERE p7.id_codigo_consumidor = ro.id_codigo_consumidor 
                    ORDER BY p7.fecha DESC 
                    LIMIT 1
                ) AS ultimo_kilometraje,
                (
                    SELECT p8.fecha 
                    FROM capired.preoperacional p8 
                    WHERE p8.id_codigo_consumidor = ro.id_codigo_consumidor 
                    ORDER BY p8.fecha DESC 
                    LIMIT 1
                ) AS fecha_ultimo_kilometraje
            FROM capired.recurso_operativo ro
            WHERE ro.id_codigo_consumidor = %s
            """,
            (session['id_codigo_consumidor'],)
        )

        datos = cursor.fetchone()
        if not datos:
            return jsonify({'success': False, 'message': 'No se encontraron datos para el usuario'}), 404

        # Calcular alertas de vencimientos
        alertas = []
        fecha_actual = datetime.now().date()

        if datos['fecha_venc_licencia']:
            fecha_venc_licencia = datos['fecha_venc_licencia'].date() if hasattr(datos['fecha_venc_licencia'], 'date') else datos['fecha_venc_licencia']
            dias_licencia = (fecha_venc_licencia - fecha_actual).days
            if dias_licencia < 0:
                alertas.append({'tipo': 'error', 'mensaje': f"Licencia de conducción vencida desde el {datos['fecha_venc_licencia'].strftime('%d/%m/%Y')}"})
            elif dias_licencia <= 30:
                alertas.append({'tipo': 'warning', 'mensaje': f'Licencia de conducción próxima a vencer en {dias_licencia} días'})

        if datos['fecha_venc_soat']:
            fecha_venc_soat = datos['fecha_venc_soat'].date() if hasattr(datos['fecha_venc_soat'], 'date') else datos['fecha_venc_soat']
            dias_soat = (fecha_venc_soat - fecha_actual).days
            if dias_soat < 0:
                alertas.append({'tipo': 'error', 'mensaje': f"SOAT vencido desde el {datos['fecha_venc_soat'].strftime('%d/%m/%Y')}"})
            elif dias_soat <= 30:
                alertas.append({'tipo': 'warning', 'mensaje': f'SOAT próximo a vencer en {dias_soat} días'})

        if datos['fecha_venc_tecnico_mecanica']:
            fecha_venc_tm = datos['fecha_venc_tecnico_mecanica'].date() if hasattr(datos['fecha_venc_tecnico_mecanica'], 'date') else datos['fecha_venc_tecnico_mecanica']
            dias_tm = (fecha_venc_tm - fecha_actual).days
            if dias_tm < 0:
                alertas.append({'tipo': 'error', 'mensaje': f"Técnico mecánica vencida desde el {datos['fecha_venc_tecnico_mecanica'].strftime('%d/%m/%Y')}"})
            elif dias_tm <= 30:
                alertas.append({'tipo': 'warning', 'mensaje': f'Técnico mecánica próxima a vencer en {dias_tm} días'})

        response_data = {
            'ciudad': datos['ciudad'] or '',
            'supervisor': datos.get('supervisor') or '',
            'placa': datos['placa'] or '',
            'modelo': datos['modelo'] or '',
            'marca': datos['marca'] or '',
            'tipo_vehiculo': datos['tipo_vehiculo'] or '',
            'tipo_licencia': datos['tipo_licencia'] or '',
            'fecha_venc_licencia': datos['fecha_venc_licencia'].strftime('%Y-%m-%d') if datos['fecha_venc_licencia'] else '',
            'fecha_venc_soat': datos['fecha_venc_soat'].strftime('%Y-%m-%d') if datos['fecha_venc_soat'] else '',
            'fecha_venc_tecnico_mecanica': datos['fecha_venc_tecnico_mecanica'].strftime('%Y-%m-%d') if datos['fecha_venc_tecnico_mecanica'] else '',
            'ultimo_kilometraje': datos['ultimo_kilometraje'],
            'fecha_ultimo_kilometraje': datos['fecha_ultimo_kilometraje'].strftime('%Y-%m-%d') if datos['fecha_ultimo_kilometraje'] else ''
        }

        return jsonify({'success': True, 'data': response_data, 'alertas': alertas})
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error interno: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/operativo/validar-kilometraje', methods=['POST'])
@login_required(role=['operativo'])
def validar_kilometraje_operativo():
    """
    Endpoint para validar kilometraje en tiempo real (operativos)
    """
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': 'No se recibieron datos'}), 400

        placa = data.get('placa')
        kilometraje_propuesto = data.get('kilometraje_propuesto')
        if not placa or kilometraje_propuesto is None:
            return jsonify({'success': False, 'message': 'Placa y kilometraje son requeridos'}), 400

        try:
            kilometraje_propuesto = int(kilometraje_propuesto)
        except ValueError:
            return jsonify({'success': False, 'message': 'El kilometraje debe ser un número entero'}), 400

        if kilometraje_propuesto < 0:
            return jsonify({'success': False, 'message': 'El kilometraje no puede ser negativo'}), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        # Normalizar placa para evitar falsos "primer registro" por variaciones (espacios/guiones/minúsculas)
        placa_normalizada = (placa or '').strip().upper().replace('-', '').replace(' ', '')
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT kilometraje_actual, fecha
            FROM capired.preoperacional 
            WHERE UPPER(REPLACE(REPLACE(TRIM(placa_vehiculo), '-', ''), ' ', '')) = %s
            ORDER BY fecha DESC 
            LIMIT 1
            """,
            (placa_normalizada,)
        )
        ultimo_registro = cursor.fetchone()

        if not ultimo_registro:
            return jsonify({'success': True, 'valido': True, 'ultimo_kilometraje': 0, 'fecha_ultimo_registro': '', 'mensaje': 'Primer registro de kilometraje para este vehículo'})

        ultimo_kilometraje = ultimo_registro['kilometraje_actual']
        fecha_ultimo_registro = ultimo_registro['fecha']

        if kilometraje_propuesto < ultimo_kilometraje:
            return jsonify({
                'success': True,
                'valido': False,
                'ultimo_kilometraje': ultimo_kilometraje,
                'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
                'mensaje': f'El kilometraje no puede ser menor al último registrado: {ultimo_kilometraje} km en fecha {fecha_ultimo_registro.strftime("%d/%m/%Y") if fecha_ultimo_registro else "N/A"}'
            })

        if kilometraje_propuesto > 1000000:
            return jsonify({
                'success': True,
                'valido': False,
                'ultimo_kilometraje': ultimo_kilometraje,
                'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
                'mensaje': 'El kilometraje no puede superar los 1,000,000 km.'
            })

        return jsonify({
            'success': True,
            'valido': True,
            'ultimo_kilometraje': ultimo_kilometraje,
            'fecha_ultimo_registro': fecha_ultimo_registro.strftime('%d/%m/%Y') if fecha_ultimo_registro else '',
            'mensaje': 'Kilometraje válido'
        })
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error interno: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/tecnicos/mantenimientos', methods=['GET'])
@login_required(role='tecnicos')
def api_tecnicos_mantenimientos():
    """API para obtener mantenimientos asignados al técnico logueado"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información del técnico logueado
        cursor.execute("""
            SELECT nombre, recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        tecnico_info = cursor.fetchone()
        if not tecnico_info:
            return jsonify({'error': 'Técnico no encontrado'}), 404
        
        tecnico_nombre = tecnico_info['nombre']
        
        # Obtener mantenimientos asignados al técnico
        # Filtrar por el nombre del técnico en el campo 'tecnico'
        query = """
        SELECT 
            m.id_mpa_mantenimientos,
            m.placa,
            m.fecha_mantenimiento,
            m.kilometraje,
            m.observacion,
            m.soporte_foto_geo as foto_taller,
            m.soporte_foto_factura as foto_factura,
            m.tipo_vehiculo,
            m.tecnico as tecnico_nombre,
            m.tipo_mantenimiento
        FROM mpa_mantenimientos m
        WHERE m.tecnico = %s
        ORDER BY m.fecha_mantenimiento DESC
        """
        
        cursor.execute(query, (tecnico_nombre,))
        mantenimientos = cursor.fetchall()
        
        # Formatear fechas para el frontend
        for mantenimiento in mantenimientos:
            if mantenimiento['fecha_mantenimiento']:
                mantenimiento['fecha_mantenimiento'] = mantenimiento['fecha_mantenimiento'].strftime('%Y-%m-%d %H:%M:%S')
        
        return jsonify({
            'success': True,
            'data': mantenimientos,
            'tecnico': tecnico_nombre
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/operativo')
@login_required(role='operativo')
def operativo_dashboard():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            resp = make_response(render_template('modulos/operativo/dashboard.html', tiene_asistencia=False))
            resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
            resp.headers['Pragma'] = 'no-cache'
            resp.headers['Expires'] = '0'
            return resp
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener la cédula del usuario logueado
        cursor.execute("""
            SELECT recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        usuario_actual = cursor.fetchone()
        
        # Verificar si es el usuario especial (52912112) que debe estar exento de la restricción
        if usuario_actual and usuario_actual['recurso_operativo_cedula'] == '52912112':
            # Usuario especial: siempre tiene acceso a todos los botones
            tiene_asistencia = True
        else:
            # Para todos los demás usuarios: verificar asistencia registrada para hoy
            fecha_hoy = datetime.now().strftime('%Y-%m-%d')
            cursor.execute("""
                SELECT COUNT(*) as registros_hoy
                FROM asistencia 
                WHERE id_codigo_consumidor = %s AND DATE(fecha_asistencia) = %s
            """, (session['id_codigo_consumidor'], fecha_hoy))
            
            registro_existente = cursor.fetchone()
            tiene_asistencia = registro_existente['registros_hoy'] > 0 if registro_existente else False
        
        resp = make_response(render_template('modulos/operativo/dashboard.html', tiene_asistencia=tiene_asistencia))
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
        return resp
        
    except mysql.connector.Error as e:
        flash(f'Error al verificar asistencia: {str(e)}', 'danger')
        resp = make_response(render_template('modulos/operativo/dashboard.html', tiene_asistencia=False))
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
        return resp
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/lider')
@login_required_lider()
def lider_dashboard():
    """
    Dashboard principal del módulo de Líder
    """
    try:
        return render_template('modulos/lider/dashboard.html')
    except Exception as e:
        flash(f'Error al cargar el panel de líder: {str(e)}', 'danger')
        return redirect(url_for('index'))

@app.route('/lider/turnos-analistas')
@login_required_lider()
def lider_turnos_analistas():
    """
    Página principal del submódulo Turnos Analistas
    """
    try:
        return render_template('modulos/lider/turnos-analistas.html')
    except Exception as e:
        flash(f'Error al cargar turnos de analistas: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/indicadores')
@login_required_lider()
def lider_indicadores():
    """
    Página principal del submódulo Ver Indicadores
    """
    try:
        return render_template('modulos/lider/indicadores.html')
    except Exception as e:
        flash(f'Error al cargar indicadores: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/indicadores/operaciones')
@login_required_lider()
def lider_indicadores_operaciones():
    """
    Página del submódulo Indicadores de Operaciones
    """
    try:
        return render_template('modulos/lider/indicadores-operaciones.html')
    except Exception as e:
        flash(f'Error al cargar indicadores de operaciones: {str(e)}', 'danger')
        return redirect(url_for('lider_indicadores'))

@app.route('/lider/indicadores/operaciones/inicio')
@login_required_lider()
def lider_inicio_operacion():
    """
    Página del submódulo Inicio de Operación
    """
    try:
        return render_template('modulos/lider/inicio-operacion.html')
    except Exception as e:
        flash(f'Error al cargar inicio de operación: {str(e)}', 'danger')
        return redirect(url_for('lider_indicadores_operaciones'))

@app.route('/lider/indicadores/operaciones/presupuesto')
@login_required_lider()
def lider_presupuesto():
    """
    Página del submódulo Presupuesto - Muestra tabla de supervisores con valores mensuales
    """
    try:
        return render_template('modulos/lider/presupuesto.html')
    except Exception as e:
        flash(f'Error al cargar presupuesto: {str(e)}', 'danger')
        return redirect(url_for('lider_indicadores_operaciones'))

@app.route('/lider/actividades-diarias')
@login_required_lider()
def lider_actividades_diarias():
    try:
        return render_template('modulos/lider/actividades-diarias.html', mostrar_cargue=True, list_endpoint='/api/analistas/actividades-diarias')
    except Exception as e:
        flash(f'Error al cargar actividades diarias: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/calidad')
@login_required_lider()
def lider_calidad():
    try:
        return render_template('modulos/lider/calidad.html', api_endpoint='/api/lider/cargar-calidad')
    except Exception as e:
        flash(f'Error al cargar módulo de calidad: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/facturacion')
@login_required_lider()
def lider_facturacion():
    try:
        return render_template('modulos/lider/facturacion.html', api_endpoint='/api/lider/cargar-facturacion')
    except Exception as e:
        flash(f'Error al cargar módulo de facturación: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/efectividad')
@login_required_lider()
def lider_efectividad():
    try:
        return render_template('modulos/lider/efectividad.html', api_endpoint='/api/lider/cargar-efectividad')
    except Exception as e:
        flash(f'Error al cargar módulo de efectividad: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/lider/estadisticas')
@login_required_lider()
def lider_estadisticas():
    try:
        return render_template('modulos/lider/estadisticas.html')
    except Exception as e:
        flash(f'Error al cargar módulo de estadísticas: {str(e)}', 'danger')
        return redirect(url_for('lider_dashboard'))

@app.route('/api/lider/cargar-actividades', methods=['POST'])
@login_required_lider_api()
def api_lider_cargar_actividades():
    file = request.files.get('file')
    if not file or not file.filename:
        return jsonify({'success': False, 'message': 'Archivo no proporcionado'}), 400
    name = file.filename.lower()
    data = file.read()
    try:
        if name.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(data))
        elif name.endswith('.xlsx') or name.endswith('.xls'):
            df = pd.read_excel(io.BytesIO(data))
        else:
            return jsonify({'success': False, 'message': 'Formato no soportado'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 400
    import re
    orig_cols = list(df.columns)
    def sanitize_name(name):
        n = re.sub(r"\s+", "_", str(name).strip())
        n = re.sub(r"[^A-Za-z0-9_]", "_", n)
        if not n or re.match(r"^[0-9]", n):
            n = f"col_{n}"
        n = re.sub(r"_+", "_", n)
        return n[:64]
    used = {}
    safe_cols = []
    for c in orig_cols:
        s = sanitize_name(c)
        base = s
        idx = 2
        while s in used:
            suffix = f"_{idx}"
            s = (base[:64 - len(suffix)]) + suffix
            idx += 1
        used[s] = True
        safe_cols.append(s)
    def sql_type(dt):
        k = getattr(dt, 'kind', 'O')
        if k in ('i', 'u'):
            return 'BIGINT'
        if k == 'f':
            return 'DECIMAL(20,6)'
        if k == 'b':
            return 'TINYINT(1)'
        if k == 'M':
            return 'DATETIME'
        return 'TEXT'
    column_defs = ', '.join([f"`{safe_cols[i]}` {sql_type(df[orig_cols[i]].dtype)} NULL" for i in range(len(orig_cols))])
    create_sql = f"CREATE TABLE IF NOT EXISTS `operaciones_actividades_diarias` ({column_defs}) ENGINE=InnoDB ROW_FORMAT=DYNAMIC DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci"
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=%s AND table_name=%s",
            (db_config.get('database'), 'operaciones_actividades_diarias')
        )
        exists = cursor.fetchone()[0] > 0
        if not exists:
            return jsonify({'success': False, 'message': 'La tabla operaciones_actividades_diarias no existe'}), 400

        cursor.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE
            FROM information_schema.columns
            WHERE table_schema=%s AND table_name=%s
            """,
            (db_config.get('database'), 'operaciones_actividades_diarias')
        )
        db_cols_rows = cursor.fetchall() or []
        db_cols = [r[0] for r in db_cols_rows]
        db_types = {r[0]: str(r[1]).lower() for r in db_cols_rows}

        def norm_name(s:str):
            import re
            s = re.sub(r"\s+", "_", str(s).strip())
            s = re.sub(r"[^A-Za-z0-9_]", "_", s)
            s = re.sub(r"_+", "_", s)
            return s.lower()

        norm_db_map = {norm_name(c): c for c in db_cols}

        mapped_cols = []
        mapped_idx = []
        for i, c in enumerate(orig_cols):
            ce = c
            n_excel = norm_name(ce)
            db_col = norm_db_map.get(n_excel)
            if not db_col:
                for dc in db_cols:
                    if dc.lower() == str(ce).lower():
                        db_col = dc
                        break
            if db_col:
                mapped_cols.append(db_col)
                mapped_idx.append(i)

        actividad_db_col = None
        actividad_idx = None
        for dc in db_cols:
            ndc = norm_name(dc)
            if ndc in ("actividad_id","id_actividad","idactividad","actividadid") or ("actividad" in ndc and "id" in ndc):
                actividad_db_col = dc
                break
        if actividad_db_col is None:
            for i, c in enumerate(orig_cols):
                k = re.sub(r"[^a-z0-9]", "", str(c).lower())
                if k in ("actividadid", "idactividad", "actividad_id", "id_actividad") or ("actividad" in k and "id" in k):
                    db_col = norm_db_map.get(norm_name(c))
                    if db_col:
                        actividad_db_col = db_col
                        actividad_idx = i
                        break
        else:
            for i, c in enumerate(orig_cols):
                if norm_name(c) == norm_name(actividad_db_col):
                    actividad_idx = i
                    break

        def convert_by_type(val, tname:str):
            try:
                import numpy as np
                if pd.isna(val):
                    return None
                if isinstance(val, pd.Timestamp):
                    if tname in ("date",):
                        return val.to_pydatetime().date()
                    return val.to_pydatetime()
                if tname in ("int","bigint","smallint","mediumint"):
                    if isinstance(val, (int,)):
                        return int(val)
                    if isinstance(val, (float,)):
                        return int(val)
                    v = str(val).strip()
                    return int(v) if v and v.isdigit() else None
                if tname in ("decimal","numeric","float","double"):
                    from decimal import Decimal as D
                    if isinstance(val, (int,float)):
                        return D(str(val))
                    v = str(val).strip()
                    return D(v) if v else None
                if tname in ("tinyint"):
                    v = str(val).strip().lower()
                    return 1 if v in ("1","true","si","sí","yes") else 0 if v in ("0","false","no") else None
                if tname in ("datetime","timestamp"):
                    if isinstance(val, str):
                        try:
                            return pd.to_datetime(val).to_pydatetime()
                        except Exception:
                            return val
                    return val
                if tname in ("date",):
                    if isinstance(val, str):
                        try:
                            return pd.to_datetime(val).date()
                        except Exception:
                            return val
                    return val
                return val if val is None or isinstance(val, (str,bytes)) else str(val)
            except Exception:
                return val

        if not mapped_cols:
            cursor.close(); connection.close()
            return jsonify({'success': False, 'message': 'No se encontraron columnas del archivo que coincidan con la tabla'}), 400

        insert_sql = f"INSERT INTO `operaciones_actividades_diarias` ({', '.join([f'`{c}`' for c in mapped_cols])}) VALUES ({','.join(['%s']*len(mapped_cols))})"
        update_cols = [c for c in mapped_cols if c != actividad_db_col]
        insert_upsert_sql = None
        if actividad_db_col and update_cols:
            insert_upsert_sql = (
                f"INSERT INTO `operaciones_actividades_diarias` ({', '.join([f'`{c}`' for c in mapped_cols])}) "
                f"VALUES ({','.join(['%s']*len(mapped_cols))}) "
                f"ON DUPLICATE KEY UPDATE {', '.join([f'`{c}`=%s' for c in update_cols])}"
            )

        inserted = 0
        updated = 0
        for r in range(len(df)):
            values = []
            for j, db_col in enumerate(mapped_cols):
                raw = df.iloc[r, mapped_idx[j]]
                values.append(convert_by_type(raw, db_types.get(db_col, '')))
            if insert_upsert_sql:
                upd_vals = [values[mapped_cols.index(c)] for c in update_cols]
                cursor.execute(insert_upsert_sql, tuple(values + upd_vals))
                rc = cursor.rowcount or 0
                if rc == 2:
                    updated += 1
                else:
                    inserted += 1
            else:
                cursor.execute(insert_sql, tuple(values))
                inserted += 1

        connection.commit()
        cursor.close(); connection.close()
        return jsonify({'success': True, 'rows_inserted': inserted, 'rows_updated': updated, 'total_rows': len(df), 'message': f"{inserted} insertadas, {updated} actualizadas"})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    except Exception as e:
        try:
            app.logger.error(f"Error en /logistica/seriales_inversa/pending: {e}")
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 200

@app.route('/api/analistas/cargar-actividades', methods=['POST'])
@login_required_api(role=['analistas','analista','lider'])
def api_analistas_cargar_actividades():
    return api_lider_cargar_actividades()

@app.route('/api/lider/cargar-calidad', methods=['POST'])
@login_required_lider_api()
def api_lider_cargar_calidad():
    file = request.files.get('file')
    if not file or not file.filename:
        return jsonify({'success': False, 'message': 'Archivo no proporcionado'}), 400
    name = file.filename.lower()
    data = file.read()
    try:
        if name.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(data))
        elif name.endswith('.xlsx') or name.endswith('.xls'):
            df = pd.read_excel(io.BytesIO(data))
        else:
            return jsonify({'success': False, 'message': 'Formato no soportado'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 400

    def nrm(s):
        try:
            return re.sub(r"[^a-z0-9]", "", str(s).lower())
        except Exception:
            return str(s).lower()

    cols_map = {nrm(c): c for c in df.columns}
    def pick(names):
        for n in names:
            k = nrm(n)
            if k in cols_map:
                return cols_map[k]
        for k0, v0 in cols_map.items():
            for n in names:
                if nrm(n) in k0:
                    return v0
        return None

    col_cuenta = pick(['cuenta','numero_de_cuenta','num_cuenta','nro_cuenta'])
    col_ot = pick(['ot','orden_de_trabajo','orden','orden_trabajo'])
    col_garantia = pick(['garantia','garantía'])
    col_causa = pick(['causa','motivo'])
    col_lider = pick(['lider','líder','supervisor'])
    col_agenda = pick(['agenda','franja'])
    col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
    col_cedula = pick(['cedula','documento','recurso_operativo_cedula','id_codigo_consumidor'])

    required = [col_cuenta, col_ot, col_garantia, col_causa, col_lider, col_agenda, col_fecha, col_cedula]
    if any(c is None for c in required):
        missing = []
        names = ['Cuenta','OT','Garantia','Causa','Lider','Agenda','Fecha','Cedula']
        for i, c in enumerate(required):
            if c is None:
                missing.append(names[i])
        return jsonify({'success': False, 'message': f'Columnas faltantes: {", ".join(missing)}'}), 400

    def to_date(val):
        try:
            if isinstance(val, pd.Timestamp):
                return val.to_pydatetime().date()
            if isinstance(val, datetime):
                return val.date()
            return pd.to_datetime(val).date()
        except Exception:
            return None

    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS operaciones_calidad (
                id INT AUTO_INCREMENT PRIMARY KEY,
                cuenta VARCHAR(64) NULL,
                ot VARCHAR(64) NULL,
                garantia VARCHAR(64) NULL,
                causa TEXT NULL,
                lider VARCHAR(128) NULL,
                agenda VARCHAR(128) NULL,
                fecha DATE NULL,
                periodo_year INT NULL,
                periodo_month INT NULL,
                cedula VARCHAR(32) NULL,
                carpeta VARCHAR(128) NULL,
                super VARCHAR(128) NULL,
                analista VARCHAR(128) NULL,
                tecnico_nombre VARCHAR(128) NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_ot (ot),
                INDEX idx_cuenta (cuenta),
                INDEX idx_cedula (cedula),
                INDEX idx_fecha (fecha)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )

        schema = None
        try:
            cur_db = connection.cursor()
            cur_db.execute("SELECT DATABASE()")
            schema = (cur_db.fetchone() or [None])[0]
            cur_db.close()
        except Exception:
            pass
        if not schema:
            schema = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
        try:
            cursor.execute(
                """
                SELECT COLUMN_NAME FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_calidad'
                """,
                (schema,)
            )
            existing_cols = {r[0] if isinstance(r, tuple) else list(r.values())[0] for r in cursor.fetchall() or []}
            if 'carpeta' not in existing_cols:
                cursor.execute("ALTER TABLE operaciones_calidad ADD COLUMN carpeta VARCHAR(128) NULL")
            if 'periodo_year' not in existing_cols:
                cursor.execute("ALTER TABLE operaciones_calidad ADD COLUMN periodo_year INT NULL")
            if 'periodo_month' not in existing_cols:
                cursor.execute("ALTER TABLE operaciones_calidad ADD COLUMN periodo_month INT NULL")
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) FROM information_schema.statistics
                    WHERE table_schema=%s AND table_name='operaciones_calidad' AND index_name='uniq_ot_periodo' AND NON_UNIQUE=0
                    """,
                    (schema,)
                )
                idx_exists = (cursor.fetchone() or [0])[0] > 0
                if not idx_exists:
                    try:
                        cursor.execute("ALTER TABLE operaciones_calidad ADD UNIQUE KEY uniq_ot_periodo (ot, periodo_year, periodo_month)")
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass

        inserted = 0
        updated = 0
        periodo_sel = (request.form.get('periodo') or '').strip()
        now_bog = datetime.now(TIMEZONE)
        p_year = now_bog.year
        p_month = now_bog.month
        if periodo_sel:
            try:
                parts = periodo_sel.split('-')
                if len(parts) == 2:
                    yy = int(parts[0]); mm = int(parts[1])
                    if 1 <= mm <= 12:
                        p_year = yy; p_month = mm
            except Exception:
                pass
        cur_ro = connection.cursor(dictionary=True)
        for r in range(len(df)):
            cuenta_v = df.iloc[r][col_cuenta]
            ot_v = df.iloc[r][col_ot]
            garantia_v = df.iloc[r][col_garantia]
            causa_v = df.iloc[r][col_causa]
            lider_v = df.iloc[r][col_lider]
            agenda_v = df.iloc[r][col_agenda]
            fecha_v = to_date(df.iloc[r][col_fecha])
            cedula_raw = df.iloc[r][col_cedula]
            cedula_v = None
            try:
                s = str(cedula_raw).strip()
                cedula_v = s if s else None
            except Exception:
                cedula_v = None

            super_v = None
            analista_v = None
            tecnico_v = None
            carpeta_v = None
            if cedula_v:
                try:
                    cur_ro.execute("SELECT nombre, super, analista, carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s LIMIT 1", (cedula_v,))
                    ro = cur_ro.fetchone()
                    if ro:
                        tecnico_v = ro.get('nombre')
                        super_v = ro.get('super')
                        analista_v = ro.get('analista')
                        carpeta_v = ro.get('carpeta')
                except Exception:
                    pass

            ot_str = None if pd.isna(ot_v) else str(ot_v).strip()
            if ot_str:
                cursor.execute(
                    "SELECT 1 FROM operaciones_calidad WHERE ot=%s AND periodo_year=%s AND periodo_month=%s LIMIT 1",
                    (ot_str, p_year, p_month)
                )
                exists_row = cursor.fetchone()
                if exists_row:
                    cursor.execute(
                        """
                        UPDATE operaciones_calidad SET
                            cuenta=%s, garantia=%s, causa=%s, lider=%s, agenda=%s, fecha=%s, cedula=%s, carpeta=%s, super=%s, analista=%s, tecnico_nombre=%s
                        WHERE ot=%s AND periodo_year=%s AND periodo_month=%s
                        """,
                        (
                            None if pd.isna(cuenta_v) else str(cuenta_v),
                            None if pd.isna(garantia_v) else str(garantia_v),
                            None if pd.isna(causa_v) else str(causa_v),
                            None if pd.isna(lider_v) else str(lider_v),
                            None if pd.isna(agenda_v) else str(agenda_v),
                            fecha_v,
                            cedula_v,
                            None if pd.isna(carpeta_v) else str(carpeta_v),
                            None if pd.isna(super_v) else str(super_v),
                            None if pd.isna(analista_v) else str(analista_v),
                            None if pd.isna(tecnico_v) else str(tecnico_v),
                            ot_str,
                            p_year,
                            p_month
                        )
                    )
                    updated += 1
                else:
                    cursor.execute(
                        """
                        INSERT INTO operaciones_calidad (
                            cuenta, ot, garantia, causa, lider, agenda, fecha, periodo_year, periodo_month, cedula, carpeta, super, analista, tecnico_nombre
                        ) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
                        """,
                        (
                            None if pd.isna(cuenta_v) else str(cuenta_v),
                            ot_str,
                            None if pd.isna(garantia_v) else str(garantia_v),
                            None if pd.isna(causa_v) else str(causa_v),
                            None if pd.isna(lider_v) else str(lider_v),
                            None if pd.isna(agenda_v) else str(agenda_v),
                            fecha_v,
                            p_year,
                            p_month,
                            cedula_v,
                            None if pd.isna(carpeta_v) else str(carpeta_v),
                            None if pd.isna(super_v) else str(super_v),
                            None if pd.isna(analista_v) else str(analista_v),
                            None if pd.isna(tecnico_v) else str(tecnico_v)
                        )
                    )
                    inserted += 1
            else:
                cursor.execute(
                    """
                    INSERT INTO operaciones_calidad (
                        cuenta, ot, garantia, causa, lider, agenda, fecha, periodo_year, periodo_month, cedula, carpeta, super, analista, tecnico_nombre
                    ) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
                    """,
                    (
                        None if pd.isna(cuenta_v) else str(cuenta_v),
                        None if pd.isna(ot_v) else str(ot_v),
                        None if pd.isna(garantia_v) else str(garantia_v),
                        None if pd.isna(causa_v) else str(causa_v),
                        None if pd.isna(lider_v) else str(lider_v),
                        None if pd.isna(agenda_v) else str(agenda_v),
                        fecha_v,
                        p_year,
                        p_month,
                        cedula_v,
                        None if pd.isna(carpeta_v) else str(carpeta_v),
                        None if pd.isna(super_v) else str(super_v),
                        None if pd.isna(analista_v) else str(analista_v),
                        None if pd.isna(tecnico_v) else str(tecnico_v)
                    )
                )
                inserted += 1

        connection.commit()
        try:
            cur_ro.close()
        except Exception:
            pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'rows_inserted': inserted, 'rows_updated': updated, 'periodo_year': p_year, 'periodo_month': p_month, 'message': f"{inserted} insertadas, {updated} actualizadas"})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    except Exception as e:
        try:
            app.logger.error(f"Error en cargue de calidad: {e}")
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 200

@app.route('/api/lider/cargar-facturacion', methods=['POST'])
@login_required_lider_api()
def api_lider_cargar_facturacion():
    file = request.files.get('file')
    if not file or not file.filename:
        return jsonify({'success': False, 'message': 'Archivo no proporcionado'}), 400
    name = file.filename.lower()
    data = file.read()
    try:
        if name.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(data))
        elif name.endswith('.xlsx') or name.endswith('.xls'):
            df = pd.read_excel(io.BytesIO(data))
        else:
            return jsonify({'success': False, 'message': 'Formato no soportado'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 400

    def nrm(s):
        try:
            return re.sub(r"[^a-z0-9]", "", str(s).lower())
        except Exception:
            return str(s).lower()

    cmap = {nrm(c): c for c in df.columns}
    def pick(names):
        for n in names:
            k = nrm(n)
            if k in cmap:
                return cmap[k]
        for k0, v0 in cmap.items():
            for n in names:
                if nrm(n) in k0:
                    return v0
        return None

    col_tecnico = pick(['tecnico_nombre','tecnico'])
    col_deberiair = pick(['deberiair'])
    col_puntos = pick(['puntos'])
    col_nivel = pick(['niveltecnico','nivel_tecnico'])
    col_mediaot = pick(['mediaot','media_ot'])
    col_oks = pick(['oks'])
    col_abiertas = pick(['abiertas'])
    col_fact_pdte = pick(['fact-pdte','fact_pdte'])
    col_fact_sinsubir = pick(['fact-sinsubir','fact_sinsubir'])
    col_vehiculo = pick(['vehiculo'])
    col_cedula = pick(['cedula','documento','recurso_operativo_cedula'])
    col_dias = pick(['dias'])

    required = [col_cedula]
    if any(c is None for c in required):
        return jsonify({'success': False, 'message': 'Falta columna cedula en el archivo'}), 400

    periodo_sel = (request.form.get('periodo') or '').strip()
    now_bog = datetime.now(TIMEZONE)
    p_year = now_bog.year
    p_month = now_bog.month
    if periodo_sel:
        try:
            parts = periodo_sel.split('-')
            if len(parts) == 2:
                yy = int(parts[0]); mm = int(parts[1])
                if 1 <= mm <= 12:
                    p_year = yy; p_month = mm
        except Exception:
            pass

    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS operaciones_facturacion (
                id INT AUTO_INCREMENT PRIMARY KEY,
                periodo_year INT NOT NULL,
                periodo_month INT NOT NULL,
                cedula VARCHAR(32) NOT NULL,
                tecnico_nombre VARCHAR(128) NULL,
                deberiair DECIMAL(20,6) NULL,
                puntos DECIMAL(20,6) NULL,
                niveltecnico VARCHAR(64) NULL,
                mediaot DECIMAL(20,6) NULL,
                oks INT NULL,
                abiertas INT NULL,
                fact_pdte INT NULL,
                fact_sinsubir INT NULL,
                vehiculo VARCHAR(64) NULL,
                super VARCHAR(128) NULL,
                analista VARCHAR(128) NULL,
                dias INT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uniq_cedula_periodo (cedula, periodo_year, periodo_month),
                INDEX idx_cedula (cedula),
                INDEX idx_periodo (periodo_year, periodo_month)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )

        schema = None
        try:
            cur_db = connection.cursor()
            cur_db.execute("SELECT DATABASE()")
            schema = (cur_db.fetchone() or [None])[0]
            cur_db.close()
        except Exception:
            pass
        if not schema:
            schema = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_facturacion'
            """,
            (schema,)
        )
        existing_cols = {r[0] if isinstance(r, tuple) else list(r.values())[0] for r in cursor.fetchall() or []}
        expected = {
            'periodo_year': 'INT NOT NULL',
            'periodo_month': 'INT NOT NULL',
            'cedula': 'VARCHAR(32) NOT NULL',
            'tecnico_nombre': 'VARCHAR(128) NULL',
            'deberiair': 'DECIMAL(20,6) NULL',
            'puntos': 'DECIMAL(20,6) NULL',
            'niveltecnico': 'VARCHAR(64) NULL',
            'mediaot': 'DECIMAL(20,6) NULL',
            'oks': 'INT NULL',
            'abiertas': 'INT NULL',
            'fact_pdte': 'INT NULL',
            'fact_sinsubir': 'INT NULL',
            'vehiculo': 'VARCHAR(64) NULL',
            'super': 'VARCHAR(128) NULL',
            'analista': 'VARCHAR(128) NULL',
            'dias': 'INT NULL'
        }
        for col, ddl in expected.items():
            if col not in existing_cols:
                cursor.execute(f"ALTER TABLE operaciones_facturacion ADD COLUMN {col} {ddl}")
        try:
            cursor.execute(
                """
                SELECT COUNT(*) FROM information_schema.statistics
                WHERE table_schema=%s AND table_name='operaciones_facturacion' AND index_name='uniq_cedula_periodo' AND NON_UNIQUE=0
                """,
                (schema,)
            )
            idx_exists = (cursor.fetchone() or [0])[0] > 0
            if not idx_exists:
                try:
                    cursor.execute("ALTER TABLE operaciones_facturacion ADD UNIQUE KEY uniq_cedula_periodo (cedula, periodo_year, periodo_month)")
                except Exception:
                    pass
        except Exception:
            pass

        inserted = 0
        updated = 0
        cur_ro = connection.cursor(dictionary=True)
        from decimal import Decimal as D
        import numpy as np
        def to_dec(v):
            try:
                if v is None or (isinstance(v, float) and not np.isfinite(v)) or pd.isna(v):
                    return None
            except Exception:
                if v is None:
                    return None
            try:
                return D(str(v))
            except Exception:
                try:
                    return D(int(v))
                except Exception:
                    return None
        def to_int(v):
            try:
                if v is None or pd.isna(v):
                    return None
            except Exception:
                if v is None:
                    return None
            try:
                return int(float(str(v)))
            except Exception:
                try:
                    return int(v)
                except Exception:
                    return None
        def to_str(v):
            try:
                return None if pd.isna(v) else str(v)
            except Exception:
                return None if v is None else str(v)
        for r in range(len(df)):
            cedula_raw = df.iloc[r][col_cedula]
            cedula_v = None
            try:
                s = str(cedula_raw).strip()
                cedula_v = s if s else None
            except Exception:
                cedula_v = None
            if not cedula_v:
                continue

            t_nombre_file = None if col_tecnico is None else df.iloc[r][col_tecnico]
            t_nombre = None
            super_v = None
            analista_v = None
            try:
                cur_ro.execute("SELECT nombre, super, analista, carpeta, cargo FROM recurso_operativo WHERE recurso_operativo_cedula = %s LIMIT 1", (cedula_v,))
                ro = cur_ro.fetchone()
                if ro:
                    t_nombre = ro.get('nombre')
                    super_v = ro.get('super')
                    analista_v = ro.get('analista')
                    carpeta_v = ro.get('carpeta')
                    cargo_v = ro.get('cargo')
            except Exception:
                pass
            if not t_nombre:
                t_nombre = to_str(t_nombre_file)
            super_v = to_str(super_v)
            analista_v = to_str(analista_v)
            carpeta_v = to_str(carpeta_v)
            cargo_v = to_str(cargo_v)

            v_deberiair = None
            v_puntos = to_dec(None if col_puntos is None else df.iloc[r][col_puntos])
            v_nivel = to_str(None if col_nivel is None else df.iloc[r][col_nivel])
            v_mediaot = to_dec(None if col_mediaot is None else df.iloc[r][col_mediaot])
            v_oks = to_int(None if col_oks is None else df.iloc[r][col_oks])
            v_abiertas = to_int(None if col_abiertas is None else df.iloc[r][col_abiertas])
            v_fact_pdte = to_int(None if col_fact_pdte is None else df.iloc[r][col_fact_pdte])
            v_fact_sinsubir = to_int(None if col_fact_sinsubir is None else df.iloc[r][col_fact_sinsubir])
            v_vehiculo = to_str(None if col_vehiculo is None else df.iloc[r][col_vehiculo])
            v_dias = to_int(None if col_dias is None else df.iloc[r][col_dias])

            pd_val = None
            try:
                if carpeta_v and cargo_v:
                    cur_ro.execute("SELECT presupuesto_diario FROM presupuesto_carpeta WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s LIMIT 1", (carpeta_v, cargo_v))
                    pr = cur_ro.fetchone()
                    if pr and 'presupuesto_diario' in pr:
                        pd_val = pr.get('presupuesto_diario')
                    else:
                        if str(carpeta_v).strip().upper() == 'DX':
                            cur_ro.execute("SELECT presupuesto_diario FROM presupuesto_carpeta WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s LIMIT 1", ('ARREGLOS HFC', cargo_v))
                            pr2 = cur_ro.fetchone()
                            if pr2 and 'presupuesto_diario' in pr2:
                                pd_val = pr2.get('presupuesto_diario')
                            else:
                                cur_ro.execute("SELECT presupuesto_diario FROM presupuesto_carpeta WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s LIMIT 1", ('MANTENIMIENTO FTTH', cargo_v))
                                pr3 = cur_ro.fetchone()
                                if pr3 and 'presupuesto_diario' in pr3:
                                    pd_val = pr3.get('presupuesto_diario')
            except Exception:
                pd_val = None

            if pd_val is not None and v_dias is not None:
                try:
                    v_deberiair = to_dec(pd_val)
                    if v_deberiair is not None:
                        v_deberiair = v_deberiair * D(str(v_dias))
                except Exception:
                    pass

            cursor.execute(
                "SELECT 1 FROM operaciones_facturacion WHERE cedula=%s AND periodo_year=%s AND periodo_month=%s LIMIT 1",
                (cedula_v, p_year, p_month)
            )
            exists_row = cursor.fetchone()
            if exists_row:
                cursor.execute(
                    "UPDATE operaciones_facturacion SET tecnico_nombre=%s, deberiair=%s, puntos=%s, niveltecnico=%s, mediaot=%s, oks=%s, abiertas=%s, fact_pdte=%s, fact_sinsubir=%s, vehiculo=%s, super=%s, analista=%s, dias=%s WHERE cedula=%s AND periodo_year=%s AND periodo_month=%s",
                    (t_nombre, v_deberiair, v_puntos, v_nivel, v_mediaot, v_oks, v_abiertas, v_fact_pdte, v_fact_sinsubir, v_vehiculo, super_v, analista_v, v_dias, cedula_v, p_year, p_month)
                )
                updated += 1
            else:
                cursor.execute(
                    "INSERT INTO operaciones_facturacion (periodo_year, periodo_month, cedula, tecnico_nombre, deberiair, puntos, niveltecnico, mediaot, oks, abiertas, fact_pdte, fact_sinsubir, vehiculo, super, analista, dias) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)",
                    (p_year, p_month, cedula_v, t_nombre, v_deberiair, v_puntos, v_nivel, v_mediaot, v_oks, v_abiertas, v_fact_pdte, v_fact_sinsubir, v_vehiculo, super_v, analista_v, v_dias)
                )
                inserted += 1

        connection.commit()
        try:
            cur_ro.close()
        except Exception:
            pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'rows_inserted': inserted, 'rows_updated': updated, 'message': f"{inserted} insertadas, {updated} actualizadas"})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    except Exception as e:
        try:
            app.logger.error(f"Error en cargue de facturación: {e}")
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 200

@app.route('/api/lider/facturacion/list', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_lider_facturacion_list():
    periodo = request.args.get('periodo', '').strip()
    cedula = request.args.get('cedula', '').strip()
    analista = request.args.get('analista', '').strip()
    superv = request.args.get('super', '').strip()
    try:
        ur_role = session.get('user_role')
        if ur_role in ('analista','analistas'):
            analista = str(session.get('user_name') or '').strip()
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        base_sql = (
            "SELECT cedula, tecnico_nombre, deberiair, puntos, niveltecnico, mediaot, oks, abiertas, fact_pdte, fact_sinsubir, vehiculo, dias "
            "FROM operaciones_facturacion WHERE periodo_year=%s AND periodo_month=%s"
        )
        params = [year, month]
        if cedula:
            base_sql += " AND cedula = %s"
            params.append(cedula)
        if analista:
            base_sql += " AND analista = %s"
            params.append(analista)
        if superv:
            base_sql += " AND super = %s"
            params.append(superv)
        base_sql += " ORDER BY tecnico_nombre ASC"
        cursor.execute(base_sql, tuple(params))
        items = cursor.fetchall() or []
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': items})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/lider/facturacion/resumen', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_lider_facturacion_resumen():
    periodo = request.args.get('periodo', '').strip()
    analista = request.args.get('analista', '').strip()
    superv = request.args.get('super', '').strip()
    try:
        ur_role = session.get('user_role')
        if ur_role in ('analista','analistas'):
            analista = str(session.get('user_name') or '').strip()
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        sql = (
            "SELECT COUNT(*) as cantidad, "
            "SUM(COALESCE(deberiair,0)) as deberiair, "
            "SUM(COALESCE(puntos,0)) as puntos, "
            "AVG(COALESCE(mediaot,0)) as mediaot, "
            "SUM(COALESCE(oks,0)) as oks, "
            "SUM(COALESCE(abiertas,0)) as abiertas, "
            "SUM(COALESCE(fact_pdte,0)) as fact_pdte, "
            "SUM(COALESCE(fact_sinsubir,0)) as fact_sinsubir, "
            "MAX(COALESCE(dias,0)) as dias "
            "FROM operaciones_facturacion WHERE periodo_year=%s AND periodo_month=%s"
        )
        params = [year, month]
        if analista:
            sql += " AND analista = %s"
            params.append(analista)
        if superv:
            sql += " AND super = %s"
            params.append(superv)
        cursor.execute(sql, tuple(params))
        resumen = cursor.fetchone() or {}
        cursor.close(); connection.close()
        return jsonify({'success': True, 'resumen': resumen})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/lider/facturacion/opciones', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_lider_facturacion_opciones():
    periodo = request.args.get('periodo', '').strip()
    try:
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            "SELECT DISTINCT analista FROM operaciones_facturacion WHERE periodo_year=%s AND periodo_month=%s AND analista IS NOT NULL AND TRIM(analista) <> '' ORDER BY analista",
            (year, month)
        )
        analistas = [r[0] for r in cursor.fetchall() or []]
        cursor.execute(
            "SELECT DISTINCT super FROM operaciones_facturacion WHERE periodo_year=%s AND periodo_month=%s AND super IS NOT NULL AND TRIM(super) <> '' ORDER BY super",
            (year, month)
        )
        supervisores = [r[0] for r in cursor.fetchall() or []]
        if not analistas or not supervisores:
            try:
                cur2 = connection.cursor()
                if not analistas:
                    cur2.execute("SELECT DISTINCT analista FROM recurso_operativo WHERE analista IS NOT NULL AND TRIM(analista) <> '' ORDER BY analista")
                    analistas = [x[0] for x in cur2.fetchall() or []]
                if not supervisores:
                    cur2.execute("SELECT DISTINCT super FROM recurso_operativo WHERE super IS NOT NULL AND TRIM(super) <> '' ORDER BY super")
                    supervisores = [x[0] for x in cur2.fetchall() or []]
                cur2.close()
            except Exception:
                pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'analistas': analistas, 'supervisores': supervisores})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/lider/cargar-efectividad', methods=['POST'])
@login_required_lider_api()
def api_lider_cargar_efectividad():
    file = request.files.get('file')
    if not file or not file.filename:
        return jsonify({'success': False, 'message': 'Archivo no proporcionado'}), 400
    name = file.filename.lower()
    data = file.read()
    try:
        if name.endswith('.csv'):
            df = pd.read_csv(io.BytesIO(data))
        elif name.endswith('.xlsx') or name.endswith('.xls'):
            df = pd.read_excel(io.BytesIO(data))
        else:
            return jsonify({'success': False, 'message': 'Formato no soportado'}), 400
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 400

    def nrm(s):
        try:
            return re.sub(r"[^a-z0-9]", "", str(s).lower())
        except Exception:
            return str(s).lower()

    cmap = {nrm(c): c for c in df.columns}
    def pick(names):
        for n in names:
            k = nrm(n)
            if k in cmap:
                return cmap[k]
        for k0, v0 in cmap.items():
            for n in names:
                if nrm(n) in k0:
                    return v0
        return None

    col_razon = pick(['razon'])
    col_kpi = pick(['kpi'])
    col_agenda = pick(['agenda'])
    col_ok = pick(['ok'])
    col_cedula = pick(['cedula','documento','recurso_operativo_cedula'])

    required = [col_cedula]
    if any(c is None for c in required):
        return jsonify({'success': False, 'message': 'Falta columna cedula en el archivo'}), 400

    periodo_sel = (request.form.get('periodo') or '').strip()
    now_bog = datetime.now(TIMEZONE)
    p_year = now_bog.year
    p_month = now_bog.month
    if periodo_sel:
        try:
            parts = periodo_sel.split('-')
            if len(parts) == 2:
                yy = int(parts[0]); mm = int(parts[1])
                if 1 <= mm <= 12:
                    p_year = yy; p_month = mm
        except Exception:
            pass

    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS operaciones_efectividad (
                id INT AUTO_INCREMENT PRIMARY KEY,
                periodo_year INT NOT NULL,
                periodo_month INT NOT NULL,
                cedula VARCHAR(32) NOT NULL,
                tecnico_nombre VARCHAR(128) NULL,
                carpeta VARCHAR(128) NULL,
                super VARCHAR(128) NULL,
                analista VARCHAR(128) NULL,
                razon VARCHAR(255) NULL,
                kpi DECIMAL(20,6) NULL,
                agenda VARCHAR(128) NULL,
                ok INT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uniq_cedula_periodo (cedula, periodo_year, periodo_month),
                INDEX idx_cedula (cedula),
                INDEX idx_periodo (periodo_year, periodo_month)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )

        schema = None
        try:
            cur_db = connection.cursor()
            cur_db.execute("SELECT DATABASE()")
            schema = (cur_db.fetchone() or [None])[0]
            cur_db.close()
        except Exception:
            pass
        if not schema:
            schema = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_efectividad'
            """,
            (schema,)
        )
        existing_cols = {r[0] if isinstance(r, tuple) else list(r.values())[0] for r in cursor.fetchall() or []}
        expected = {
            'periodo_year': 'INT NOT NULL',
            'periodo_month': 'INT NOT NULL',
            'cedula': 'VARCHAR(32) NOT NULL',
            'tecnico_nombre': 'VARCHAR(128) NULL',
            'carpeta': 'VARCHAR(128) NULL',
            'super': 'VARCHAR(128) NULL',
            'analista': 'VARCHAR(128) NULL',
            'razon': 'VARCHAR(255) NULL',
            'kpi': 'DECIMAL(20,6) NULL',
            'agenda': 'VARCHAR(128) NULL',
            'ok': 'INT NULL'
        }
        for col, ddl in expected.items():
            if col not in existing_cols:
                cursor.execute(f"ALTER TABLE operaciones_efectividad ADD COLUMN {col} {ddl}")
        try:
            cursor.execute(
                """
                SELECT COUNT(*) FROM information_schema.statistics
                WHERE table_schema=%s AND table_name='operaciones_efectividad' AND index_name='uniq_cedula_periodo' AND NON_UNIQUE=0
                """,
                (schema,)
            )
            idx_exists = (cursor.fetchone() or [0])[0] > 0
            if not idx_exists:
                try:
                    cursor.execute("ALTER TABLE operaciones_efectividad ADD UNIQUE KEY uniq_cedula_periodo (cedula, periodo_year, periodo_month)")
                except Exception:
                    pass
        except Exception:
            pass

        inserted = 0
        updated = 0
        cur_ro = connection.cursor(dictionary=True)
        from decimal import Decimal as D
        import numpy as np
        def to_dec(v):
            try:
                if v is None or (isinstance(v, float) and not np.isfinite(v)) or pd.isna(v):
                    return None
            except Exception:
                if v is None:
                    return None
            try:
                return D(str(v))
            except Exception:
                try:
                    return D(int(v))
                except Exception:
                    return None
        def to_int(v):
            try:
                if v is None or pd.isna(v):
                    return None
            except Exception:
                if v is None:
                    return None
            try:
                return int(float(str(v)))
            except Exception:
                try:
                    return int(v)
                except Exception:
                    return None
        def to_str(v):
            try:
                return None if pd.isna(v) else str(v)
            except Exception:
                return None if v is None else str(v)

        for r in range(len(df)):
            cedula_raw = df.iloc[r][col_cedula]
            cedula_v = None
            try:
                s = str(cedula_raw).strip()
                # Normalizar cédula: manejar números en formato float y eliminar no dígitos
                if s:
                    try:
                        if re.fullmatch(r"\d+(\.0+)?", s):
                            s = str(int(float(s)))
                        else:
                            digits = re.sub(r"\D", "", s)
                            if digits:
                                s = digits
                    except Exception:
                        pass
                cedula_v = s if s else None
            except Exception:
                cedula_v = None
            if not cedula_v:
                continue

            t_nombre = None
            carpeta_v = None
            super_v = None
            analista_v = None
            try:
                # Búsqueda principal por cédula
                cur_ro.execute("SELECT nombre, carpeta, super, analista FROM recurso_operativo WHERE recurso_operativo_cedula = %s LIMIT 1", (cedula_v,))
                ro = cur_ro.fetchone()
                # Fallback: intentar con CAST si el tipo de columna difiere
                if not ro:
                    try:
                        cur_ro.execute("SELECT nombre, carpeta, super, analista FROM recurso_operativo WHERE CAST(recurso_operativo_cedula AS CHAR) = %s LIMIT 1", (cedula_v,))
                        ro = cur_ro.fetchone()
                    except Exception:
                        pass
                # Fallback: intentar por id_codigo_consumidor (algunas bases traen este ID en 'cedula')
                if not ro:
                    try:
                        cur_ro.execute("SELECT nombre, carpeta, super, analista FROM recurso_operativo WHERE CAST(id_codigo_consumidor AS CHAR) = %s LIMIT 1", (cedula_v,))
                        ro = cur_ro.fetchone()
                    except Exception:
                        pass
                if ro:
                    t_nombre = ro.get('nombre')
                    carpeta_v = ro.get('carpeta')
                    super_v = ro.get('super')
                    analista_v = ro.get('analista')
            except Exception:
                pass
            t_nombre = to_str(t_nombre)
            carpeta_v = to_str(carpeta_v)
            super_v = to_str(super_v)
            analista_v = to_str(analista_v)

            v_razon = to_str(None if col_razon is None else df.iloc[r][col_razon])
            v_kpi = to_dec(None if col_kpi is None else df.iloc[r][col_kpi])
            v_agenda = to_str(None if col_agenda is None else df.iloc[r][col_agenda])
            v_ok = to_int(None if col_ok is None else df.iloc[r][col_ok])

            cursor.execute(
                "SELECT 1 FROM operaciones_efectividad WHERE cedula=%s AND periodo_year=%s AND periodo_month=%s LIMIT 1",
                (cedula_v, p_year, p_month)
            )
            exists_row = cursor.fetchone()
            if exists_row:
                cursor.execute(
                    "UPDATE operaciones_efectividad SET tecnico_nombre=%s, carpeta=%s, super=%s, analista=%s, razon=%s, kpi=%s, agenda=%s, ok=%s WHERE cedula=%s AND periodo_year=%s AND periodo_month=%s",
                    (t_nombre, carpeta_v, super_v, analista_v, v_razon, v_kpi, v_agenda, v_ok, cedula_v, p_year, p_month)
                )
                updated += 1
            else:
                cursor.execute(
                    "INSERT INTO operaciones_efectividad (periodo_year, periodo_month, cedula, tecnico_nombre, carpeta, super, analista, razon, kpi, agenda, ok) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)",
                    (p_year, p_month, cedula_v, t_nombre, carpeta_v, super_v, analista_v, v_razon, v_kpi, v_agenda, v_ok)
                )
                inserted += 1

        connection.commit()
        try:
            cur_ro.close()
        except Exception:
            pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'rows_inserted': inserted, 'rows_updated': updated, 'message': f"{inserted} insertadas, {updated} actualizadas"})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    except Exception as e:
        try:
            app.logger.error(f"Error en cargue de efectividad: {e}")
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 200

@app.route('/api/lider/efectividad/list', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_lider_efectividad_list():
    periodo = request.args.get('periodo', '').strip()
    analista = request.args.get('analista', '').strip()
    superv = request.args.get('super', '').strip()
    carpeta = request.args.get('carpeta', '').strip()
    try:
        ur_role = session.get('user_role')
        if ur_role in ('analista','analistas'):
            analista = str(session.get('user_name') or '').strip()
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        base_sql = (
            "SELECT cedula, tecnico_nombre, carpeta, razon, kpi, agenda, ok, super, analista "
            "FROM operaciones_efectividad WHERE periodo_year=%s AND periodo_month=%s"
        )
        params = [year, month]
        if analista:
            base_sql += " AND analista = %s"
            params.append(analista)
        if superv:
            base_sql += " AND super = %s"
            params.append(superv)
        if carpeta:
            base_sql += " AND carpeta = %s"
            params.append(carpeta)
        base_sql += " ORDER BY tecnico_nombre ASC"
        cursor.execute(base_sql, tuple(params))
        items = cursor.fetchall() or []
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': items})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/lider/efectividad/opciones', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_lider_efectividad_opciones():
    periodo = request.args.get('periodo', '').strip()
    try:
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            "SELECT DISTINCT analista FROM operaciones_efectividad WHERE periodo_year=%s AND periodo_month=%s AND analista IS NOT NULL AND TRIM(analista) <> '' ORDER BY analista",
            (year, month)
        )
        analistas = [r[0] for r in cursor.fetchall() or []]
        cursor.execute(
            "SELECT DISTINCT super FROM operaciones_efectividad WHERE periodo_year=%s AND periodo_month=%s AND super IS NOT NULL AND TRIM(super) <> '' ORDER BY super",
            (year, month)
        )
        supervisores = [r[0] for r in cursor.fetchall() or []]
        cursor.execute(
            "SELECT DISTINCT carpeta FROM operaciones_efectividad WHERE periodo_year=%s AND periodo_month=%s AND carpeta IS NOT NULL AND TRIM(carpeta) <> '' ORDER BY carpeta",
            (year, month)
        )
        carpetas = [r[0] for r in cursor.fetchall() or []]
        if not analistas or not supervisores or not carpetas:
            try:
                cur2 = connection.cursor()
                if not analistas:
                    cur2.execute("SELECT DISTINCT analista FROM recurso_operativo WHERE analista IS NOT NULL AND TRIM(analista) <> '' ORDER BY analista")
                    analistas = [x[0] for x in cur2.fetchall() or []]
                if not supervisores:
                    cur2.execute("SELECT DISTINCT super FROM recurso_operativo WHERE super IS NOT NULL AND TRIM(super) <> '' ORDER BY super")
                    supervisores = [x[0] for x in cur2.fetchall() or []]
                if not carpetas:
                    cur2.execute("SELECT DISTINCT carpeta FROM recurso_operativo WHERE carpeta IS NOT NULL AND TRIM(carpeta) <> '' ORDER BY carpeta")
                    carpetas = [x[0] for x in cur2.fetchall() or []]
                cur2.close()
            except Exception:
                pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'analistas': analistas, 'supervisores': supervisores, 'carpetas': carpetas})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/lider/calidad/list', methods=['GET'])
@login_required_lider_api()
def api_lider_calidad_list():
    periodo = request.args.get('periodo', '').strip()
    try:
        now_bog = datetime.now(TIMEZONE)
        year = now_bog.year
        month = now_bog.month
        if periodo:
            try:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0])
                    month = int(parts[1])
            except Exception:
                pass
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor(dictionary=True)
        cur.execute(
            """
            SELECT cedula, tecnico_nombre, agenda, fecha, carpeta, ot, periodo_year, periodo_month
            FROM operaciones_calidad
            """
        )
        rows = cur.fetchall() or []
        cur2 = connection.cursor()

        meses = {
            'enero': 1, 'febrero': 2, 'marzo': 3, 'abril': 4, 'mayo': 5, 'junio': 6,
            'julio': 7, 'agosto': 8, 'septiembre': 9, 'setiembre': 9, 'octubre': 10, 'noviembre': 11, 'diciembre': 12
        }
        def parse_agenda(a, f):
            y = None
            m = None
            s = (a or '').strip().lower()
            if not s:
                return None, None
            try:
                m1 = re.search(r"(\d{4})\D+(\d{1,2})", s)
                if m1:
                    y = int(m1.group(1)); m = int(m1.group(2))
                else:
                    m2 = re.search(r"(\d{1,2})\D+(\d{4})", s)
                    if m2:
                        m = int(m2.group(1)); y = int(m2.group(2))
                if not y or not m:
                    for k,v in meses.items():
                        if k in s:
                            m = v
                            break
                    if m:
                        y_search = re.search(r"(\d{4})", s)
                        if y_search:
                            y = int(y_search.group(1))
                        elif f:
                            try:
                                if isinstance(f, datetime):
                                    y = f.year
                                else:
                                    y = pd.to_datetime(f).year
                            except Exception:
                                y = None
            except Exception:
                y = None; m = None
            if not y or not m:
                return None, None
            if m < 1 or m > 12:
                return None, None
            return y, m

        grupos = {}
        for r in rows:
            py = r.get('periodo_year'); pm = r.get('periodo_month')
            yx = None; mx = None
            try:
                if py is not None and pm is not None:
                    yx = int(py); mx = int(pm)
            except Exception:
                yx = None; mx = None
            if yx is None or mx is None:
                yx, mx = parse_agenda(r.get('agenda'), r.get('fecha'))
            if yx != year or mx != month:
                continue
            ced = r.get('cedula') or ''
            tec = r.get('tecnico_nombre') or ''
            car = r.get('carpeta') or ''
            otv = r.get('ot')
            if ced not in grupos:
                grupos[ced] = {'carpeta': car, 'tecnico_nombre': tec, 'ots': set()}
            if otv is not None and str(otv).strip():
                grupos[ced]['ots'].add(str(otv).strip())

        items = []
        for ced, info in grupos.items():
            cur2.execute(
                "SELECT COALESCE(oks,0) FROM operaciones_facturacion WHERE cedula=%s AND periodo_year=%s AND periodo_month=%s LIMIT 1",
                (ced, year, month)
            )
            row = cur2.fetchone()
            oks = int(row[0]) if row and row[0] is not None else 0
            calidad = len(info['ots'])
            pct = (100.0 - (calidad * 100.0 / oks)) if oks > 0 else 0.0
            items.append({
                'cedula': ced,
                'carpeta': info['carpeta'],
                'tecnico_nombre': info['tecnico_nombre'],
                'oks': oks,
                'calidad': calidad,
                'porcentaje_calidad': round(pct, 2)
            })

        cur2.close(); cur.close(); connection.close()
        items.sort(key=lambda x: (str(x['carpeta'] or ''), str(x['tecnico_nombre'] or '')))
        return jsonify({'success': True, 'items': items})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/analistas/actividades-diarias', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_actividades_diarias_list():
    user_name = session.get('user_name', '')
    user_role = session.get('user_role')
    analista_override = request.args.get('analista', '').strip()
    if analista_override:
        ur = session.get('user_role')
        uid = str(session.get('id_codigo_consumidor', ''))
        uc = str(session.get('user_cedula', ''))
        if (ur in ('administrativo','lider')) or uid == '26' or uc == '52912112':
            user_name = analista_override
    fecha = request.args.get('fecha', '').strip()
    fecha_norm = fecha
    if fecha:
        for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
            try:
                fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                break
            except Exception:
                pass
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cursor.fetchall()}
        def norm(s):
            return re.sub(r"[^a-z0-9]", "", s.lower())
        def pick(names, approx=None):
            if approx is None:
                approx = []
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            if approx:
                nset = {norm(x) for x in approx}
                for k0,v0 in cols.items():
                    if norm(k0) in nset:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'], approx=['orden_de_trabajo','ordentrabajo','ot'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'], approx=['numerodecuenta','cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'], approx=['fechaactividad','fechaorden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'], approx=['external_id','exetrnal_id','idexterno','id_externo','cedula'])
        col_act_id = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        col_estado = pick(['estado'])
        col_final = pick(['estado_final','finalizado','final'])
        col_tip_ok = pick(['tipificacion_ok'])
        col_cierre = pick(['cierre_ciclo'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': False, 'items': [], 'message': 'Columnas requeridas no encontradas'}), 200
        tipo_fecha = None
        try:
            cursor.execute(
                """
                SELECT DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                """,
                (db_config.get('database'), col_fecha)
            )
            row = cursor.fetchone()
            if row:
                tipo_fecha = str(row[0]).lower()
        except Exception:
            tipo_fecha = None

        cursor.execute(
            """
            SELECT COLLATION_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='recurso_operativo' AND column_name='analista'
            """,
            (db_config.get('database'),)
        )
        collation_row = cursor.fetchone()
        coll = collation_row[0] if collation_row and collation_row[0] else 'utf8mb4_0900_ai_ci'
        cursor.execute(
            f"""
            SELECT recurso_operativo_cedula, id_codigo_consumidor, nombre
            FROM recurso_operativo
            WHERE LOWER(TRIM(analista)) COLLATE {coll} = LOWER(TRIM(CAST(%s AS CHAR CHARACTER SET utf8mb4))) COLLATE {coll}
            """,
            (user_name,)
        )
        tecnicos = cursor.fetchall()
        ids_all = []
        nombres_map = {}
        for t in tecnicos:
            try:
                ced = str(t[0]) if t[0] is not None else ''
                idc = str(t[1]) if len(t) > 1 and t[1] is not None else ''
                nom = t[2] if len(t) > 2 else (t[1] if len(t) > 1 else '')
                if ced:
                    ids_all.append(ced)
                    nombres_map[ced] = nom
                if idc:
                    ids_all.append(idc)
                    nombres_map[idc] = nom
            except Exception:
                pass
        filtro_fecha_sql = ''
        params = []
        if fecha:
            if tipo_fecha in ('datetime','timestamp','date'):
                filtro_fecha_sql = f" AND DATE(o.`{col_fecha}`) = %s"
                params.append(fecha_norm)
            else:
                try:
                    y = fecha_norm[0:4]
                    m = fecha_norm[5:7]
                    d = fecha_norm[8:10]
                    like_patterns = [
                        f"{fecha_norm}%",
                        f"{y}/{m}/{d}%",
                        f"{d}/{m}/{y}%",
                        f"{d}-{m}-{y}%"
                    ]
                except Exception:
                    like_patterns = [fecha_norm + '%']
                filtro_fecha_sql = " AND (" + " OR ".join([f"o.`{col_fecha}` LIKE %s"] * len(like_patterns)) + ")"
                params.extend(like_patterns)
        rows = []
        if ids_all:
            placeholders = ','.join(['%s'] * len(ids_all))
            filtro_final_sql = ''
            mostrar_finalizados = str(request.args.get('mostrar_finalizados','1')).strip().lower()
            if col_final and mostrar_finalizados in ('0','false','no'):
                filtro_final_sql = f" AND (o.`{col_final}` IS NULL OR CAST(o.`{col_final}` AS SIGNED) <> 1)"
            select_fields = [
                f"o.`{col_ot}` AS orden_de_trabajo",
                f"o.`{col_cuenta}` AS numero_de_cuenta",
                f"o.`{col_ext}` AS external_id",
                f"o.`{col_fecha}` AS fecha",
            ]
            if col_act_id:
                select_fields.insert(3, f"o.`{col_act_id}` AS actividad_id")
            if col_estado:
                select_fields.append(f"o.`{col_estado}` AS estado")
            if col_final:
                select_fields.append(f"o.`{col_final}` AS estado_final")
            if col_tip_ok:
                select_fields.append(f"o.`{col_tip_ok}` AS tipificacion_ok")
            if col_cierre:
                select_fields.append(f"o.`{col_cierre}` AS cierre_ciclo")
            if col_fecha_franja:
                select_fields.append(f"o.`{col_fecha_franja}` AS fecha_franja_cierre_ciclo")
            if col_franja_cierre:
                select_fields.append(f"o.`{col_franja_cierre}` AS franja_cierre_ciclo")
            if col_alerta:
                select_fields.append(f"o.`{col_alerta}` AS alerta_cierre_ciclo")
            sql = (
                "SELECT " + ", ".join(select_fields) +
                " FROM operaciones_actividades_diarias o" +
                f" WHERE CAST(o.`{col_ext}` AS CHAR) IN ({placeholders}) {filtro_fecha_sql}{filtro_final_sql}" +
                f" ORDER BY o.`{col_fecha}` DESC LIMIT 500"
            )
            cursor = connection.cursor(dictionary=True)
            cursor.execute(sql, tuple(ids_all) + tuple(params))
        base_rows = cursor.fetchall()
        now = datetime.now(TIMEZONE)
        bloqueo_inicio = TIMEZONE.localize(datetime(2025, 12, 16, 0, 0, 0))
        for r in base_rows:
            cid = str(r.get('external_id')) if r.get('external_id') is not None else ''
            r['tecnico'] = nombres_map.get(cid, '')
            should_hide = False
            try:
                act_date = None
                v = r.get('fecha')
                if isinstance(v, datetime):
                    act_date = v.date()
                else:
                    s = str(v).strip()
                    m = re.match(r"^(\d{4})-(\d{2})-(\d{2})", s)
                    if m:
                        act_date = datetime(int(m.group(1)), int(m.group(2)), int(m.group(3))).date()
                if now >= bloqueo_inicio and act_date:
                    dnext = act_date + timedelta(days=1)
                    cutoff = TIMEZONE.localize(datetime(dnext.year, dnext.month, dnext.day, 12, 0, 0))
                    if now >= cutoff:
                        ef = r.get('estado_final')
                        ef_val = None
                        try:
                            ef_val = int(ef)
                        except Exception:
                            ef_val = None
                        if ef_val != 1:
                            try:
                                cupd = connection.cursor()
                                conds = f"CAST(`{col_ot}` AS CHAR)=%s AND CAST(`{col_cuenta}` AS CHAR)=%s"
                                params_u = [str(r.get('orden_de_trabajo') or ''), str(r.get('numero_de_cuenta') or '')]
                                if col_act_id and r.get('actividad_id') is not None:
                                    conds += f" AND `{col_act_id}`=%s"
                                    params_u.append(r.get('actividad_id'))
                                else:
                                    vv = r.get('fecha')
                                    try:
                                        if isinstance(vv, datetime):
                                            conds += f" AND DATE(`{col_fecha}`)=%s"
                                            params_u.append(vv.date().strftime('%Y-%m-%d'))
                                        else:
                                            s0 = str(vv).strip()
                                            m3 = re.match(r"^(\d{4}-\d{2}-\d{2})", s0)
                                            if m3:
                                                conds += f" AND `{col_fecha}` LIKE %s"
                                                params_u.append(m3.group(1) + '%')
                                    except Exception:
                                        pass
                                sqlu = f"UPDATE `operaciones_actividades_diarias` SET `estado_final`=2 WHERE {conds} AND (`estado_final` IS NULL OR CAST(`estado_final` AS SIGNED) <> 1)"
                                cupd.execute(sqlu, tuple(params_u))
                                connection.commit()
                                cupd.close()
                            except Exception:
                                pass
                            if user_role in ('analista','analistas'):
                                should_hide = True
            except Exception:
                should_hide = False
            if should_hide:
                continue
            rows.append({
                'orden_de_trabajo': r.get('orden_de_trabajo'),
                'numero_de_cuenta': r.get('numero_de_cuenta'),
                'external_id': r.get('external_id'),
                'actividad_id': r.get('actividad_id'),
                'tecnico': r.get('tecnico'),
                'fecha': r.get('fecha'),
                'estado': (r.get('estado') or '').strip() if col_estado else '',
                'estado_final': r.get('estado_final') if col_final else None,
                'tipificacion_ok': r.get('tipificacion_ok') if col_tip_ok else None,
                'cierre_ciclo': r.get('cierre_ciclo') if col_cierre else None,
                'fecha_franja_cierre_ciclo': r.get('fecha_franja_cierre_ciclo') if col_fecha_franja else None,
                'franja_cierre_ciclo': r.get('franja_cierre_ciclo') if col_franja_cierre else None,
                'alerta_cierre_ciclo': r.get('alerta_cierre_ciclo') if col_alerta else None
            })
        cursor.close()
        connection.close()
        return jsonify({'success': True, 'items': rows})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/analistas/actividades-diarias/resumen', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_actividades_diarias_resumen():
    user_name = session.get('user_name', '')
    user_role = session.get('user_role')
    analista_override = request.args.get('analista', '').strip()
    if analista_override:
        ur = session.get('user_role')
        uid = str(session.get('id_codigo_consumidor', ''))
        uc = str(session.get('user_cedula', ''))
        if (ur in ('administrativo','lider')) or uid == '26' or uc == '52912112':
            user_name = analista_override
    fecha = request.args.get('fecha', '').strip()
    fecha_norm = fecha
    if fecha:
        for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
            try:
                fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                break
            except Exception:
                pass
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cursor.fetchall()}
        def pick(names, approx=None):
            if approx is None:
                approx = []
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            if approx:
                def norm(s):
                    import re
                    return re.sub(r"[^a-z0-9]", "", s.lower())
                aset = {norm(x) for x in approx}
                for k0,v0 in cols.items():
                    if norm(k0) in aset:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'], approx=['orden_de_trabajo','ordentrabajo','ot'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'], approx=['numerodecuenta','cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'], approx=['fechaactividad','fechaorden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'], approx=['external_id','exetrnal_id','idexterno','id_externo','cedula'])
        col_estado = pick(['estado'])
        col_final = pick(['estado_final','finalizado','final'])
        col_cierre = pick(['cierre_ciclo'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': False, 'resumen': {'completado': {'cantidad': 0, 'gestionada': 0}, 'no_completado': {'cantidad': 0, 'gestionada': 0}}}), 200
        cursor.execute(
            """
            SELECT COLLATION_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='recurso_operativo' AND column_name='analista'
            """,
            (db_config.get('database'),)
        )
        row = cursor.fetchone()
        coll = row[0] if row and row[0] else 'utf8mb4_general_ci'
        cursor.execute(
            f"""
            SELECT recurso_operativo_cedula, nombre
            FROM recurso_operativo
            WHERE LOWER(TRIM(analista)) COLLATE {coll} = LOWER(TRIM(CAST(%s AS CHAR CHARACTER SET utf8mb4))) COLLATE {coll}
            """,
            (user_name,)
        )
        tecnicos = cursor.fetchall()
        cedulas = [t[0] for t in tecnicos]
        filtro_fecha_sql = ''
        params = []
        if fecha:
            cursor.execute(
                """
                SELECT DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                """,
                (db_config.get('database'), col_fecha)
            )
            rt = cursor.fetchone()
            tipo_fecha = str(rt[0]).lower() if rt else None
            if tipo_fecha in ('datetime','timestamp','date'):
                filtro_fecha_sql = f" AND DATE(o.`{col_fecha}`) = %s"
                params.append(fecha_norm)
            else:
                filtro_fecha_sql = f" AND o.`{col_fecha}` LIKE %s"
                params.append(fecha_norm + '%')
        comp_total = 0
        comp_gest = 0
        ncomp_total = 0
        ncomp_gest = 0
        cancel_total = 0
        cancel_gest = 0
        m_comp_total = 0
        m_comp_gest = 0
        m_ncomp_total = 0
        m_ncomp_gest = 0
        m_cancel_total = 0
        m_cancel_gest = 0
        cc_gestionada = 0
        if cedulas and col_estado:
            placeholders = ','.join(['%s'] * len(cedulas))
            final_cond = ''
            if col_final:
                final_cond = f" AND CAST(o.`{col_final}` AS SIGNED) = 1"
            sql = f"""
                SELECT
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'completado' THEN 1 ELSE 0 END) AS comp_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'completado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS comp_gest,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'no completado' THEN 1 ELSE 0 END) AS ncomp_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'no completado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS ncomp_gest,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'cancelado' THEN 1 ELSE 0 END) AS cancel_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'cancelado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS cancel_gest
                FROM operaciones_actividades_diarias o
                WHERE CAST(o.`{col_ext}` AS CHAR) IN ({placeholders}) {filtro_fecha_sql}
                  AND o.`{col_cuenta}` IS NOT NULL
                  AND CAST(o.`{col_cuenta}` AS CHAR) <> ''
                  AND o.`{col_cuenta}` REGEXP '^[0-9]+'
                  AND CAST(o.`{col_cuenta}` AS SIGNED) > 0
                  AND CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 6
            """
            c2 = connection.cursor()
            c2.execute(sql, tuple(cedulas) + tuple(params))
            rr = c2.fetchone() or (0,0,0,0,0,0)
            try:
                comp_total = int(rr[0] or 0)
                comp_gest = int(rr[1] or 0)
                ncomp_total = int(rr[2] or 0)
                ncomp_gest = int(rr[3] or 0)
                cancel_total = int(rr[4] or 0)
                cancel_gest = int(rr[5] or 0)
            except Exception:
                comp_total = comp_total or 0
                comp_gest = comp_gest or 0
                ncomp_total = ncomp_total or 0
                ncomp_gest = ncomp_gest or 0
                cancel_total = cancel_total or 0
                cancel_gest = cancel_gest or 0
            c2.close()

            # Cálculo mensual acumulado
            # Determinar mes base usando fecha_norm o fecha actual
            base_date = None
            try:
                base_date = datetime.strptime(fecha_norm or '', '%Y-%m-%d') if fecha_norm else None
            except Exception:
                base_date = None
            if base_date is None:
                try:
                    now_str = datetime.now(TIMEZONE).strftime('%Y-%m-%d')
                    base_date = datetime.strptime(now_str, '%Y-%m-%d')
                except Exception:
                    base_date = datetime.now()
            month_start = base_date.replace(day=1).strftime('%Y-%m-%d')
            import calendar as _cal
            last_day = _cal.monthrange(base_date.year, base_date.month)[1]
            month_end = base_date.replace(day=last_day).strftime('%Y-%m-%d')
            # Detectar tipo de columna fecha para filtrar por mes
            filtro_mes_sql = ''
            mes_params = []
            try:
                cursor = connection.cursor()
                cursor.execute(
                    """
                    SELECT DATA_TYPE FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                    """,
                    (db_config.get('database'), col_fecha)
                )
                rowt = cursor.fetchone()
                tipo_fecha2 = str(rowt[0]).lower() if rowt else None
                cursor.close()
            except Exception:
                tipo_fecha2 = None
            if tipo_fecha2 in ('datetime','timestamp','date'):
                filtro_mes_sql = f" AND DATE(o.`{col_fecha}`) BETWEEN %s AND %s"
                mes_params.extend([month_start, month_end])
            else:
                # Asumir formato textual 'YYYY-MM-...'
                pref = base_date.strftime('%Y-%m-')
                filtro_mes_sql = f" AND o.`{col_fecha}` LIKE %s"
                mes_params.append(pref + '%')
            sqlm = f"""
                SELECT
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'completado' THEN 1 ELSE 0 END) AS comp_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'completado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS comp_gest,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'no completado' THEN 1 ELSE 0 END) AS ncomp_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'no completado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS ncomp_gest,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'cancelado' THEN 1 ELSE 0 END) AS cancel_total,
                  SUM(CASE WHEN LOWER(TRIM(o.`{col_estado}`)) = 'cancelado' {(' AND CAST(o.`' + col_final + '` AS SIGNED) = 1') if col_final else ''} THEN 1 ELSE 0 END) AS cancel_gest
                FROM operaciones_actividades_diarias o
                WHERE CAST(o.`{col_ext}` AS CHAR) IN ({placeholders}) {filtro_mes_sql}
                  AND o.`{col_cuenta}` IS NOT NULL
                  AND CAST(o.`{col_cuenta}` AS CHAR) <> ''
                  AND o.`{col_cuenta}` REGEXP '^[0-9]+'
                  AND CAST(o.`{col_cuenta}` AS SIGNED) > 0
                  AND CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 6
            """
            c3 = connection.cursor()
            c3.execute(sqlm, tuple(cedulas) + tuple(mes_params))
            rrm = c3.fetchone() or (0,0,0,0,0,0)
            try:
                m_comp_total = int(rrm[0] or 0)
                m_comp_gest = int(rrm[1] or 0)
                m_ncomp_total = int(rrm[2] or 0)
                m_ncomp_gest = int(rrm[3] or 0)
                m_cancel_total = int(rrm[4] or 0)
                m_cancel_gest = int(rrm[5] or 0)
            except Exception:
                m_comp_total = m_comp_total or 0
                m_comp_gest = m_comp_gest or 0
                m_ncomp_total = m_ncomp_total or 0
                m_ncomp_gest = m_ncomp_gest or 0
                m_cancel_total = 0
                m_cancel_gest = 0
            c3.close()
            if col_cierre:
                sql_cc = f"""
                    SELECT COUNT(*)
                    FROM operaciones_actividades_diarias o
                    WHERE CAST(o.`{col_ext}` AS CHAR) IN ({placeholders}) {filtro_mes_sql}
                      AND o.`{col_cuenta}` IS NOT NULL
                      AND CAST(o.`{col_cuenta}` AS CHAR) <> ''
                      AND o.`{col_cuenta}` REGEXP '^[0-9]+'
                      AND CAST(o.`{col_cuenta}` AS SIGNED) > 0
                      AND CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 6
                      AND LOWER(TRIM(o.`{col_estado}`)) = 'completado'
                      AND CAST(o.`{col_cierre}` AS SIGNED) = 1
                """
                c4 = connection.cursor()
                c4.execute(sql_cc, tuple(cedulas) + tuple(mes_params))
                rrc = c4.fetchone()
                try:
                    cc_gestionada = int(rrc[0] or 0)
                except Exception:
                    cc_gestionada = 0
                c4.close()

            cc_ots_mes = 0
            cc_calidad_mes = 0
            cc_calidad_pct = 0.0
            if col_ot and col_cierre:
                sql_ots = f"""
                    SELECT COUNT(DISTINCT CAST(o.`{col_ot}` AS CHAR))
                    FROM operaciones_actividades_diarias o
                    WHERE CAST(o.`{col_ext}` AS CHAR) IN ({placeholders}) {filtro_mes_sql}
                      AND o.`{col_cuenta}` IS NOT NULL
                      AND CAST(o.`{col_cuenta}` AS CHAR) <> ''
                      AND o.`{col_cuenta}` REGEXP '^[0-9]+'
                      AND CAST(o.`{col_cuenta}` AS SIGNED) > 0
                      AND CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 6
                      AND LOWER(TRIM(o.`{col_estado}`)) = 'completado'
                      AND CAST(o.`{col_cierre}` AS SIGNED) = 1
                """
                c5 = connection.cursor()
                c5.execute(sql_ots, tuple(cedulas) + tuple(mes_params))
                r_ots = c5.fetchone()
                try:
                    cc_ots_mes = int(r_ots[0] or 0)
                except Exception:
                    cc_ots_mes = 0
                c5.close()

                sql_cal = (
                    "SELECT COUNT(DISTINCT CAST(o.`" + col_ot + "` AS CHAR)) "
                    "FROM operaciones_actividades_diarias o "
                    "WHERE CAST(o.`" + col_ext + "` AS CHAR) IN (" + placeholders + ") " + filtro_mes_sql +
                    " AND o.`" + col_cuenta + "` IS NOT NULL"
                    " AND CAST(o.`" + col_cuenta + "` AS CHAR) <> ''"
                    " AND o.`" + col_cuenta + "` REGEXP '^[0-9]+'"
                    " AND CAST(o.`" + col_cuenta + "` AS SIGNED) > 0"
                    " AND CHAR_LENGTH(CAST(o.`" + col_cuenta + "` AS CHAR)) >= 6"
                    " AND LOWER(TRIM(o.`" + col_estado + "`)) = 'completado'"
                    " AND CAST(o.`" + col_cierre + "` AS SIGNED) = 1"
                    " AND EXISTS (SELECT 1 FROM operaciones_calidad oc "
                    "WHERE oc.ot = CAST(o.`" + col_ot + "` AS CHAR) AND oc.periodo_year = %s AND oc.periodo_month = %s)"
                )
                c6 = connection.cursor()
                c6.execute(sql_cal, tuple(cedulas) + tuple(mes_params) + (base_date.year, base_date.month))
                r_cal = c6.fetchone()
                try:
                    cc_calidad_mes = int(r_cal[0] or 0)
                except Exception:
                    cc_calidad_mes = 0
                c6.close()
                try:
                    cc_calidad_pct = round((100.0 - (cc_calidad_mes / cc_ots_mes * 100.0)), 1) if cc_ots_mes > 0 else 0.0
                except Exception:
                    cc_calidad_pct = 0.0

                cc_calidades_aplicadas = 0
                sql_cal_apl = (
                    "SELECT COUNT(*) "
                    "FROM operaciones_calidad oc "
                    "WHERE oc.periodo_year = %s AND oc.periodo_month = %s "
                    "AND EXISTS (SELECT 1 FROM operaciones_actividades_diarias o "
                    "WHERE CAST(o.`" + col_ext + "` AS CHAR) IN (" + placeholders + ") " + filtro_mes_sql +
                    " AND o.`" + col_cuenta + "` IS NOT NULL"
                    " AND CAST(o.`" + col_cuenta + "` AS CHAR) <> ''"
                    " AND o.`" + col_cuenta + "` REGEXP '^[0-9]+'"
                    " AND CAST(o.`" + col_cuenta + "` AS SIGNED) > 0"
                    " AND CHAR_LENGTH(CAST(o.`" + col_cuenta + "` AS CHAR)) >= 6"
                    " AND LOWER(TRIM(o.`" + col_estado + "`)) = 'completado'"
                    " AND CAST(o.`" + col_cierre + "` AS SIGNED) = 1"
                    " AND oc.ot = CAST(o.`" + col_ot + "` AS CHAR)"
                    ")"
                )
                c7 = connection.cursor()
                c7.execute(sql_cal_apl, (base_date.year, base_date.month) + tuple(cedulas) + tuple(mes_params))
                r_apl = c7.fetchone()
                try:
                    cc_calidades_aplicadas = int(r_apl[0] or 0)
                except Exception:
                    cc_calidades_aplicadas = 0
                c7.close()
        cursor.close()
        connection.close()
        return jsonify({
            'success': True,
            'resumen': {
                'completado': {
                    'cantidad': comp_total,
                    'gestionada': comp_gest
                },
                'no_completado': {
                    'cantidad': ncomp_total,
                    'gestionada': ncomp_gest
                },
                'cancelado': {
                    'cantidad': cancel_total,
                    'gestionada': cancel_gest
                }
            },
            'mensual': {
                'cantidad': (m_comp_total + m_ncomp_total + (m_cancel_total or 0)),
                'gestionada': (m_comp_gest + m_ncomp_gest + (m_cancel_gest or 0)),
                'cancelado': {
                    'cantidad': (m_cancel_total or 0),
                    'gestionada': (m_cancel_gest or 0)
                }
            },
            'cierre_ciclo': {
                'meta_mensual': 260,
                'gestionada': cc_gestionada,
                'porcentaje_meta': round((cc_gestionada/260*100), 1) if 260 > 0 else 0
            },
            'cierre_ciclo_calidad': {
                'ots_mes': cc_ots_mes,
                'con_calidad_mes': cc_calidad_mes,
                'porcentaje_mensual': cc_calidad_pct,
                'calidades_aplicadas': cc_calidades_aplicadas
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/analistas/actividades-diarias/export', methods=['GET'])
@login_required_api(role='administrativo')
def api_analistas_actividades_diarias_export():
    formato = (request.args.get('formato') or 'csv').strip().lower()
    fecha = (request.args.get('fecha') or '').strip()
    analista = (request.args.get('analista') or '').strip()
    mensual = ((request.args.get('mensual') or '').strip().lower() in ('1','true','si','yes'))
    solo_gest = ((request.args.get('gestionadas') or '').strip().lower() in ('1','true','si','yes'))
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in c.fetchall()}
        cols_type = {}
        try:
            c.execute(
                """
                SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                """,
                (db_config.get('database'),)
            )
            for r in c.fetchall() or []:
                cols_type[str(r[0]).lower()] = str(r[1]).lower()
        except Exception:
            cols_type = {}
        def pick(names, approx=None):
            if approx is None:
                approx = []
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            if approx:
                import re
                def norm(s):
                    return re.sub(r"[^a-z0-9]", "", s.lower())
                aset = {norm(x) for x in approx}
                for k0,v0 in cols.items():
                    if norm(k0) in aset:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'], approx=['orden_de_trabajo','ordentrabajo','ot'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'], approx=['numerodecuenta','cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'], approx=['fechaactividad','fechaorden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'], approx=['external_id','exetrnal_id','idexterno','id_externo','cedula'])
        col_estado = pick(['estado'])
        col_final = pick(['estado_final','finalizado','final'])
        col_cierre = pick(['cierre_ciclo'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        opt_cols = []
        for opt in ['tipificacion_ok','tipificacion_novedad','observacion_cierre','tipificacion_razon','tipo_razon_aplica','observacion_razon','confirmacion_evento','cancelado_tipificacion','cancelado_opcion_texto','cancelado_observacion']:
            if opt.lower() in cols:
                opt_cols.append(cols[opt.lower()])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': False, 'message': 'Columnas requeridas no encontradas'}), 200
        tipo_fecha = None
        try:
            c.execute(
                """
                SELECT DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                """,
                (db_config.get('database'), col_fecha)
            )
            rowt = c.fetchone()
            tipo_fecha = str(rowt[0]).lower() if rowt else None
        except Exception:
            tipo_fecha = None
        cedulas = []
        if analista:
            c.execute(
                """
                SELECT COLLATION_NAME FROM information_schema.columns
                WHERE table_schema=%s AND table_name='recurso_operativo' AND column_name='analista'
                """,
                (db_config.get('database'),)
            )
            rcoll = c.fetchone()
            coll = rcoll[0] if rcoll and rcoll[0] else 'utf8mb4_0900_ai_ci'
            c.execute(
                f"""
                SELECT recurso_operativo_cedula
                FROM recurso_operativo
                WHERE LOWER(TRIM(analista)) COLLATE {coll} = LOWER(TRIM(CAST(%s AS CHAR CHARACTER SET utf8mb4))) COLLATE {coll}
                """,
                (analista,)
            )
            cedulas = [r[0] for r in c.fetchall()]
        params = []
        where = []
        where.append(f"o.`{col_cuenta}` IS NOT NULL")
        where.append(f"CAST(o.`{col_cuenta}` AS CHAR) <> ''")
        tipo_cuenta = cols_type.get(col_cuenta.lower())
        is_numeric = str(tipo_cuenta or '').lower() in (
            'int','bigint','smallint','mediumint','tinyint','decimal','numeric','float','double')
        if is_numeric:
            where.append(f"CAST(o.`{col_cuenta}` AS SIGNED) > 0")
        else:
            where.append(f"CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 3")
        if col_estado:
            where.append(f"LOWER(TRIM(o.`{col_estado}`)) IN ('completado','no completado','cancelado')")
        if solo_gest:
            if col_final:
                where.append(f"CAST(o.`{col_final}` AS SIGNED) = 1")
            elif col_cierre:
                where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
        if fecha and not mensual:
            import re
            fecha_norm = fecha
            for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
                try:
                    fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                    break
                except Exception:
                    pass
            if tipo_fecha in ('datetime','timestamp','date'):
                where.append(f"DATE(o.`{col_fecha}`) = %s")
                params.append(fecha_norm)
            else:
                where.append(f"o.`{col_fecha}` LIKE %s")
                params.append(fecha_norm + '%')
        if mensual:
            from calendar import monthrange
            now = datetime.now(TIMEZONE)
            ms = f"{now.year}-{now.month:02d}-01"
            me = f"{now.year}-{now.month:02d}-{monthrange(now.year, now.month)[1]:02d}"
            if tipo_fecha in ('datetime','timestamp','date'):
                where.append(f"DATE(o.`{col_fecha}`) BETWEEN %s AND %s")
                params.extend([ms, me])
            else:
                pref = now.strftime('%Y-%m-')
                where.append(f"o.`{col_fecha}` LIKE %s")
                params.append(pref + '%')
        if cedulas:
            placeholders = ','.join(['%s'] * len(cedulas))
            where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
            params.extend(cedulas)
        select_parts = [
            f"o.`{col_ot}` AS orden_de_trabajo",
            f"o.`{col_cuenta}` AS numero_de_cuenta",
            f"o.`{col_ext}` AS tecnico_id",
        ]
        if tipo_fecha in ('datetime','timestamp','date'):
            select_parts.append(f"DATE_FORMAT(o.`{col_fecha}`, '%Y-%m-%d') AS fecha")
        else:
            select_parts.append(f"o.`{col_fecha}` AS fecha")
        if col_estado:
            select_parts.append(f"o.`{col_estado}` AS estado")
        if col_final:
            select_parts.append(f"o.`{col_final}` AS estado_final")
        if col_cierre:
            select_parts.append(f"o.`{col_cierre}` AS cierre_ciclo")
        if col_fecha_franja:
            tipo_fecha_franja = cols_type.get(col_fecha_franja.lower())
            if tipo_fecha_franja in ('datetime','timestamp','date'):
                select_parts.append(f"DATE_FORMAT(o.`{col_fecha_franja}`, '%Y-%m-%d') AS fecha_franja_cierre_ciclo")
            else:
                select_parts.append(f"o.`{col_fecha_franja}` AS fecha_franja_cierre_ciclo")
        if col_franja_cierre:
            select_parts.append(f"o.`{col_franja_cierre}` AS franja_cierre_ciclo")
        if col_alerta:
            select_parts.append(f"o.`{col_alerta}` AS alerta_cierre_ciclo")
        for oc in opt_cols:
            select_parts.append(f"o.`{oc}` AS `{oc}`")
        if col_cierre_super:
            select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
        if col_tip_super_1:
            select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
        if col_tip_super_2:
            select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
        if col_fecha_gestion_super:
            select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
        sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
        if where:
            sql += " WHERE " + " AND ".join(where)
        sql += f" ORDER BY o.`{col_fecha}` DESC"
        c = connection.cursor(dictionary=True)
        c.execute(sql, tuple(params))
        rows = c.fetchall() or []
        tecnico_ids = {str(r.get('tecnico_id')) for r in rows if r.get('tecnico_id') is not None}
        nombres_map = {}
        analistas_map = {}
        supervisores_map = {}
        if tecnico_ids:
            placeholders = ','.join(['%s'] * len(tecnico_ids))
            c2 = connection.cursor()
            # Mapear por cédula
            c2.execute(
                f"SELECT recurso_operativo_cedula, nombre, analista, super FROM recurso_operativo WHERE CAST(recurso_operativo_cedula AS CHAR) IN ({placeholders})",
                tuple(tecnico_ids)
            )
            for r in c2.fetchall() or []:
                k = str(r[0]); nombres_map[k] = r[1]
                analistas_map[k] = r[2] if len(r) > 2 else ''
                supervisores_map[k] = r[3] if len(r) > 3 else ''
            # Mapear por id_codigo_consumidor
            c2.execute(
                f"SELECT id_codigo_consumidor, nombre, analista, super FROM recurso_operativo WHERE CAST(id_codigo_consumidor AS CHAR) IN ({placeholders})",
                tuple(tecnico_ids)
            )
            for r in c2.fetchall() or []:
                k = str(r[0]); nombres_map[k] = r[1]
                analistas_map[k] = r[2] if len(r) > 2 else ''
                supervisores_map[k] = r[3] if len(r) > 3 else ''
            c2.close()
        for r in rows:
            cid = str(r.get('tecnico_id')) if r.get('tecnico_id') is not None else ''
            r['tecnico'] = nombres_map.get(cid, '')
            r['analista'] = analistas_map.get(cid, '')
            r['supervisor'] = supervisores_map.get(cid, '')
        c.close(); connection.close()
        if formato == 'xlsx':
            buf = io.BytesIO()
            pd.DataFrame(rows).to_excel(buf, index=False)
            buf.seek(0)
            filename = f"actividades_diarias_{datetime.now(TIMEZONE).strftime('%Y%m%d_%H%M%S')}.xlsx"
            return send_file(buf, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', as_attachment=True, download_name=filename)
        else:
            def fmt(v):
                if isinstance(v, datetime):
                    return v.strftime('%Y-%m-%d %H:%M:%S')
                return v
            si = io.StringIO()
            if rows:
                header = list(rows[0].keys())
            else:
                header = ['orden_de_trabajo','numero_de_cuenta','tecnico_id','tecnico','analista','supervisor','fecha','estado','estado_final','cierre_ciclo','fecha_franja_cierre_ciclo','franja_cierre_ciclo','alerta_cierre_ciclo','cierre_super','tip_super_1','tip_super_2','fecha_gestion_super'] + opt_cols
            w = csv.writer(si)
            w.writerow(header)
            for r in rows:
                w.writerow([fmt(r.get(h)) for h in header])
            output = si.getvalue()
            filename = f"actividades_diarias_{datetime.now(TIMEZONE).strftime('%Y%m%d_%H%M%S')}.csv"
            return Response(output, mimetype='text/csv; charset=utf-8', headers={'Content-Disposition': f'attachment; filename="{filename}"'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
# Detalle de actividad por OT y cuenta
@app.route('/api/analistas/actividad-detalle', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_detalle():
    ot = request.args.get('ot', '').strip()
    cuenta = request.args.get('cuenta', '').strip()
    fecha = request.args.get('fecha', '').strip()
    tecnico_id = request.args.get('tecnico_id', '').strip()
    estado_filtro = (request.args.get('estado') or '').strip().lower()
    actividad_id = request.args.get('actividad_id', '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in c.fetchall()}
        def pick(names, approx=None):
            if approx is None:
                approx = []
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            if approx:
                def norm(s):
                    import re
                    return re.sub(r"[^a-z0-9]", "", s.lower())
                aset = {norm(x) for x in approx}
                for k0,v0 in cols.items():
                    if norm(k0) in aset:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'], approx=['ordentrabajo','ot'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'], approx=['numerodecuenta','cuenta'])
        col_estado = pick(['estado'])
        col_nombre = pick(['nombre_completo','nombre'])
        col_tipo = pick(['tipo_de_actividad','tipo','actividad'])
        col_dir = pick(['direccion_campo_1','direccion'])
        col_tiempos = pick(['inicio_fin','tiempos','tiempo_gestion'])
        col_duracion = pick(['duracion','duración'])
        col_razon = pick(['razon','razón'])
        col_conf_evento = pick(['confirmacion_evento'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        col_act = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        params = []
        where = []
        if actividad_id and col_act:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = str(actividad_id)
            where.append(f"CAST(o.`{col_act}` AS CHAR) = %s")
            params.append(val_aid)
        if ot:
            where.append(f"CAST(o.`{col_ot}` AS CHAR) = %s")
            params.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
        if cuenta:
            where.append(f"CAST(o.`{col_cuenta}` AS CHAR) = %s")
            params.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
        # Filtrar por técnico si viene y existe la columna
        if tecnico_id and col_ext:
            try:
                val_tid = str(int(str(tecnico_id).split('.')[0]))
            except Exception:
                val_tid = str(tecnico_id)
            where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
            params.append(val_tid)
        # Filtrar por estado si viene y existe la columna
        if estado_filtro and col_estado:
            where.append(f"LOWER(TRIM(o.`{col_estado}`)) = %s")
            params.append(estado_filtro)
        sql = f"SELECT o.`{col_ot}` AS ot, o.`{col_cuenta}` AS cuenta"
        if col_estado: sql += f", o.`{col_estado}` AS estado"
        if col_nombre: sql += f", o.`{col_nombre}` AS nombre_completo"
        if col_tipo: sql += f", o.`{col_tipo}` AS tipo_de_actividad"
        if col_dir: sql += f", o.`{col_dir}` AS direccion_campo_1"
        if col_tiempos: sql += f", o.`{col_tiempos}` AS inicio_fin"
        if col_duracion: sql += f", o.`{col_duracion}` AS duracion"
        if col_razon: sql += f", o.`{col_razon}` AS razon"
        if col_conf_evento: sql += f", o.`{col_conf_evento}` AS confirmacion_evento"
        sql += " FROM operaciones_actividades_diarias o"
        if where:
            sql += " WHERE " + " AND ".join(where)
        # Filtro por fecha si se detecta columna y viene parámetro
        if fecha and col_fecha:
            # Detectar tipo de columna
            tipo_fecha = None
            try:
                c.execute(
                    """
                    SELECT DATA_TYPE FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                    """,
                    (db_config.get('database'), col_fecha)
                )
                rtf = c.fetchone()
                tipo_fecha = str(rtf[0]).lower() if rtf else None
            except Exception:
                tipo_fecha = None
            # Normalizar fecha
            fecha_norm = fecha
            for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
                try:
                    from datetime import datetime
                    fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                    break
                except Exception:
                    pass
            if ' WHERE ' in sql:
                sql += " AND "
            else:
                sql += " WHERE "
            if tipo_fecha in ('datetime','timestamp','date'):
                sql += f"DATE(o.`{col_fecha}`) = %s"
                params.append(fecha_norm)
            else:
                sql += f"o.`{col_fecha}` LIKE %s"
                params.append(fecha_norm + '%')
        # Ordenar por fecha si existe, si no por OT
        if col_fecha:
            sql += f" ORDER BY o.`{col_fecha}` DESC LIMIT 1"
        else:
            sql += " ORDER BY 1 DESC LIMIT 1"
        c = connection.cursor(dictionary=True)
        c.execute(sql, tuple(params))
        row = c.fetchone() or {}
        if not row:
            try:
                where_fb = []
                params_fb = []
                if ot:
                    where_fb.append(f"CAST(o.`{col_ot}` AS CHAR) = %s")
                    params_fb.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
                if cuenta:
                    where_fb.append(f"CAST(o.`{col_cuenta}` AS CHAR) = %s")
                    params_fb.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
                if tecnico_id and col_ext:
                    try:
                        val_tid = str(int(str(tecnico_id).split('.')[0]))
                    except Exception:
                        val_tid = str(tecnico_id)
                    where_fb.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params_fb.append(val_tid)
                sql_fb = f"SELECT o.`{col_ot}` AS ot, o.`{col_cuenta}` AS cuenta"
                if col_estado: sql_fb += f", o.`{col_estado}` AS estado"
                if col_nombre: sql_fb += f", o.`{col_nombre}` AS nombre_completo"
                if col_tipo: sql_fb += f", o.`{col_tipo}` AS tipo_de_actividad"
                if col_dir: sql_fb += f", o.`{col_dir}` AS direccion_campo_1"
                if col_tiempos: sql_fb += f", o.`{col_tiempos}` AS inicio_fin"
                if col_duracion: sql_fb += f", o.`{col_duracion}` AS duracion"
                if col_razon: sql_fb += f", o.`{col_razon}` AS razon"
                if col_conf_evento: sql_fb += f", o.`{col_conf_evento}` AS confirmacion_evento"
                sql_fb += " FROM operaciones_actividades_diarias o"
                if where_fb:
                    sql_fb += " WHERE " + " AND ".join(where_fb)
                if col_fecha:
                    sql_fb += f" ORDER BY o.`{col_fecha}` DESC LIMIT 1"
                else:
                    sql_fb += " ORDER BY 1 DESC LIMIT 1"
                c.execute(sql_fb, tuple(params_fb))
                row = c.fetchone() or {}
            except Exception:
                row = {}
        c.close(); connection.close()
        return jsonify({'success': True, 'data': row})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Verificar existencia de OT en la gestión de técnicos
@app.route('/api/analistas/ot-existe', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_ot_existe():
    ot = request.args.get('ot', '').strip()
    cuenta = request.args.get('cuenta', '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        where = []
        params = []
        if ot:
            where.append("ot = %s")
            params.append(int(str(ot).split('.')[0]))
        if cuenta:
            where.append("cuenta = %s")
            params.append(int(str(cuenta).split('.')[0]))
        sql = "SELECT COUNT(*) FROM gestion_ot_tecnicos"
        if where:
            sql += " WHERE " + " AND ".join(where)
        cur.execute(sql, tuple(params))
        exists = (cur.fetchone()[0] or 0) > 0
        cur.close(); connection.close()
        return jsonify({'success': True, 'exists': exists})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Marcar actividad como facturada por analista
@app.route('/api/analistas/actividad-marcar-facturada', methods=['POST'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_marcar_facturada():
    data = request.get_json() or {}
    ot = str(data.get('ot') or '').strip()
    cuenta = str(data.get('cuenta') or '').strip()
    actividad_id = str(data.get('actividad_id') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        # Asegurar columna facturado_analista
        cur.execute(
            """
            SELECT COUNT(*) FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name='facturado_analista'
            """,
            (db_config.get('database'),)
        )
        has_col = cur.fetchone()[0] > 0
        if not has_col:
            cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `facturado_analista` TINYINT(1) NULL DEFAULT NULL")
        # Detectar nombres de columnas ot/cuenta
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                if n.lower() in cols:
                    return cols[n.lower()]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_act_id = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        col_final = pick(['estado_final','finalizado','final'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        where = []
        params = []
        if ot:
            where.append(f"CAST(`{col_ot}` AS CHAR) = %s")
            params.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
        if cuenta:
            where.append(f"CAST(`{col_cuenta}` AS CHAR) = %s")
            params.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
        if actividad_id and col_act_id:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = actividad_id
            where.append(f"CAST(`{col_act_id}` AS CHAR) = %s")
            params.append(val_aid)
        if not where:
            return jsonify({'success': False, 'error': 'Faltan OT/Cuenta'}), 400
        expired_cond = ''
        if col_final:
            expired_cond = f" AND (`{col_final}` IS NULL OR CAST(`{col_final}` AS SIGNED) <> 2)"
        sql = f"UPDATE `operaciones_actividades_diarias` SET `facturado_analista`=1 WHERE " + " AND ".join(where) + expired_cond
        cur.execute(sql, tuple(params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'updated': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/analistas/actividad-cierre', methods=['POST'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_cierre():
    data = request.get_json() or {}
    ot = str(data.get('ot') or '').strip()
    cuenta = str(data.get('cuenta') or '').strip()
    actividad_id = str(data.get('actividad_id') or '').strip()
    tip_ok = str(data.get('tipificacion_ok') or '').strip()
    tip_nov = str(data.get('tipificacion_novedad') or '').strip()
    observ = str(data.get('observacion') or '').strip()
    conf_evento = data.get('confirmacion_evento')
    fecha_franja = str(data.get('fecha_franja_cierre_ciclo') or '').strip()
    franja_cierre = str(data.get('franja_cierre_ciclo') or '').strip()
    alerta_cierre = str(data.get('alerta_cierre_ciclo') or '').strip()
    cierre_flag = data.get('cierre_ciclo')
    cierre_true = False
    try:
        cierre_true = (cierre_flag is not None) and (str(cierre_flag).strip().lower() in ('1','true','si','sí'))
    except Exception:
        cierre_true = False
    tip_ok_upper = (tip_ok or '').strip().upper()
    if cierre_true and tip_ok_upper == 'CLIENTE INCONFORME':
        faltantes = []
        if not observ:
            faltantes.append('observacion')
        if not fecha_franja:
            faltantes.append('fecha_franja_cierre_ciclo')
        if not franja_cierre:
            faltantes.append('franja_cierre_ciclo')
        if not alerta_cierre:
            faltantes.append('alerta_cierre_ciclo')
        if faltantes:
            return jsonify({'success': False, 'code': 'VALIDATION_ERROR', 'missing': faltantes, 'error': 'Faltan campos requeridos para cierre de ciclo CLIENTE INCONFORME'}), 400
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        # Asegurar columnas
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def ensure_col(name, ddl):
            if name.lower() not in cols:
                cur.execute(ddl)
        # Reducir tamaño de fila: usar TEXT para tipificaciones
        ensure_col('tipificacion_ok', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tipificacion_ok` TEXT NULL")
        ensure_col('tipificacion_novedad', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tipificacion_novedad` TEXT NULL")
        ensure_col('observacion_cierre', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `observacion_cierre` TEXT NULL")
        ensure_col('estado_final', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `estado_final` TINYINT(1) NULL DEFAULT 0")
        ensure_col('confirmacion_evento', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `confirmacion_evento` TINYINT(1) NULL")
        ensure_col('cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `cierre_ciclo` TINYINT(1) NULL DEFAULT 0")
        ensure_col('fecha_franja_cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `fecha_franja_cierre_ciclo` DATE NULL")
        ensure_col('franja_cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `franja_cierre_ciclo` TEXT NULL")
        ensure_col('alerta_cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `alerta_cierre_ciclo` TEXT NULL")
        ensure_col('analista', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `analista` VARCHAR(255) NULL")
        try:
            cur.execute(
                """
                SELECT column_name, data_type FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                AND column_name IN ('tipificacion_ok','tipificacion_novedad')
                """,
                (db_config.get('database'),)
            )
            for cname, dtype in cur.fetchall():
                if str(dtype).lower().startswith('varchar'):
                    cur.execute(f"ALTER TABLE `operaciones_actividades_diarias` MODIFY COLUMN `{cname}` TEXT NULL")
        except Exception:
            pass
        try:
            cur.execute("ALTER TABLE `operaciones_actividades_diarias` ROW_FORMAT=DYNAMIC")
        except Exception:
            pass
        # Detectar columnas ot/cuenta
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                if n.lower() in cols:
                    return cols[n.lower()]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_act_id = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        col_final = pick(['estado_final','finalizado','final'])
        col_analista = pick(['analista','analista_nombre','nombre_analista'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        where = []
        params = []
        if ot:
            where.append(f"CAST(`{col_ot}` AS CHAR) = %s")
            params.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
        if cuenta:
            where.append(f"CAST(`{col_cuenta}` AS CHAR) = %s")
            params.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
        if actividad_id and col_act_id:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = actividad_id
            where.append(f"CAST(`{col_act_id}` AS CHAR) = %s")
            params.append(val_aid)
        if not where:
            return jsonify({'success': False, 'error': 'Faltan OT/Cuenta'}), 400
        if col_fecha:
            c2 = connection.cursor()
            c2.execute(f"SELECT o.`{col_fecha}` FROM operaciones_actividades_diarias o WHERE " + " AND ".join(where) + " LIMIT 1", tuple(params))
            rdt = c2.fetchone()
            c2.close()
            if rdt:
                v = rdt[0]
                act_date = None
                try:
                    if isinstance(v, datetime):
                        act_date = v.date()
                    else:
                        s = str(v).strip()
                        m = re.match(r"^(\d{4})-(\d{2})-(\d{2})", s)
                        if m:
                            act_date = datetime(int(m.group(1)), int(m.group(2)), int(m.group(3))).date()
                except Exception:
                    act_date = None
                now = datetime.now(TIMEZONE)
                bloqueo_inicio = TIMEZONE.localize(datetime(2025, 12, 16, 0, 0, 0))
                if now >= bloqueo_inicio and act_date:
                    dnext = act_date + timedelta(days=1)
                    cutoff = TIMEZONE.localize(datetime(dnext.year, dnext.month, dnext.day, 12, 0, 0))
                    if now >= cutoff:
                        try:
                            c3 = connection.cursor()
                            fecha_cond = ""
                            fecha_param = None
                            try:
                                if isinstance(v, datetime):
                                    fecha_cond = f" AND DATE(`{col_fecha}`) = %s"
                                    fecha_param = v.date().strftime('%Y-%m-%d')
                                else:
                                    s0 = str(v).strip()
                                    m2 = re.match(r"^(\d{4}-\d{2}-\d{2})", s0)
                                    if m2:
                                        fecha_cond = f" AND `{col_fecha}` LIKE %s"
                                        fecha_param = m2.group(1) + '%'
                            except Exception:
                                fecha_cond = ""
                                fecha_param = None
                            sqlb = "UPDATE `operaciones_actividades_diarias` SET `estado_final`=2 WHERE " + " AND ".join(where) + fecha_cond + " AND (`estado_final` IS NULL OR CAST(`estado_final` AS SIGNED) <> 1)"
                            p = tuple(params + ([fecha_param] if fecha_param else []))
                            c3.execute(sqlb, p)
                            connection.commit()
                            c3.close()
                        except Exception:
                            pass
                        return jsonify({'success': False, 'code': 'BLOCKED_BY_CUTOFF'}), 403
        set_parts = []
        set_vals = []
        ext_payload = str((data.get('external_id') or '').strip())
        if ext_payload:
            try:
                cext = None
                cur.execute(
                    """
                    SELECT COLUMN_NAME FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                    """,
                    (db_config.get('database'),)
                )
                cols_ext = {r[0].lower(): r[0] for r in cur.fetchall()}
                def picke(names):
                    for n in names:
                        if n.lower() in cols_ext:
                            return cols_ext[n.lower()]
                    for k0,v0 in cols_ext.items():
                        for n in names:
                            if n.lower() in k0:
                                return v0
                    return None
                cext = picke(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
                if not cext:
                    try:
                        cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `external_id` VARCHAR(64) NULL")
                        cext = 'external_id'
                    except Exception:
                        cext = None
                if cext:
                    set_parts.append(f"`{cext}`=%s")
                    set_vals.append(ext_payload)
            except Exception:
                pass
        if tip_ok:
            set_parts.append("`tipificacion_ok`=%s")
            set_vals.append(tip_ok)
        else:
            set_parts.append("`tipificacion_ok`=NULL")
        if tip_nov:
            set_parts.append("`tipificacion_novedad`=%s")
            set_vals.append(tip_nov)
        else:
            set_parts.append("`tipificacion_novedad`=NULL")
        if observ:
            set_parts.append("`observacion_cierre`=%s")
            set_vals.append(observ)
        else:
            set_parts.append("`observacion_cierre`=NULL")
        if conf_evento is not None:
            set_parts.append("`confirmacion_evento`=%s")
            set_vals.append(1 if str(conf_evento).strip() in ('1','true','si','Sí') else 0)
        cierre_ciclo = data.get('cierre_ciclo')
        if cierre_ciclo is not None:
            set_parts.append("`cierre_ciclo`=%s")
            set_vals.append(1 if str(cierre_ciclo).strip() in ('1','true','si','Sí') else 0)
        if fecha_franja:
            set_parts.append("`fecha_franja_cierre_ciclo`=%s")
            set_vals.append(fecha_franja)
        if franja_cierre:
            set_parts.append("`franja_cierre_ciclo`=%s")
            set_vals.append(franja_cierre)
        tip_ok_upper = (tip_ok or '').strip().upper()
        if alerta_cierre:
            set_parts.append("`alerta_cierre_ciclo`=%s")
            set_vals.append(alerta_cierre)
        elif tip_ok_upper and tip_ok_upper != 'CLIENTE INCONFORME':
            set_parts.append("`alerta_cierre_ciclo`=NULL")
        # Marcar finalizado al concluir
        set_parts.append("`estado_final`=1")
        # Guardar analista (nombre de quien realiza la gestión)
        try:
            analista_nombre = (session.get('user_name') or '').strip()
        except Exception:
            analista_nombre = ''
        if analista_nombre:
            if not col_analista:
                col_analista = 'analista'
            set_parts.append(f"`{col_analista}`=%s")
            set_vals.append(analista_nombre)
        expired_cond = ''
        if col_final:
            expired_cond = f" AND (`{col_final}` IS NULL OR CAST(`{col_final}` AS SIGNED) <> 2)"
        sql = f"UPDATE `operaciones_actividades_diarias` SET {', '.join(set_parts)} WHERE " + " AND ".join(where) + expired_cond
        cur.execute(sql, tuple(set_vals + params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'updated': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/analistas/actividad-razon', methods=['POST'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_razon():
    data = request.get_json() or {}
    ot = str(data.get('ot') or '').strip()
    cuenta = str(data.get('cuenta') or '').strip()
    actividad_id = str(data.get('actividad_id') or '').strip()
    tip_razon = str(data.get('tipificacion_razon') or '').strip()
    aplica = data.get('tipo_razon_aplica')
    observ = str(data.get('observacion_razon') or '').strip()
    conf_evento = data.get('confirmacion_evento')
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        # Asegurar columnas requeridas
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def ensure_col(name, ddl):
            if name.lower() not in cols:
                cur.execute(ddl)
        # Reducir tamaño de fila: usar TEXT para tipificacion_razon
        ensure_col('tipificacion_razon', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tipificacion_razon` TEXT NULL")
        ensure_col('tipo_razon_aplica', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tipo_razon_aplica` TINYINT(1) NULL")
        ensure_col('observacion_razon', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `observacion_razon` TEXT NULL")
        ensure_col('confirmacion_evento', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `confirmacion_evento` TINYINT(1) NULL")
        ensure_col('estado_final', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `estado_final` TINYINT(1) NULL DEFAULT 0")
        # Si las columnas existen como VARCHAR, convertir a TEXT
        try:
            cur.execute(
                """
                SELECT column_name, data_type FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                AND column_name IN ('tipificacion_razon')
                """,
                (db_config.get('database'),)
            )
            for cname, dtype in cur.fetchall():
                if str(dtype).lower().startswith('varchar'):
                    cur.execute(f"ALTER TABLE `operaciones_actividades_diarias` MODIFY COLUMN `{cname}` TEXT NULL")
        except Exception:
            pass
        try:
            cur.execute("ALTER TABLE `operaciones_actividades_diarias` ROW_FORMAT=DYNAMIC")
        except Exception:
            pass
        # Detectar columnas ot/cuenta
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                if n.lower() in cols:
                    return cols[n.lower()]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_act_id = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        col_final = pick(['estado_final','finalizado','final'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        where = []
        params = []
        if ot:
            where.append(f"CAST(`{col_ot}` AS CHAR) = %s")
            params.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
        if cuenta:
            where.append(f"CAST(`{col_cuenta}` AS CHAR) = %s")
            params.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
        if actividad_id and col_act_id:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = actividad_id
            where.append(f"CAST(`{col_act_id}` AS CHAR) = %s")
            params.append(val_aid)
        if not where:
            return jsonify({'success': False, 'error': 'Faltan OT/Cuenta'}), 400
        if col_fecha:
            c2 = connection.cursor()
            c2.execute(f"SELECT o.`{col_fecha}` FROM operaciones_actividades_diarias o WHERE " + " AND ".join(where) + " LIMIT 1", tuple(params))
            rdt = c2.fetchone()
            c2.close()
            if rdt:
                v = rdt[0]
                act_date = None
                try:
                    if isinstance(v, datetime):
                        act_date = v.date()
                    else:
                        s = str(v).strip()
                        m = re.match(r"^(\d{4})-(\d{2})-(\d{2})", s)
                        if m:
                            act_date = datetime(int(m.group(1)), int(m.group(2)), int(m.group(3))).date()
                except Exception:
                    act_date = None
                now = datetime.now(TIMEZONE)
                bloqueo_inicio = TIMEZONE.localize(datetime(2025, 12, 16, 0, 0, 0))
                if now >= bloqueo_inicio and act_date:
                    dnext = act_date + timedelta(days=1)
                    cutoff = TIMEZONE.localize(datetime(dnext.year, dnext.month, dnext.day, 12, 0, 0))
                    if now >= cutoff:
                        try:
                            c3 = connection.cursor()
                            fecha_cond = ""
                            fecha_param = None
                            try:
                                if isinstance(v, datetime):
                                    fecha_cond = f" AND DATE(`{col_fecha}`) = %s"
                                    fecha_param = v.date().strftime('%Y-%m-%d')
                                else:
                                    s0 = str(v).strip()
                                    m2 = re.match(r"^(\d{4}-\d{2}-\d{2})", s0)
                                    if m2:
                                        fecha_cond = f" AND `{col_fecha}` LIKE %s"
                                        fecha_param = m2.group(1) + '%'
                            except Exception:
                                fecha_cond = ""
                                fecha_param = None
                            sqlb = "UPDATE `operaciones_actividades_diarias` SET `estado_final`=2 WHERE " + " AND ".join(where) + fecha_cond + " AND (`estado_final` IS NULL OR CAST(`estado_final` AS SIGNED) <> 1)"
                            p = tuple(params + ([fecha_param] if fecha_param else []))
                            c3.execute(sqlb, p)
                            connection.commit()
                            c3.close()
                        except Exception:
                            pass
                        return jsonify({'success': False, 'code': 'BLOCKED_BY_CUTOFF'}), 403
        set_parts = []
        set_vals = []
        ext_payload = str((data.get('external_id') or '').strip())
        if ext_payload:
            try:
                cext = None
                cur.execute(
                    """
                    SELECT COLUMN_NAME FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                    """,
                    (db_config.get('database'),)
                )
                cols_ext = {r[0].lower(): r[0] for r in cur.fetchall()}
                def picke(names):
                    for n in names:
                        if n.lower() in cols_ext:
                            return cols_ext[n.lower()]
                    for k0,v0 in cols_ext.items():
                        for n in names:
                            if n.lower() in k0:
                                return v0
                    return None
                cext = picke(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
                if not cext:
                    try:
                        cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `external_id` VARCHAR(64) NULL")
                        cext = 'external_id'
                    except Exception:
                        cext = None
                if cext:
                    set_parts.append(f"`{cext}`=%s")
                    set_vals.append(ext_payload)
            except Exception:
                pass
        if tip_razon:
            set_parts.append("`tipificacion_razon`=%s")
            set_vals.append(tip_razon)
        else:
            set_parts.append("`tipificacion_razon`=NULL")
        if aplica is not None:
            set_parts.append("`tipo_razon_aplica`=%s")
            set_vals.append(1 if str(aplica).strip() in ('1','true','si','Sí') else 0)
        else:
            set_parts.append("`tipo_razon_aplica`=NULL")
        if observ:
            set_parts.append("`observacion_razon`=%s")
            set_vals.append(observ)
        else:
            set_parts.append("`observacion_razon`=NULL")
        if conf_evento is not None:
            set_parts.append("`confirmacion_evento`=%s")
            set_vals.append(1 if str(conf_evento).strip() in ('1','true','si','Sí') else 0)
        else:
            set_parts.append("`confirmacion_evento`=NULL")
        set_parts.append("`estado_final`=1")
        expired_cond = ''
        if col_final:
            expired_cond = f" AND (`{col_final}` IS NULL OR CAST(`{col_final}` AS SIGNED) <> 2)"
        sql = f"UPDATE `operaciones_actividades_diarias` SET {', '.join(set_parts)} WHERE " + " AND ".join(where) + expired_cond
        cur.execute(sql, tuple(set_vals + params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'updated': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/analistas/actividad-cancelado', methods=['POST'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_cancelado():
    data = request.get_json() or {}
    ot = str(data.get('ot') or '').strip()
    cuenta = str(data.get('cuenta') or '').strip()
    actividad_id = str(data.get('actividad_id') or '').strip()
    tip_cancelado = str(data.get('cancelado_tipificacion') or '').strip()
    texto_opcion = str(data.get('cancelado_opcion_texto') or '').strip()
    observ = str(data.get('cancelado_observacion') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def ensure_col(name, ddl):
            if name.lower() not in cols:
                try:
                    cur.execute(ddl)
                except Exception:
                    pass
        ensure_col('cancelado_tipificacion', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `cancelado_tipificacion` TEXT NULL")
        ensure_col('cancelado_opcion_texto', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `cancelado_opcion_texto` TEXT NULL")
        ensure_col('cancelado_observacion', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `cancelado_observacion` TEXT NULL")
        ensure_col('estado_final', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `estado_final` TINYINT(1) NULL DEFAULT 0")
        try:
            cur.execute(
                """
                SELECT column_name, data_type FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                AND column_name IN ('cancelado_tipificacion')
                """,
                (db_config.get('database'),)
            )
            for cname, dtype in cur.fetchall():
                if str(dtype).lower().startswith('varchar'):
                    cur.execute(f"ALTER TABLE `operaciones_actividades_diarias` MODIFY COLUMN `{cname}` TEXT NULL")
        except Exception:
            pass
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                if n.lower() in cols:
                    return cols[n.lower()]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_act_id = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        col_final = pick(['estado_final','finalizado','final'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        where = []
        params = []
        if ot:
            where.append(f"CAST(`{col_ot}` AS CHAR) = %s")
            val_ot = str(ot).split('.')[0].strip()
            try:
                val_ot = str(int(val_ot))
            except Exception:
                pass
            params.append(val_ot)
        if cuenta:
            where.append(f"CAST(`{col_cuenta}` AS CHAR) = %s")
            val_cta = str(cuenta).split('.')[0].strip()
            try:
                val_cta = str(int(val_cta))
            except Exception:
                pass
            params.append(val_cta)
        if actividad_id and col_act_id:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = actividad_id
            where.append(f"CAST(`{col_act_id}` AS CHAR) = %s")
            params.append(val_aid)
        if not where:
            return jsonify({'success': False, 'error': 'Faltan OT/Cuenta'}), 400
        if col_fecha:
            c2 = connection.cursor()
            c2.execute(f"SELECT o.`{col_fecha}` FROM operaciones_actividades_diarias o WHERE " + " AND ".join(where) + " LIMIT 1", tuple(params))
            rdt = c2.fetchone()
            c2.close()
            if rdt:
                v = rdt[0]
                act_date = None
                try:
                    if isinstance(v, datetime):
                        act_date = v.date()
                    else:
                        s = str(v).strip()
                        m = re.match(r"^(\d{4})-(\d{2})-(\d{2})", s)
                        if m:
                            act_date = datetime(int(m.group(1)), int(m.group(2)), int(m.group(3))).date()
                except Exception:
                    act_date = None
                now = datetime.now(TIMEZONE)
                bloqueo_inicio = TIMEZONE.localize(datetime(2025, 12, 16, 0, 0, 0))
                if now >= bloqueo_inicio and act_date:
                    dnext = act_date + timedelta(days=1)
                    cutoff = TIMEZONE.localize(datetime(dnext.year, dnext.month, dnext.day, 12, 0, 0))
                    if now >= cutoff:
                        try:
                            c3 = connection.cursor()
                            fecha_cond = ""
                            fecha_param = None
                            try:
                                if isinstance(v, datetime):
                                    fecha_cond = f" AND DATE(`{col_fecha}`) = %s"
                                    fecha_param = v.date().strftime('%Y-%m-%d')
                                else:
                                    s0 = str(v).strip()
                                    m2 = re.match(r"^(\d{4}-\d{2}-\d{2})", s0)
                                    if m2:
                                        fecha_cond = f" AND `{col_fecha}` LIKE %s"
                                        fecha_param = m2.group(1) + '%'
                            except Exception:
                                fecha_cond = ""
                                fecha_param = None
                            sqlb = "UPDATE `operaciones_actividades_diarias` SET `estado_final`=2 WHERE " + " AND ".join(where) + fecha_cond + " AND (`estado_final` IS NULL OR CAST(`estado_final` AS SIGNED) <> 1)"
                            p = tuple(params + ([fecha_param] if fecha_param else []))
                            c3.execute(sqlb, p)
                            connection.commit()
                            c3.close()
                        except Exception:
                            pass
                        return jsonify({'success': False, 'code': 'BLOCKED_BY_CUTOFF'}), 403
        set_parts = []
        set_vals = []
        ext_payload = str((data.get('external_id') or '').strip())
        if ext_payload:
            try:
                cext = None
                cur.execute(
                    """
                    SELECT COLUMN_NAME FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                    """,
                    (db_config.get('database'),)
                )
                cols_ext = {r[0].lower(): r[0] for r in cur.fetchall()}
                def picke(names):
                    for n in names:
                        if n.lower() in cols_ext:
                            return cols_ext[n.lower()]
                    for k0,v0 in cols_ext.items():
                        for n in names:
                            if n.lower() in k0:
                                return v0
                    return None
                cext = picke(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
                if not cext:
                    try:
                        cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `external_id` VARCHAR(64) NULL")
                        cext = 'external_id'
                    except Exception:
                        cext = None
                if cext:
                    set_parts.append(f"`{cext}`=%s")
                    set_vals.append(ext_payload)
            except Exception:
                pass
        has_tip = 'cancelado_tipificacion' in cols
        has_texto = 'cancelado_opcion_texto' in cols
        has_obs = 'cancelado_observacion' in cols
        has_final = 'estado_final' in cols
        if has_tip:
            if tip_cancelado:
                set_parts.append("`cancelado_tipificacion`=%s")
                set_vals.append(tip_cancelado)
            else:
                set_parts.append("`cancelado_tipificacion`=NULL")
        texto_final = texto_opcion if (tip_cancelado.strip().upper() == 'OTRA' and texto_opcion) else None
        if has_texto:
            if texto_final is not None:
                set_parts.append("`cancelado_opcion_texto`=%s")
                set_vals.append(texto_final)
            else:
                set_parts.append("`cancelado_opcion_texto`=NULL")
        if has_obs:
            if observ:
                set_parts.append("`cancelado_observacion`=%s")
                set_vals.append(observ)
            else:
                set_parts.append("`cancelado_observacion`=NULL")
        if has_final:
            set_parts.append("`estado_final`=1")
        expired_cond = ''
        if col_final:
            expired_cond = f" AND (`{col_final}` IS NULL OR CAST(`{col_final}` AS SIGNED) <> 2)"
        sql = f"UPDATE `operaciones_actividades_diarias` SET {', '.join(set_parts)} WHERE " + " AND ".join(where) + expired_cond
        cur.execute(sql, tuple(set_vals + params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'updated': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/analistas/actividad-gestion-update', methods=['POST'])
@login_required_analistas_or_lider_api()
def api_analistas_actividad_gestion_update():
    data = request.get_json() or {}
    ot = str(data.get('ot') or '').strip()
    cuenta = str(data.get('cuenta') or '').strip()
    actividad_id = str(data.get('actividad_id') or '').strip()
    tecnico = str(data.get('tecnico') or '').strip()
    external_id = str(data.get('external_id') or '').strip()
    estado = str(data.get('estado') or '').strip()
    nombre = str(data.get('nombre_completo') or data.get('nombre') or '').strip()
    tipo = str(data.get('tipo_de_actividad') or data.get('tipo') or '').strip()
    direccion = str(data.get('direccion') or data.get('direccion_campo_1') or '').strip()
    tiempos = str(data.get('inicio_fin') or data.get('tiempo_gestion') or '').strip()
    duracion = str(data.get('duracion') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute(
            """
            SELECT COUNT(*) FROM information_schema.tables
            WHERE table_schema=%s AND table_name=%s
            """,
            (db_config.get('database'), 'operaciones_actividades_diarias')
        )
        if (cur.fetchone() or [0])[0] == 0:
            cur.close(); connection.close()
            return jsonify({'success': True, 'updated': False})
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                if n.lower() in cols:
                    return cols[n.lower()]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        def ensure_col(name, ddl):
            if name.lower() not in cols:
                try:
                    cur.execute(ddl)
                except Exception:
                    pass
        c_ot = pick(['orden_de_trabajo','ot','orden','orden_trabajo'])
        c_cta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        c_act = pick(['actividad_id','id_actividad','id_actividad_diaria'])
        c_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        c_tec = pick(['tecnico','tecnico_nombre'])
        c_estado = pick(['estado'])
        c_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        c_nom = pick(['nombre_completo','nombre'])
        c_tipo = pick(['tipo_de_actividad','tipo','actividad'])
        c_dir = pick(['direccion_campo_1','direccion'])
        c_tiempos = pick(['inicio_fin','tiempos','tiempo_gestion'])
        c_dur = pick(['duracion','duración'])
        if not c_ot or not c_cta:
            return jsonify({'success': False, 'error': 'Columnas OT/Cuenta no detectadas'}), 200
        if not c_ext:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `external_id` VARCHAR(64) NULL")
                c_ext = 'external_id'
            except Exception:
                pass
        if not c_tec:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tecnico` TEXT NULL")
                c_tec = 'tecnico'
            except Exception:
                pass
        if not c_estado:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `estado` TEXT NULL")
                c_estado = 'estado'
            except Exception:
                pass
        if not c_nom:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `nombre_completo` TEXT NULL")
                c_nom = 'nombre_completo'
            except Exception:
                pass
        if not c_tipo:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tipo_de_actividad` TEXT NULL")
                c_tipo = 'tipo_de_actividad'
            except Exception:
                pass
        if not c_dir:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `direccion_campo_1` TEXT NULL")
                c_dir = 'direccion_campo_1'
            except Exception:
                pass
        if not c_tiempos:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `inicio_fin` TEXT NULL")
                c_tiempos = 'inicio_fin'
            except Exception:
                pass
        if not c_dur:
            try:
                cur.execute("ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `duracion` TEXT NULL")
                c_dur = 'duracion'
            except Exception:
                pass
        where = []
        params = []
        if ot:
            where.append(f"CAST(`{c_ot}` AS CHAR) = %s")
            params.append(str(int(str(ot).split('.')[0])) if str(ot).strip() else ot)
        if cuenta:
            where.append(f"CAST(`{c_cta}` AS CHAR) = %s")
            params.append(str(int(str(cuenta).split('.')[0])) if str(cuenta).strip() else cuenta)
        if actividad_id and c_act:
            try:
                val_aid = str(int(str(actividad_id).split('.')[0]))
            except Exception:
                val_aid = actividad_id
            where.append(f"CAST(`{c_act}` AS CHAR) = %s")
            params.append(val_aid)
        if not where:
            return jsonify({'success': False, 'error': 'Faltan OT/Cuenta'}), 400
        set_parts = []
        set_vals = []
        if external_id:
            set_parts.append(f"`{c_ext}`=%s")
            set_vals.append(external_id)
        if tecnico:
            set_parts.append(f"`{c_tec}`=%s")
            set_vals.append(tecnico)
        if estado:
            set_parts.append(f"`{c_estado}`=%s")
            set_vals.append(estado)
        if nombre:
            set_parts.append(f"`{c_nom}`=%s")
            set_vals.append(nombre)
        if tipo:
            set_parts.append(f"`{c_tipo}`=%s")
            set_vals.append(tipo)
        if direccion:
            set_parts.append(f"`{c_dir}`=%s")
            set_vals.append(direccion)
        if tiempos:
            set_parts.append(f"`{c_tiempos}`=%s")
            set_vals.append(tiempos)
        if duracion:
            set_parts.append(f"`{c_dur}`=%s")
            set_vals.append(duracion)
        if not set_parts:
            cur.close(); connection.close()
            return jsonify({'success': True, 'updated': False})
        sql = f"UPDATE `operaciones_actividades_diarias` SET {', '.join(set_parts)} WHERE " + " AND ".join(where)
        cur.execute(sql, tuple(set_vals + params))
        rc = getattr(cur, 'rowcount', 0)
        if rc == 0:
            cur.execute(
                "SELECT COUNT(*) FROM `operaciones_actividades_diarias` WHERE " + " AND ".join(where),
                tuple(params)
            )
            exists_count = (cur.fetchone() or [0])[0]
            if exists_count and int(exists_count) > 0:
                connection.commit()
                cur.close(); connection.close()
                return jsonify({'success': True, 'updated': True})
            ins_cols = []
            ins_vals = []
            if c_ot:
                ins_cols.append(f"`{c_ot}`"); ins_vals.append(ot)
            if c_cta:
                ins_cols.append(f"`{c_cta}`"); ins_vals.append(cuenta)
            if c_act and actividad_id:
                ins_cols.append(f"`{c_act}`"); ins_vals.append(params[-1] if where and actividad_id else actividad_id)
            if c_ext and external_id:
                ins_cols.append(f"`{c_ext}`"); ins_vals.append(external_id)
            if c_estado and estado:
                ins_cols.append(f"`{c_estado}`"); ins_vals.append(estado)
            if c_fecha:
                try:
                    now_bog = datetime.now(TIMEZONE)
                    ins_cols.append(f"`{c_fecha}`"); ins_vals.append(now_bog.strftime('%Y-%m-%d'))
                except Exception:
                    pass
            if c_tec and tecnico:
                ins_cols.append(f"`{c_tec}`"); ins_vals.append(tecnico)
            if c_nom and nombre:
                ins_cols.append(f"`{c_nom}`"); ins_vals.append(nombre)
            if c_tipo and tipo:
                ins_cols.append(f"`{c_tipo}`"); ins_vals.append(tipo)
            if c_dir and direccion:
                ins_cols.append(f"`{c_dir}`"); ins_vals.append(direccion)
            if c_tiempos and tiempos:
                ins_cols.append(f"`{c_tiempos}`"); ins_vals.append(tiempos)
            if c_dur and duracion:
                ins_cols.append(f"`{c_dur}`"); ins_vals.append(duracion)
            if ins_cols:
                sql_ins = f"INSERT INTO `operaciones_actividades_diarias` ({', '.join(ins_cols)}) VALUES ({', '.join(['%s']*len(ins_cols))})"
                cur.execute(sql_ins, tuple(ins_vals))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'updated': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
# Sugerir tecnología y categoría desde tipo de actividad
@app.route('/api/analistas/sugerir-tecnologia-categoria', methods=['GET'])
@login_required_analistas_or_lider_api()
def api_analistas_sugerir_tecnologia_categoria():
    tipo = (request.args.get('tipo') or '').strip()
    if not tipo:
        return jsonify({'success': False, 'error': 'tipo requerido'}), 400
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()

        # Obtener tecnologías disponibles
        cur.execute("""
            SELECT DISTINCT tecnologia 
            FROM base_codigos_facturacion 
            WHERE tecnologia IS NOT NULL AND tecnologia <> ''
        """)
        tecnologias_rows = cur.fetchall() or []
        tecnologias = [str(r[0]) for r in tecnologias_rows]

        # Normalizador
        import unicodedata, re
        def norm(s:str):
            s = unicodedata.normalize('NFKD', s)
            s = ''.join([c for c in s if not unicodedata.combining(c)])
            s = s.lower()
            s = re.sub(r"[^a-z0-9]+"," ", s).strip()
            return s
        tipo_n = norm(tipo)
        tokens = set(tipo_n.split())

        # Heurísticos
        heur_map = [
            (['ftth','gpon','fibra'], 'FTTH'),
            (['hfc','coax','docsis'], 'HFC'),
            (['adsl','xdsl','cobre'], 'XDSL'),
            (['fwa','radio'], 'FWA'),
        ]
        suger_tecnologia = None
        for keys, tech in heur_map:
            if any(k in tokens for k in keys):
                if tech in tecnologias:
                    suger_tecnologia = tech
                    break

        # Si no por heurística, tratar de encontrar por categorías con LIKE
        suger_categoria = None
        cur = connection.cursor(dictionary=True)
        # Buscar categorías que contengan parte del tipo
        like = f"%{tipo_n.split()[0]}%" if tipo_n else '%'
        cur.execute("""
            SELECT DISTINCT tecnologia, categoria 
            FROM base_codigos_facturacion
            WHERE categoria IS NOT NULL AND categoria <> ''
        """)
        best_score = 0
        best_pair = None
        for r in cur.fetchall() or []:
            cat = str(r.get('categoria') or '')
            cat_n = norm(cat)
            score = 0
            if cat_n and tipo_n:
                if cat_n in tipo_n or tipo_n in cat_n:
                    score = min(len(cat_n), len(tipo_n))
                else:
                    # intersección de palabras
                    score = len(set(cat_n.split()) & set(tipo_n.split()))
            if score > best_score:
                best_score = score
                best_pair = (str(r.get('tecnologia') or ''), str(r.get('categoria') or ''))

        if best_pair:
            tech_candidate, cat_candidate = best_pair
            if tech_candidate:
                suger_tecnologia = tech_candidate
            suger_categoria = cat_candidate

        # Si sigue sin tecnología y hay tokens que coinciden exactamente con tecnologías
        if not suger_tecnologia:
            for tech in tecnologias:
                if norm(tech) in tokens or any(norm(tech) in w for w in tokens):
                    suger_tecnologia = tech
                    break

        return jsonify({
            'success': True,
            'sugerencia': {
                'tecnologia': suger_tecnologia,
                'categoria': suger_categoria
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
# APIs para Inicio de Operación
@app.route('/api/lider/inicio-operacion/supervisores', methods=['GET'])
@login_required_lider_api()
def api_inicio_operacion_supervisores():
    """
    API para obtener lista de supervisores desde tabla asistencia
    """
    connection = None
    cursor = None
    try:
        # Conectar a la base de datos capired
        connection = mysql.connector.connect(
            host='localhost',
            port=3306,
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener supervisores únicos de ambas tablas (asistencia y recurso_operativo)
        # Limpiar datos para evitar duplicados por espacios o caracteres especiales
        cursor.execute("""
            SELECT DISTINCT TRIM(REPLACE(REPLACE(supervisor, '\n', ''), '\r', '')) as supervisor
            FROM (
                SELECT DISTINCT super as supervisor 
                FROM asistencia 
                WHERE super IS NOT NULL AND super != ''
                UNION
                SELECT DISTINCT super as supervisor 
                FROM recurso_operativo 
                WHERE super IS NOT NULL AND super != ''
            ) AS combined_supervisors
            WHERE TRIM(REPLACE(REPLACE(supervisor, '\n', ''), '\r', '')) != ''
            ORDER BY supervisor
        """)
        
        supervisores = cursor.fetchall()
        
        return jsonify({
            'success': True,
            'supervisores': [s['supervisor'] for s in supervisores]
        })
        
    except mysql.connector.Error as e:
        print(f"ERROR DB - Supervisores: {str(e)}")
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - Supervisores: {str(e)}")
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/inicio-operacion/analistas', methods=['GET'])
@login_required_lider_api()
def api_inicio_operacion_analistas():
    """
    API para obtener lista de analistas desde tabla recurso_operativo
    """
    connection = None
    cursor = None
    try:
        # Conectar a la base de datos capired
        connection = mysql.connector.connect(
            host='localhost',
            port=3306,
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener analistas únicos de la tabla recurso_operativo
        # Limpiar datos para evitar duplicados por espacios o caracteres especiales
        cursor.execute("""
            SELECT DISTINCT TRIM(REPLACE(REPLACE(analista, '\n', ''), '\r', '')) as analista
            FROM recurso_operativo 
            WHERE analista IS NOT NULL AND analista != ''
            AND TRIM(REPLACE(REPLACE(analista, '\n', ''), '\r', '')) != ''
            ORDER BY analista
        """)
        
        analistas = cursor.fetchall()
        
        return jsonify({
            'success': True,
            'analistas': [a['analista'] for a in analistas]
        })
        
    except mysql.connector.Error as e:
        print(f"ERROR DB - Analistas: {str(e)}")
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - Analistas: {str(e)}")
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/inicio-operacion/datos', methods=['GET'])
@login_required_lider_api()
def api_inicio_operacion_datos():
    """
    API para obtener datos del dashboard de inicio de operación
    """
    connection = None
    cursor = None
    try:
        # Obtener parámetros de filtro
        fecha = request.args.get('fecha')
        supervisores = request.args.getlist('supervisores[]')
        analistas = request.args.getlist('analistas[]')
        estado = request.args.get('estado')
        
        # Debug: Imprimir parámetros recibidos
        print(f"DEBUG - Parámetros recibidos:")
        print(f"  - fecha: {fecha}")
        print(f"  - supervisores: {supervisores}")
        print(f"  - analistas: {analistas}")
        
        # Conectar a la base de datos capired
        connection = mysql.connector.connect(
            host='localhost',
            port=3306,
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Construir condiciones WHERE
        where_conditions = []
        params = []
        
        if fecha:
            where_conditions.append("DATE(fecha_asistencia) = %s")
            params.append(fecha)
        
        if supervisores:
            placeholders = ','.join(['%s'] * len(supervisores))
            where_conditions.append(f"a.super IN ({placeholders})")
            params.extend(supervisores)
        
        if analistas:
            # Filtrar por analistas usando JOIN con recurso_operativo
            placeholders = ','.join(['%s'] * len(analistas))
            where_conditions.append(f"ro.analista IN ({placeholders})")
            params.extend(analistas)
        
        if estado:
            where_conditions.append("LOWER(TRIM(a.estado)) = %s")
            params.append((estado or '').strip().lower())
        
        where_clause = " AND ".join(where_conditions) if where_conditions else "1=1"
        
        # Definir nombres de tipificación para técnicos (según especificaciones exactas del usuario)
        tipificaciones_tecnicos = [
            'POSTVENTA',
            'POSTVENTA FTTH',
            'FTTH INSTALACIONES',
            'MANTENIMIENTO FTTH',
            'INSTALACIONES DOBLES',
            'ARREGLOS HFC',
            'BROWNFIELD',
            'INSTALACIONES DOBLES BACK'
        ]
        
        # Definir nombres de tipificación para auxiliares (CON ASISTENCIA)
        tipificaciones_auxiliares = [
            'AUXILIAR DE MOTO',
            'AUXILIAR CAMIONETA'
        ]
        
        # Mantener las carpetas originales para validación de asignación
        carpetas_tecnicos = [
            'POSTVENTA',
            'POSTVENTA FTTH',
            'FTTH INSTALACIONES',
            'MANTENIMIENTO FTTH',
            'INSTALACIONES DOBLES',
            'ARREGLOS HFC',
            'BROWNFIELD',
            'INSTALACIONES DOBLES BACK'
        ]
        
        carpetas_auxiliares = [
            'AUXILIAR'
        ]
        
        # Query principal para obtener datos de asistencia con JOIN a tipificacion_asistencia y recurso_operativo
        query = f"""
            SELECT 
                a.cedula,
                a.tecnico,
                a.carpeta,
                a.super,
                a.carpeta_dia,
                t.nombre_tipificacion,
                a.eventos,
                a.valor,
                a.estado,
                a.novedad,
                a.fecha_asistencia,
                a.hora_inicio,
                ro.analista
            FROM asistencia a
            LEFT JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN recurso_operativo ro ON a.cedula = ro.recurso_operativo_cedula
            WHERE {where_clause}
        """
        
        # Debug: Imprimir consulta y parámetros
        print(f"DEBUG - Consulta SQL:")
        print(f"  Query: {query}")
        print(f"  Params: {params}")
        print(f"  Where clause: {where_clause}")
        
        cursor.execute(query, params)
        asistencia_data = cursor.fetchall()
        
        # Debug: Imprimir cantidad de registros obtenidos
        print(f"DEBUG - Registros obtenidos: {len(asistencia_data)}")
        if len(asistencia_data) > 0:
            print(f"DEBUG - Primer registro: {asistencia_data[0]}")
        else:
            print("DEBUG - No se obtuvieron registros")
        
        # Convertir hora_inicio de timedelta a string para serialización JSON
        for registro in asistencia_data:
            if registro.get('hora_inicio') is not None:
                hora_inicio = registro['hora_inicio']
                if hasattr(hora_inicio, 'total_seconds'):  # Es un timedelta
                    # Convertir timedelta a horas y minutos
                    total_seconds = int(hora_inicio.total_seconds())
                    hours = total_seconds // 3600
                    minutes = (total_seconds % 3600) // 60
                    registro['hora_inicio'] = f"{hours:02d}:{minutes:02d}"
                elif isinstance(hora_inicio, str):
                    # Ya es string, mantenerlo como está
                    pass
                else:
                    # Otro tipo, convertir a string vacío
                    registro['hora_inicio'] = ""
            else:
                # Es None, convertir a string vacío
                registro['hora_inicio'] = ""
        
        # Inicializar contadores
        tecnicos_con_asistencia = 0
        tecnicos_sin_asistencia = 0
        apoyo_con_asistencia = 0
        apoyo_sin_asistencia = 0
        auxiliares_con_asistencia = 0
        auxiliares_sin_asistencia = 0
        
        oks_dia = 0
        presupuesto_dia = 0
        cumple = 0
        no_cumple = 0
        
        # Procesar cada registro
        for registro in asistencia_data:
            carpeta_dia = registro.get('carpeta_dia', '')
            nombre_tipificacion = registro.get('nombre_tipificacion', '')
            carpeta = registro.get('carpeta', '')
            eventos = registro.get('eventos', 0) or 0
            valor = registro.get('valor', 0) or 0
            estado = registro.get('estado', '').lower() if registro.get('estado') else ''
            
            # Contar OK's y presupuesto
            oks_dia += eventos
            presupuesto_dia += valor
            
            # Contar cumplimiento
            if estado in ['cumple', 'novedad']:
                cumple += 1
            elif estado in ['no cumple', 'no aplica']:
                no_cumple += 1
            
            # Lógica de asistencia CORREGIDA basada en nombre_tipificacion:
            # La asistencia se determina por el nombre_tipificacion obtenido del JOIN
            # La ausencia es cuando alguien asignado a un rol (carpeta) no tiene el nombre_tipificacion correspondiente
            
            # TÉCNICOS CON ASISTENCIA: carpeta en lista técnicos Y nombre_tipificacion en lista técnicos
            if carpeta and carpeta.strip() and carpeta in carpetas_tecnicos:
                if nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion in tipificaciones_tecnicos:
                    tecnicos_con_asistencia += 1
            
            # APOYO CAMIONETAS CON ASISTENCIA: carpeta = 'APOYO CAMIONETAS' Y nombre_tipificacion = 'APOYO CAMIONETAS'
            elif carpeta and carpeta.strip() and carpeta == 'APOYO CAMIONETAS':
                if nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion == 'APOYO CAMIONETAS':
                    apoyo_con_asistencia += 1
            
            # AUXILIARES CON ASISTENCIA: carpeta = 'AUXILIAR' Y nombre_tipificacion específico
            if carpeta and carpeta.strip() and carpeta == 'AUXILIAR':
                if nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion in tipificaciones_auxiliares:
                    auxiliares_con_asistencia += 1
            
            # SIN ASISTENCIA: Personas asignadas a roles pero sin nombre_tipificacion correspondiente
            if carpeta and carpeta.strip():
                if carpeta in carpetas_tecnicos:
                    # Si está asignado como técnico pero no tiene nombre_tipificacion de técnico
                    if not (nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion in tipificaciones_tecnicos):
                        tecnicos_sin_asistencia += 1
                elif carpeta == 'APOYO CAMIONETAS':
                    # Si está asignado como apoyo pero no tiene nombre_tipificacion de apoyo
                    if not (nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion == 'APOYO CAMIONETAS'):
                        apoyo_sin_asistencia += 1
                elif carpeta in carpetas_auxiliares:
                    # Si está asignado como auxiliar pero no tiene nombre_tipificacion de auxiliar
                    if not (nombre_tipificacion and nombre_tipificacion.strip() and nombre_tipificacion in tipificaciones_auxiliares):
                        auxiliares_sin_asistencia += 1
        
        # Calcular totales
        total_tecnicos = tecnicos_con_asistencia + tecnicos_sin_asistencia
        total_apoyo_camionetas = apoyo_con_asistencia + apoyo_sin_asistencia
        total_auxiliares = auxiliares_con_asistencia + auxiliares_sin_asistencia
        
        # Calcular porcentajes de cumplimiento diario
        total_evaluados = cumple + no_cumple
        cumplimiento_porcentaje = (cumple / total_evaluados * 100) if total_evaluados > 0 else 0
        
        # Presupuesto mes - obtener del primer día del mes con datos
        presupuesto_mes = 0
        if fecha:
            # Extraer año y mes de la fecha seleccionada
            from datetime import datetime
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%d')
            anio = fecha_obj.year
            mes = fecha_obj.month
            
            # Consulta para obtener el presupuesto del primer día del mes que tenga datos
            query_presupuesto_mes = f"""
                SELECT SUM(a.valor) as presupuesto_primer_dia
                FROM asistencia a
                LEFT JOIN recurso_operativo ro ON a.cedula = ro.recurso_operativo_cedula
                WHERE YEAR(a.fecha_asistencia) = %s 
                AND MONTH(a.fecha_asistencia) = %s
                AND a.valor IS NOT NULL
                AND a.valor > 0
                {' AND ro.analista IN (' + ','.join(['%s'] * len(analistas)) + ')' if analistas else ''}
                {' AND a.super IN (' + ','.join(['%s'] * len(supervisores)) + ')' if supervisores else ''}
                {' AND LOWER(TRIM(a.estado)) = %s' if estado else ''}
                AND DATE(a.fecha_asistencia) = (
                    SELECT MIN(DATE(a2.fecha_asistencia))
                    FROM asistencia a2
                    LEFT JOIN recurso_operativo ro2 ON a2.cedula = ro2.recurso_operativo_cedula
                    WHERE YEAR(a2.fecha_asistencia) = %s 
                    AND MONTH(a2.fecha_asistencia) = %s
                    AND a2.valor IS NOT NULL
                    AND a2.valor > 0
                    {' AND ro2.analista IN (' + ','.join(['%s'] * len(analistas)) + ')' if analistas else ''}
                    {' AND a2.super IN (' + ','.join(['%s'] * len(supervisores)) + ')' if supervisores else ''}
                    {' AND LOWER(TRIM(a2.estado)) = %s' if estado else ''}
                )
            """
            
            # Preparar parámetros para la consulta
            params_presupuesto = [anio, mes]
            if analistas:
                params_presupuesto.extend(analistas)
            if supervisores:
                params_presupuesto.extend(supervisores)
            if estado:
                params_presupuesto.append((estado or '').strip().lower())
            params_presupuesto.extend([anio, mes])  # Para la subconsulta
            if analistas:
                params_presupuesto.extend(analistas)
            if supervisores:
                params_presupuesto.extend(supervisores)
            if estado:
                params_presupuesto.append((estado or '').strip().lower())
            
            cursor.execute(query_presupuesto_mes, params_presupuesto)
            resultado_presupuesto = cursor.fetchone()
            
            if resultado_presupuesto and resultado_presupuesto['presupuesto_primer_dia']:
                presupuesto_mes = float(resultado_presupuesto['presupuesto_primer_dia']) * 26
            else:
                # Si no hay datos del mes, usar el presupuesto del día actual * 26
                presupuesto_mes = presupuesto_dia * 26
        else:
            # Si no hay fecha específica, usar el presupuesto del día actual * 26
            presupuesto_mes = presupuesto_dia * 26
        
        # Calcular cumplimiento mensual acumulado
        cumplimiento_mes_porcentaje = 0
        cumple_mes = 0
        novedad_mes = 0
        no_cumple_mes = 0
        no_aplica_mes = 0
        
        if fecha:
            # Extraer año y mes de la fecha seleccionada
            from datetime import datetime
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%d')
            anio = fecha_obj.year
            mes = fecha_obj.month
            
            # Consulta para obtener datos acumulados del mes completo
            query_mes = f"""
                SELECT 
                    a.estado
                FROM asistencia a
                LEFT JOIN recurso_operativo ro ON a.cedula = ro.recurso_operativo_cedula
                WHERE YEAR(a.fecha_asistencia) = %s 
                AND MONTH(a.fecha_asistencia) = %s
                AND a.estado IS NOT NULL 
                AND a.estado != ''
            """
            
            params_mes = [anio, mes]
            
            # Aplicar filtros de supervisores si existen
            if supervisores:
                placeholders = ','.join(['%s'] * len(supervisores))
                query_mes += f" AND a.super IN ({placeholders})"
                params_mes.extend(supervisores)
            
            # Aplicar filtros de analistas si existen
            if analistas:
                placeholders = ','.join(['%s'] * len(analistas))
                query_mes += f" AND ro.analista IN ({placeholders})"
                params_mes.extend(analistas)
            
            if estado:
                query_mes += " AND LOWER(TRIM(a.estado)) = %s"
                params_mes.append((estado or '').strip().lower())
            
            cursor.execute(query_mes, params_mes)
            registros_mes = cursor.fetchall()
            
            # Contar estados del mes completo
            for registro in registros_mes:
                estado = registro.get('estado', '').lower() if registro.get('estado') else ''
                if estado == 'cumple':
                    cumple_mes += 1
                elif estado == 'novedad':
                    novedad_mes += 1
                elif estado == 'no cumple':
                    no_cumple_mes += 1
                elif estado == 'no aplica':
                    no_aplica_mes += 1
            
            # Calcular cumplimiento mensual con la nueva fórmula
            # (Cumple_mes + Novedad_mes) / (Cumple_mes + Novedad_mes + No_Cumple_mes + No_Aplica_mes) × 100
            total_mes = cumple_mes + novedad_mes + no_cumple_mes + no_aplica_mes
            if total_mes > 0:
                cumplimiento_mes_porcentaje = ((cumple_mes + novedad_mes) / total_mes) * 100
            
            print(f"DEBUG - Cumplimiento mensual para {mes}/{anio}:")
            print(f"  - Cumple: {cumple_mes}")
            print(f"  - Novedad: {novedad_mes}")
            print(f"  - No Cumple: {no_cumple_mes}")
            print(f"  - No Aplica: {no_aplica_mes}")
            print(f"  - Total evaluados: {total_mes}")
            print(f"  - Porcentaje mensual: {cumplimiento_mes_porcentaje:.1f}%")
        
        # Log para depuración
        print(f"DEBUG - Inicio Operación: Registros procesados: {len(asistencia_data)}")
        print(f"DEBUG - Técnicos: Total={total_tecnicos} (Con asistencia={tecnicos_con_asistencia}, Sin asistencia={tecnicos_sin_asistencia})")
        print(f"DEBUG - Apoyo: Total={total_apoyo_camionetas} (Con asistencia={apoyo_con_asistencia}, Sin asistencia={apoyo_sin_asistencia})")
        print(f"DEBUG - Auxiliares: Total={total_auxiliares} (Con asistencia={auxiliares_con_asistencia}, Sin asistencia={auxiliares_sin_asistencia})")
        print(f"DEBUG - Métricas: OKs={oks_dia}, Presupuesto día=${presupuesto_dia:,}, Presupuesto mes=${presupuesto_mes:,}")
        print(f"DEBUG - Cumplimiento: {cumple} cumple, {no_cumple} no cumple ({cumplimiento_porcentaje:.1f}%)")
        print(f"DEBUG - Lógica asistencia FINAL basada en nombre_tipificacion:")
        print(f"  - TÉCNICOS con asistencia: nombre_tipificacion en {tipificaciones_tecnicos}")
        print(f"  - TÉCNICOS sin asistencia: carpeta en técnicos PERO nombre_tipificacion NO en técnicos")
        print(f"  - APOYO con asistencia: nombre_tipificacion = 'APOYO CAMIONETAS'")
        print(f"  - APOYO sin asistencia: carpeta = 'APOYO CAMIONETAS' PERO nombre_tipificacion ≠ 'APOYO CAMIONETAS'")
        print(f"  - AUXILIARES con asistencia: nombre_tipificacion en {tipificaciones_auxiliares}")
        print(f"  - AUXILIARES sin asistencia: carpeta en auxiliares PERO nombre_tipificacion NO en auxiliares")
        print(f"DEBUG - JOIN con tipificacion_asistencia: carpeta_dia -> codigo_tipificacion -> nombre_tipificacion")

        cierre_ciclo_meta = 260
        cierre_ciclo_gestionado_mes = 0
        cierre_ciclo_porcentaje_mes = 0.0
        cierre_ciclo_detalle = []
        cierre_ciclo_ots_mes = 0
        cierre_ciclo_calidad_mes = 0
        cierre_ciclo_calidad_porcentaje = 0.0
        try:
            c2 = connection.cursor()
            c2.execute(
                """
                SELECT COLUMN_NAME FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                """,
                ('capired',)
            )
            cols = {r[0].lower(): r[0] for r in (c2.fetchall() or [])}
            def pick(options):
                for opt in options:
                    if opt.lower() in cols:
                        return cols[opt.lower()]
                return None
            col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
            col_estado = pick(['estado'])
            col_cierre = pick(['cierre_ciclo'])
            col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
            col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
            where_parts = []
            params_cc = []
            if col_estado:
                where_parts.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
            if col_cierre:
                where_parts.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
            from datetime import datetime
            base_dt = None
            if fecha:
                try:
                    base_dt = datetime.strptime(fecha, '%Y-%m-%d')
                except Exception:
                    base_dt = datetime.now()
            else:
                base_dt = datetime.now()
            if col_fecha:
                c2.execute(
                    """
                    SELECT DATA_TYPE FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                    """,
                    ('capired', col_fecha)
                )
                row_t = c2.fetchone()
                tipo_fecha = str(row_t[0]).lower() if row_t and row_t[0] else None
                if tipo_fecha in ('datetime','timestamp','date'):
                    where_parts.append(f"YEAR(o.`{col_fecha}`) = %s AND MONTH(o.`{col_fecha}`) = %s")
                    params_cc.extend([base_dt.year, base_dt.month])
                else:
                    pref = base_dt.strftime('%Y-%m-')
                    where_parts.append(f"o.`{col_fecha}` LIKE %s")
                    params_cc.append(pref + '%')

            # Filtrar por analistas si se proporciona y existe columna de ID externo
            cedulas_all = []
            cedulas_por_analista = {}
            if analistas and col_ext:
                c2.execute(
                    """
                    SELECT COLLATION_NAME FROM information_schema.columns
                    WHERE table_schema=%s AND table_name='recurso_operativo' AND column_name='analista'
                    """,
                    ('capired',)
                )
                coll_row = c2.fetchone()
                coll = coll_row[0] if coll_row and coll_row[0] else 'utf8mb4_0900_ai_ci'
                for a in analistas:
                    c2.execute(
                        f"""
                        SELECT recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE LOWER(TRIM(analista)) COLLATE {coll} = LOWER(TRIM(CAST(%s AS CHAR CHARACTER SET utf8mb4))) COLLATE {coll}
                        """,
                        (a,)
                    )
                    rows_ced = c2.fetchall() or []
                    ceds = [r[0] for r in rows_ced]
                    cedulas_por_analista[a] = ceds
                    cedulas_all.extend(ceds)
                if cedulas_all:
                    placeholders = ','.join(['%s'] * len(cedulas_all))
                    where_parts.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
                    params_cc.extend([str(x) for x in cedulas_all])

            sql_cc = "SELECT COUNT(*) FROM operaciones_actividades_diarias o"
            if where_parts:
                sql_cc += " WHERE " + " AND ".join(where_parts)
            c2.execute(sql_cc, tuple(params_cc))
            row_cnt = c2.fetchone()
            cierre_ciclo_gestionado_mes = int(row_cnt[0]) if row_cnt and row_cnt[0] is not None else 0
            cierre_ciclo_porcentaje_mes = round((cierre_ciclo_gestionado_mes / cierre_ciclo_meta * 100), 1) if cierre_ciclo_meta > 0 else 0.0

            if col_ot:
                sql_ots = "SELECT COUNT(DISTINCT CAST(o.`" + col_ot + "` AS CHAR)) FROM operaciones_actividades_diarias o"
                if where_parts:
                    sql_ots += " WHERE " + " AND ".join(where_parts)
                c2.execute(sql_ots, tuple(params_cc))
                r_ots = c2.fetchone()
                cierre_ciclo_ots_mes = int(r_ots[0]) if r_ots and r_ots[0] is not None else 0

                sql_cal = (
                    "SELECT COUNT(DISTINCT CAST(o.`" + col_ot + "` AS CHAR)) "
                    "FROM operaciones_actividades_diarias o "
                    "WHERE " + (" AND ".join(where_parts) if where_parts else "1=1") +
                    " AND EXISTS (SELECT 1 FROM operaciones_calidad oc "
                    "WHERE oc.ot = CAST(o.`" + col_ot + "` AS CHAR) AND oc.periodo_year = %s AND oc.periodo_month = %s)"
                )
                c2.execute(sql_cal, tuple(params_cc) + (base_dt.year, base_dt.month))
                r_cal = c2.fetchone()
                cierre_ciclo_calidad_mes = int(r_cal[0]) if r_cal and r_cal[0] is not None else 0
                cierre_ciclo_calidad_porcentaje = round((100.0 - (cierre_ciclo_calidad_mes / cierre_ciclo_ots_mes * 100.0)), 1) if cierre_ciclo_ots_mes > 0 else 0.0

            # Detalle por analista (solo si se filtró por analistas y existe columna de ID externo)
            if analistas and col_ext:
                for a in analistas:
                    ceds = cedulas_por_analista.get(a) or []
                    if not ceds:
                        cierre_ciclo_detalle.append({
                            'analista': a,
                            'gestionado_mes': 0,
                            'porcentaje_mensual': 0.0
                        })
                        continue
                    placeholders = ','.join(['%s'] * len(ceds))
                    sql_det = "SELECT COUNT(*) FROM operaciones_actividades_diarias o"
                    det_where = list(where_parts)
                    det_params = list(params_cc)
                    det_where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
                    det_params.extend([str(x) for x in ceds])
                    sql_det += " WHERE " + " AND ".join(det_where)
                    c2.execute(sql_det, tuple(det_params))
                    rdet = c2.fetchone()
                    cnt = int(rdet[0]) if rdet and rdet[0] is not None else 0
                    cierre_ciclo_detalle.append({
                        'analista': a,
                        'gestionado_mes': cnt,
                        'porcentaje_mensual': round((cnt / cierre_ciclo_meta * 100), 1) if cierre_ciclo_meta > 0 else 0.0
                    })

            c2.close()
        except Exception:
            try:
                c2.close()
            except Exception:
                pass

        return jsonify({
            'success': True,
            'data': {
                'tecnicos': {
                    'total': total_tecnicos,
                    'con_asistencia': tecnicos_con_asistencia,
                    'sin_asistencia': tecnicos_sin_asistencia
                },
                'apoyo_camionetas': {
                    'total': total_apoyo_camionetas,
                    'con_asistencia': apoyo_con_asistencia,
                    'sin_asistencia': apoyo_sin_asistencia
                },
                'auxiliares': {
                    'total': total_auxiliares,
                    'con_asistencia': auxiliares_con_asistencia,
                    'sin_asistencia': auxiliares_sin_asistencia
                },
                'metricas': {
                    'oks_dia': oks_dia,
                    'presupuesto_dia': presupuesto_dia,
                    'presupuesto_mes': presupuesto_mes
                },
                'cumplimiento': {
                    'cumple': cumple,
                    'no_cumple': no_cumple,
                    'cumplimiento_dia': round(cumplimiento_porcentaje, 1),
                    'cumplimiento_mes': round(cumplimiento_mes_porcentaje, 1),
                    'cumple_mes': cumple_mes,
                    'novedad_mes': novedad_mes,
                    'no_cumple_mes': no_cumple_mes,
                    'no_aplica_mes': no_aplica_mes,
                    'total_mes': cumple_mes + novedad_mes + no_cumple_mes + no_aplica_mes
                },
                'cierre_ciclo': {
                    'meta_mensual': cierre_ciclo_meta,
                    'gestionado_mes': cierre_ciclo_gestionado_mes,
                    'porcentaje_mensual': cierre_ciclo_porcentaje_mes,
                    'detalle': cierre_ciclo_detalle
                },
                'cierre_ciclo_calidad': {
                    'ots_mes': cierre_ciclo_ots_mes,
                    'con_calidad_mes': cierre_ciclo_calidad_mes,
                    'porcentaje_mensual': cierre_ciclo_calidad_porcentaje
                },
                'tabla_asistencia': asistencia_data,
                'debug_info': {
                    'total_registros': len(asistencia_data),
                    'filtros_aplicados': {
                        'fecha': fecha,
                        'supervisores': supervisores,
                        'analistas': analistas
                    }
                }
            }
        })
        
    except mysql.connector.Error as e:
        print(f"ERROR DB - Inicio Operación Datos: {str(e)}")
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - Inicio Operación Datos: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/inicio-operacion/indicador-diario', methods=['GET'])
@login_required_lider_api()
def api_inicio_operacion_indicador_diario():
    """
    API para indicador diario: tabla por supervisor (cumple, no cumple, % día)
    y gráfica de % mensual por supervisor.
    """
    connection = None
    cursor = None
    try:
        # Parámetros
        fecha = request.args.get('fecha')
        supervisores = request.args.getlist('supervisores[]')
        analistas = request.args.getlist('analistas[]')
        estado = request.args.get('estado')

        # Conectar DB
        connection = mysql.connector.connect(
            host='localhost',
            port=3306,
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        cursor = connection.cursor(dictionary=True)

        # Si no viene fecha, usar hoy
        if not fecha:
            from datetime import datetime
            fecha = datetime.now().strftime('%Y-%m-%d')

        # Diario por supervisor
        query_diario = """
            SELECT 
                a.super AS supervisor,
                SUM(CASE WHEN LOWER(TRIM(a.estado)) IN ('cumple','novedad') THEN 1 ELSE 0 END) AS cumple,
                SUM(CASE WHEN LOWER(TRIM(a.estado)) IN ('no cumple','no aplica') THEN 1 ELSE 0 END) AS no_cumple,
                COUNT(*) AS total_evaluados
            FROM asistencia a
            LEFT JOIN recurso_operativo ro ON a.cedula = ro.recurso_operativo_cedula
            WHERE DATE(a.fecha_asistencia) = %s
        """
        params_diario = [fecha]
        if supervisores:
            query_diario += f" AND a.super IN ({','.join(['%s']*len(supervisores))})"
            params_diario.extend(supervisores)
        if analistas:
            query_diario += f" AND ro.analista IN ({','.join(['%s']*len(analistas))})"
            params_diario.extend(analistas)
        if estado:
            query_diario += " AND LOWER(TRIM(a.estado)) = %s"
            params_diario.append((estado or '').strip().lower())
        query_diario += " GROUP BY a.super ORDER BY a.super"

        cursor.execute(query_diario, params_diario)
        diario_rows = cursor.fetchall() or []
        diario = []
        for r in diario_rows:
            cumple = int(r.get('cumple') or 0)
            no_cumple = int(r.get('no_cumple') or 0)
            total = int(r.get('total_evaluados') or 0)
            denominador = cumple + no_cumple  # cumple+novedad + no cumple+no aplica
            porcentaje = (cumple / denominador * 100) if denominador > 0 else 0
            diario.append({
                'supervisor': r.get('supervisor') or '',
                'cumple': cumple,
                'no_cumple': no_cumple,
                'total_evaluados': total,
                'porcentaje': porcentaje
            })

        # Mensual por supervisor
        from datetime import datetime
        dt = datetime.strptime(fecha, '%Y-%m-%d')
        anio, mes = dt.year, dt.month
        query_mensual = """
            SELECT 
                a.super AS supervisor,
                SUM(CASE WHEN LOWER(TRIM(a.estado)) IN ('cumple','novedad') THEN 1 ELSE 0 END) AS cumple,
                SUM(CASE WHEN LOWER(TRIM(a.estado)) IN ('no cumple','no aplica') THEN 1 ELSE 0 END) AS no_cumple
            FROM asistencia a
            LEFT JOIN recurso_operativo ro ON a.cedula = ro.recurso_operativo_cedula
            WHERE YEAR(a.fecha_asistencia) = %s AND MONTH(a.fecha_asistencia) = %s
        """
        params_mensual = [anio, mes]
        if supervisores:
            query_mensual += f" AND a.super IN ({','.join(['%s']*len(supervisores))})"
            params_mensual.extend(supervisores)
        if analistas:
            query_mensual += f" AND ro.analista IN ({','.join(['%s']*len(analistas))})"
            params_mensual.extend(analistas)
        if estado:
            query_mensual += " AND LOWER(TRIM(a.estado)) = %s"
            params_mensual.append((estado or '').strip().lower())
        query_mensual += " GROUP BY a.super ORDER BY a.super"

        cursor.execute(query_mensual, params_mensual)
        mensual_rows = cursor.fetchall() or []
        mensual = []
        for r in mensual_rows:
            cumple = int(r.get('cumple') or 0)
            no_cumple = int(r.get('no_cumple') or 0)
            denominador = cumple + no_cumple
            porcentaje = (cumple / denominador * 100) if denominador > 0 else 0
            mensual.append({
                'supervisor': r.get('supervisor') or '',
                'porcentaje': porcentaje
            })

        return jsonify({
            'success': True,
            'fecha': fecha,
            'diario': diario,
            'mensual': mensual
        })

    except mysql.connector.Error as e:
        print(f"ERROR DB - Indicador Diario: {str(e)}")
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - Indicador Diario: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/analistas', methods=['GET'])
@login_required_lider_api()
def api_get_analistas():
    """
    API para obtener lista de analistas activos
    """
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener analistas activos
        cursor.execute("""
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                nombre,
                cargo,
                estado
            FROM recurso_operativo 
            WHERE (cargo = 'ANALISTA' OR cargo = 'ANALISTA LOGISTICA') 
            AND estado = 'Activo'
            ORDER BY nombre
        """)
        
        analistas = cursor.fetchall()
        
        return jsonify({
            'success': True,
            'analistas': analistas
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/turnos', methods=['GET'])
@login_required_lider_api()
def api_get_turnos():
    """
    API para obtener lista de turnos disponibles
    """
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener turnos disponibles
        cursor.execute("""
            SELECT 
                turnos_horario,
                turnos_nombre,
                turnos_horas_laboradas,
                turnos_breack,
                turnos_almuerzo
            FROM turnos
            ORDER BY turnos_horario
        """)
        
        turnos_data = []
        for row in cursor.fetchall():
            turnos_data.append({
                'horario': row['turnos_horario'],
                'nombre': row['turnos_nombre'],
                'horas_laboradas': row['turnos_horas_laboradas'],
                'break': row['turnos_breack'],
                'almuerzo': row['turnos_almuerzo']
            })
        
        return jsonify({
            'success': True,
            'turnos': turnos_data
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/asignar-turno', methods=['POST'])
@login_required_lider_api()
def api_asignar_turno():
    """
    API para asignar turno a un analista
    """
    connection = None
    cursor = None
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No se recibieron datos'}), 400
            
        # Validar campos requeridos
        required_fields = ['analista', 'fecha', 'turno']
        for field in required_fields:
            if field not in data or not data[field]:
                return jsonify({'error': f'Campo requerido: {field}'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar si ya existe una asignación para esa fecha y analista
        cursor.execute("""
            SELECT id_analistas_turnos FROM analistas_turnos_base 
            WHERE analistas_turnos_fecha = %s AND analistas_turnos_analista = %s
        """, (data['fecha'], data['analista']))
        
        existing = cursor.fetchone()
        
        if existing:
            # Actualizar asignación existente
            cursor.execute("""
                UPDATE analistas_turnos_base 
                SET analistas_turnos_turno = %s,
                    analistas_turnos_almuerzo = %s,
                    analistas_turnos_break = %s,
                    analistas_turnos_horas_trabajadas = %s
                WHERE id_analistas_turnos = %s
            """, (
                data['turno'],
                data.get('almuerzo'),
                data.get('break'),
                data.get('horas_trabajadas'),
                existing['id_analistas_turnos']
            ))
        else:
            # Crear nueva asignación
            cursor.execute("""
                INSERT INTO analistas_turnos_base (
                    analistas_turnos_fecha,
                    analistas_turnos_analista,
                    analistas_turnos_turno,
                    analistas_turnos_almuerzo,
                    analistas_turnos_break,
                    analistas_turnos_horas_trabajadas
                ) VALUES (%s, %s, %s, %s, %s, %s)
            """, (
                data['fecha'],
                data['analista'],
                data['turno'],
                data.get('almuerzo'),
                data.get('break'),
                data.get('horas_trabajadas')
            ))
        
        connection.commit()
        
        return jsonify({
            'success': True,
            'message': 'Turno asignado correctamente'
        })
        
    except mysql.connector.Error as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/asignar-turnos-semana', methods=['POST'])
@login_required_lider_api()
def api_asignar_turnos_semana():
    """
    API para asignar turnos de una semana completa a un analista
    """
    connection = None
    cursor = None
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No se recibieron datos'}), 400
            
        # Validar campos requeridos
        required_fields = ['analista_id', 'turnos']
        for field in required_fields:
            if field not in data or not data[field]:
                return jsonify({'error': f'Campo requerido: {field}'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información de los turnos disponibles
        cursor.execute("SELECT turnos_horario, turnos_nombre, turnos_horas_laboradas, turnos_breack, turnos_almuerzo FROM turnos")
        turnos_info = {}
        for turno in cursor.fetchall():
            turnos_info[turno['turnos_horario']] = {
                'nombre': turno['turnos_nombre'],
                'horas_laboradas': turno['turnos_horas_laboradas'],
                'break': turno['turnos_breack'],
                'almuerzo': turno['turnos_almuerzo']
            }
        
        turnos_asignados = 0
        turnos_actualizados = 0
        errores = []
        
        # Procesar cada día y sus turnos
        for fecha, turnos_dia in data['turnos'].items():
            if not turnos_dia or not isinstance(turnos_dia, list) or len(turnos_dia) == 0:
                continue
                
            # Para cada día, asignar todos los turnos seleccionados
            # Como solo puede haber un turno por día, tomamos el primero
            turno_id = turnos_dia[0]
            
            if not turno_id or turno_id not in turnos_info:
                errores.append(f"Turno inválido para la fecha {fecha}")
                continue
            
            turno_info = turnos_info[turno_id]
            
            # Verificar si ya existe una asignación para esa fecha y analista
            cursor.execute("""
                SELECT id_analistas_turnos FROM analistas_turnos_base 
                WHERE analistas_turnos_fecha = %s AND analistas_turnos_analista = %s
            """, (fecha, data['analista_id']))
            
            existing = cursor.fetchone()
            
            try:
                if existing:
                    # Actualizar asignación existente
                    cursor.execute("""
                        UPDATE analistas_turnos_base 
                        SET analistas_turnos_turno = %s,
                            analistas_turnos_almuerzo = %s,
                            analistas_turnos_break = %s,
                            analistas_turnos_horas_trabajadas = %s
                        WHERE id_analistas_turnos = %s
                    """, (
                        turno_id,
                        turno_info['almuerzo'],
                        turno_info['break'],
                        turno_info['horas_laboradas'],
                        existing['id_analistas_turnos']
                    ))
                    turnos_actualizados += 1
                else:
                    # Crear nueva asignación
                    cursor.execute("""
                        INSERT INTO analistas_turnos_base (
                            analistas_turnos_fecha,
                            analistas_turnos_analista,
                            analistas_turnos_turno,
                            analistas_turnos_almuerzo,
                            analistas_turnos_break,
                            analistas_turnos_horas_trabajadas
                        ) VALUES (%s, %s, %s, %s, %s, %s)
                    """, (
                        fecha,
                        data['analista_id'],
                        turno_id,
                        turno_info['almuerzo'],
                        turno_info['break'],
                        turno_info['horas_laboradas']
                    ))
                    turnos_asignados += 1
            except Exception as e:
                errores.append(f"Error al procesar fecha {fecha}: {str(e)}")
        
        connection.commit()
        
        mensaje = ''
        if turnos_asignados > 0:
            mensaje += f"{turnos_asignados} turno(s) asignado(s). "
        if turnos_actualizados > 0:
            mensaje += f"{turnos_actualizados} turno(s) actualizado(s). "
        if errores:
            mensaje += f"Errores: {', '.join(errores)}"
        
        return jsonify({
            'success': True,
            'message': mensaje or 'Operación completada exitosamente',
            'asignados': turnos_asignados,
            'actualizados': turnos_actualizados,
            'errores': errores
        })
        
    except mysql.connector.Error as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        if connection:
            connection.rollback()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/turnos-semana', methods=['GET'])
@login_required_lider_api()
def api_get_turnos_semana():
    """
    API para obtener turnos de una semana específica
    """
    connection = None
    cursor = None
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        if not fecha_inicio or not fecha_fin:
            return jsonify({'error': 'Se requieren fecha_inicio y fecha_fin'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener asignaciones de la semana con nombre de analista
        cursor.execute("""
            SELECT 
                atb.analistas_turnos_fecha,
                COALESCE(ro.nombre, atb.analistas_turnos_analista) as analistas_turnos_analista,
                atb.analistas_turnos_turno,
                atb.analistas_turnos_almuerzo,
                atb.analistas_turnos_break,
                atb.analistas_turnos_horas_trabajadas
            FROM analistas_turnos_base atb
            LEFT JOIN recurso_operativo ro ON atb.analistas_turnos_analista = ro.id_codigo_consumidor
            WHERE atb.analistas_turnos_fecha BETWEEN %s AND %s
            ORDER BY atb.analistas_turnos_fecha, ro.nombre
        """, (fecha_inicio, fecha_fin))
        
        turnos_semana = cursor.fetchall()
        
        # Convertir fechas a strings para asegurar compatibilidad con el frontend
        for turno in turnos_semana:
            if 'analistas_turnos_fecha' in turno and turno['analistas_turnos_fecha']:
                turno['analistas_turnos_fecha'] = turno['analistas_turnos_fecha'].strftime('%Y-%m-%d')
        
        return jsonify({
            'success': True,
            'turnos': turnos_semana
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/resumen-semanal', methods=['GET'])
@login_required_lider_api()
def api_get_resumen_semanal():
    """
    API para obtener resumen semanal de horas trabajadas por analista
    """
    connection = None
    cursor = None
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        if not fecha_inicio or not fecha_fin:
            return jsonify({'error': 'Se requieren fecha_inicio y fecha_fin'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Consulta para obtener resumen semanal con datos reales de la tabla
        # Solo cuenta horas de almuerzo en días que realmente trabajaron (horas > 0)
        cursor.execute("""
            SELECT 
                ro.nombre as nombre_analista,
                SUM(atb.analistas_turnos_horas_trabajadas) as horas_semanales,
                COUNT(DISTINCT CASE WHEN atb.analistas_turnos_horas_trabajadas > 0 THEN atb.analistas_turnos_fecha END) as dias_trabajados,
                COUNT(DISTINCT CASE WHEN atb.analistas_turnos_horas_trabajadas > 0 THEN atb.analistas_turnos_fecha END) as horas_almuerzo_total,
                (SUM(atb.analistas_turnos_horas_trabajadas) - COUNT(DISTINCT CASE WHEN atb.analistas_turnos_horas_trabajadas > 0 THEN atb.analistas_turnos_fecha END)) as total_horas_netas
            FROM analistas_turnos_base atb
            INNER JOIN recurso_operativo ro ON atb.analistas_turnos_analista = ro.id_codigo_consumidor
            WHERE atb.analistas_turnos_fecha BETWEEN %s AND %s
            GROUP BY atb.analistas_turnos_analista, ro.nombre
            ORDER BY ro.nombre
        """, (fecha_inicio, fecha_fin))
        
        resumen_semanal = cursor.fetchall()
        
        # Asegurar que los valores numéricos sean correctos
        for analista in resumen_semanal:
            analista['horas_semanales'] = float(analista['horas_semanales']) if analista['horas_semanales'] else 0
            analista['dias_trabajados'] = int(analista['dias_trabajados']) if analista['dias_trabajados'] else 0
            analista['horas_almuerzo_total'] = int(analista['horas_almuerzo_total']) if analista['horas_almuerzo_total'] else 0
            analista['total_horas_netas'] = float(analista['total_horas_netas']) if analista['total_horas_netas'] else 0
            
            # Asegurar que el total no sea negativo
            if analista['total_horas_netas'] < 0:
                analista['total_horas_netas'] = 0
        
        return jsonify({
            'success': True,
            'resumen': resumen_semanal
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/detalles-dia', methods=['GET'])
@login_required_lider_api()
def api_get_detalles_dia():
    """
    API para obtener detalles de turnos de un día específico
    """
    connection = None
    cursor = None
    try:
        fecha = request.args.get('fecha')
        
        if not fecha:
            return jsonify({'error': 'Se requiere el parámetro fecha'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener detalles del día con información completa del turno y nombre de la analista
        cursor.execute("""
            SELECT 
                atb.analistas_turnos_analista,
                ro.nombre as nombre_analista,
                atb.analistas_turnos_turno,
                atb.analistas_turnos_almuerzo,
                atb.analistas_turnos_break,
                atb.analistas_turnos_horas_trabajadas,
                t.turnos_nombre,
                t.turnos_horas_laboradas
            FROM analistas_turnos_base atb
            INNER JOIN recurso_operativo ro ON atb.analistas_turnos_analista = ro.id_codigo_consumidor
            LEFT JOIN turnos t ON atb.analistas_turnos_turno = t.turnos_horario
            WHERE atb.analistas_turnos_fecha = %s
            ORDER BY ro.nombre
        """, (fecha,))
        
        detalles = cursor.fetchall()
        
        return jsonify({
            'success': True,
            'detalles': detalles,
            'fecha': fecha
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/operativo/asistencia')
@login_required(role='operativo')
def operativo_asistencia():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('operativo_dashboard'))
            
        cursor = connection.cursor(dictionary=True)
        
        # Crear tablas si no existen
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS tipificacion_asistencia (
                id_tipificacion INT AUTO_INCREMENT PRIMARY KEY,
                codigo_tipificacion VARCHAR(50) NOT NULL,
                nombre_tipificacion VARCHAR(200),
                estado CHAR(1) DEFAULT '1',
                fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS asistencia (
                id_asistencia INT AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(20),
                tecnico VARCHAR(100),
                carpeta_dia VARCHAR(50),
                carpeta VARCHAR(50),
                super VARCHAR(100),
                fecha_asistencia TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                id_codigo_consumidor INT
            )
        """)
        connection.commit()
        
        # Obtener el nombre del usuario logueado para usar como filtro de supervisor
        cursor.execute("""
            SELECT nombre FROM capired.recurso_operativo
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        
        supervisor_result = cursor.fetchone()
        if not supervisor_result or not supervisor_result['nombre']:
            flash('No se encontró información del usuario logueado', 'warning')
            return redirect(url_for('operativo_dashboard'))
            
        supervisor_usuario = supervisor_result['nombre']
        
        # Verificar si ya existe un registro de asistencia para hoy
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        cursor.execute("""
            SELECT COUNT(*) as registros_hoy
            FROM asistencia 
            WHERE super = %s AND DATE(fecha_asistencia) = %s
        """, (supervisor_usuario, fecha_hoy))
        
        registro_existente = cursor.fetchone()
        ya_registrado = registro_existente['registros_hoy'] > 0 if registro_existente else False
        
        # DEBUG: Mostrar todos los valores distintos de carpeta para debug
        cursor.execute("""
            SELECT DISTINCT carpeta, COUNT(*) as cantidad
            FROM capired.recurso_operativo
            WHERE estado = 'Activo'
            GROUP BY carpeta
            ORDER BY carpeta
        """)
        debug_carpetas = cursor.fetchall()
        print("\n=== DEBUG: Valores distintos en columna 'carpeta' ===")
        for carpeta in debug_carpetas:
            print(f"Carpeta: '{carpeta['carpeta']}' - Cantidad: {carpeta['cantidad']}")
        
        # Obtener técnicos del supervisor automáticamente
        # Obtener la cédula del usuario actual para excluirlo de la lista
        cursor.execute("""
            SELECT recurso_operativo_cedula 
            FROM capired.recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (session['id_codigo_consumidor'],))
        usuario_actual = cursor.fetchone()
        
        # Filtrar técnicos por supervisor usando la lógica estándar
        cursor.execute("""
            SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre, carpeta
            FROM capired.recurso_operativo
            WHERE super = %s AND estado = 'Activo'
            AND recurso_operativo_cedula != %s
            ORDER BY nombre
        """, (supervisor_usuario, usuario_actual['recurso_operativo_cedula'] if usuario_actual else ''))
        tecnicos = cursor.fetchall()
        print(f"Técnicos encontrados para supervisor {supervisor_usuario} (excluyendo supervisor): {len(tecnicos)}")
        
        # Obtener lista de tipificaciones para carpeta_dia (solo zona OP para operativo)
        cursor.execute("""
            SELECT codigo_tipificacion, nombre_tipificacion
            FROM tipificacion_asistencia
            WHERE estado = '1' AND zona = 'OP'
            ORDER BY codigo_tipificacion
        """)
        carpetas_dia = cursor.fetchall()
        cursor.execute(
            """
            SELECT a.id_codigo_consumidor, a.carpeta_dia, t.nombre_tipificacion
            FROM asistencia a
            JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE a.super = %s AND DATE(a.fecha_asistencia) = %s AND a.carpeta = 'RRHH'
            """,
            (supervisor_usuario, fecha_hoy)
        )
        rrhh_rows = cursor.fetchall()
        novedades_rrhh = {}
        for r in rrhh_rows:
            novedades_rrhh[r['id_codigo_consumidor']] = {
                'codigo': r['carpeta_dia'],
                'nombre': r['nombre_tipificacion']
            }
        
        cursor.execute(
            """
            SELECT COUNT(*) as registros_no_rrhh
            FROM asistencia 
            WHERE super = %s AND DATE(fecha_asistencia) = %s AND (carpeta IS NULL OR UPPER(carpeta) <> 'RRHH')
            """,
            (supervisor_usuario, fecha_hoy)
        )
        r_no_rrhh = cursor.fetchone()
        registros_no_rrhh = r_no_rrhh['registros_no_rrhh'] if r_no_rrhh else 0
        total_tecnicos = len(tecnicos)
        total_rrhh = len(rrhh_rows)
        pendientes = max(total_tecnicos - total_rrhh, 0)
        ya_registrado = (registros_no_rrhh >= pendientes and pendientes > 0)
        return render_template('modulos/operativo/asistencia.html',
                           tecnicos=tecnicos,
                           carpetas_dia=carpetas_dia,
                           supervisor=supervisor_usuario,
                           ya_registrado=ya_registrado,
                           fecha_hoy=fecha_hoy,
                           novedades_rrhh=novedades_rrhh)
                           
    except mysql.connector.Error as e:
        flash(f'Error al cargar datos: {str(e)}', 'danger')
        return redirect(url_for('operativo_dashboard'))
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/operativo/cierre-ciclo')
@login_required(role=['operativo','tecnico','tecnicos'])
def operativo_cierre_ciclo():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('operativo_dashboard'))
        cursor = connection.cursor(dictionary=True)
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        cursor.execute(
            """
            SELECT COUNT(*) as registros_hoy
            FROM asistencia 
            WHERE id_codigo_consumidor = %s AND DATE(fecha_asistencia) = %s
            """,
            (session['id_codigo_consumidor'], fecha_hoy)
        )
        registro_existente = cursor.fetchone()
        tiene_asistencia = registro_existente['registros_hoy'] > 0 if registro_existente else False
        resp = make_response(render_template('modulos/operativo/cierre_ciclo.html', tiene_asistencia=tiene_asistencia))
        resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
        resp.headers['Pragma'] = 'no-cache'
        resp.headers['Expires'] = '0'
        return resp
    except mysql.connector.Error as e:
        flash(f'Error al cargar Cierre de Ciclo: {str(e)}', 'danger')
        return redirect(url_for('operativo_dashboard'))
    finally:
        if cursor:
            try:
                cursor.close()
            except:
                pass
        if connection and connection.is_connected():
            try:
                connection.close()
            except:
                pass

@app.route('/api/operativo/cierre-ciclo', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo():
    fecha = (request.args.get('fecha') or '').strip()
    tipificacion = (request.args.get('tipificacion') or '').strip()
    connection = None
    c = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
        cols_type = {}
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        for r in c.fetchall():
            cols_type[r[0].lower()] = str(r[1]).lower()
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols_all:
                    return cols_all[k]
            for k0,v0 in cols_all.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        col_estado = pick(['estado'])
        col_cierre = pick(['cierre_ciclo'])
        col_tip_ok = pick(['tipificacion_ok'])
        col_tip_nov = pick(['tipificacion_novedad'])
        # Columnas para gestión de supervisor
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': True, 'data': [], 'total': 0}), 200
        params = []
        where = []
        where.append(f"o.`{col_cuenta}` IS NOT NULL")
        where.append(f"CAST(o.`{col_cuenta}` AS CHAR) <> ''")
        where.append(f"o.`{col_cuenta}` REGEXP '^[0-9]+'")
        where.append(f"CAST(o.`{col_cuenta}` AS SIGNED) > 0")
        where.append(f"CHAR_LENGTH(CAST(o.`{col_cuenta}` AS CHAR)) >= 6")
        if col_estado:
            where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
        if col_cierre:
            where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
        try:
            user_role = session.get('user_role')
        except Exception:
            user_role = None
        if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
            val_id = str(session.get('id_codigo_consumidor') or '').strip()
            val_ced = str(session.get('user_cedula') or '').strip()
            col_l = str(col_ext).lower()
            if 'cedula' in col_l:
                if val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
            else:
                if val_id and val_ced:
                    where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                    params.extend([val_id, val_ced])
                elif val_id:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_id)
                elif val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
        elif user_role in ('operativo','Operativo') and col_ext:
            sup_name = str(session.get('user_name') or '').strip()
            tech_keys = []
            try:
                c_sup = connection.cursor()
                try:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE super = %s
                        """,
                        (sup_name,)
                    )
                except Exception:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE supervisor = %s
                        """,
                        (sup_name,)
                    )
                for r0 in c_sup.fetchall() or []:
                    try:
                        if r0[0] is not None:
                            tech_keys.append(str(r0[0]))
                    except Exception:
                        pass
                    try:
                        if r0[1] is not None:
                            tech_keys.append(str(r0[1]))
                    except Exception:
                        pass
                c_sup.close()
            except Exception:
                tech_keys = []
            tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
            if len(tech_keys) == 0:
                return jsonify({'success': True, 'data': [], 'total': 0}), 200
            placeholders = ','.join(['%s'] * len(tech_keys))
            where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
            params.extend(tech_keys)
        tipo_fecha_base = cols_type.get((col_fecha_franja or col_fecha).lower())
        if fecha:
            fecha_norm = fecha
            for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
                try:
                    fecha_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                    break
                except Exception:
                    pass
            target_col = col_fecha_franja or col_fecha
            if tipo_fecha_base in ('datetime','timestamp','date'):
                where.append(f"DATE(o.`{target_col}`) = %s")
                params.append(fecha_norm)
            else:
                try:
                    y = fecha_norm[0:4]
                    m = fecha_norm[5:7]
                    d = fecha_norm[8:10]
                    like_patterns = [
                        f"{fecha_norm}%",
                        f"{y}/{m}/{d}%",
                        f"{d}/{m}/{y}%",
                        f"{d}-{m}-{y}%"
                    ]
                except Exception:
                    like_patterns = [fecha_norm + '%']
                where.append("(" + " OR ".join([f"o.`{target_col}` LIKE %s"] * len(like_patterns)) + ")")
                params.extend(like_patterns)
        if tipificacion:
            if col_tip_ok:
                where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
                params.append(tipificacion)
            elif col_tip_nov:
                where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
                params.append(tipificacion)
        select_parts = [
            f"o.`{col_ot}` AS orden_de_trabajo",
            f"o.`{col_cuenta}` AS numero_de_cuenta",
            f"o.`{col_ext}` AS tecnico_id"
        ]
        tipo_fecha_col_fecha = cols_type.get(col_fecha.lower())
        if tipo_fecha_col_fecha in ('datetime','timestamp','date'):
            select_parts.append(f"DATE_FORMAT(o.`{col_fecha}`, '%Y-%m-%d') AS fecha")
        else:
            select_parts.append(f"o.`{col_fecha}` AS fecha")
        if col_estado:
            select_parts.append(f"o.`{col_estado}` AS estado")
        if col_cierre:
            select_parts.append(f"o.`{col_cierre}` AS cierre_ciclo")
        if col_tip_ok:
            select_parts.append(f"o.`{col_tip_ok}` AS tipificacion_ok")
        if col_tip_nov:
            select_parts.append(f"o.`{col_tip_nov}` AS tipificacion_novedad")
        if col_cierre_super:
            select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
        if col_tip_super_1:
            select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
        if col_tip_super_2:
            select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
        if col_fecha_gestion_super:
            select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
        if col_fecha_franja:
            tipo_fecha_franja = cols_type.get(col_fecha_franja.lower())
            if tipo_fecha_franja in ('datetime','timestamp','date'):
                select_parts.append(f"DATE_FORMAT(o.`{col_fecha_franja}`, '%Y-%m-%d') AS fecha_franja_cierre_ciclo")
            else:
                select_parts.append(f"o.`{col_fecha_franja}` AS fecha_franja_cierre_ciclo")
        if col_franja_cierre:
            select_parts.append(f"o.`{col_franja_cierre}` AS franja_cierre_ciclo")
        if col_alerta:
            select_parts.append(f"o.`{col_alerta}` AS alerta_cierre_ciclo")
        sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
        if where:
            sql += " WHERE " + " AND ".join(where)
        order_col = col_fecha_franja or col_fecha
        if tipo_fecha_base in ('datetime','timestamp','date'):
            sql += f" ORDER BY DATE(o.`{order_col}`) DESC"
        else:
            sql += f" ORDER BY o.`{order_col}` DESC"
        cur = connection.cursor(dictionary=True)
        cur.execute(sql, tuple(params))
        rows = cur.fetchall() or []
        f_norm = None
        if fecha:
            f_norm = fecha
            for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
                try:
                    f_norm = datetime.strptime(fecha, fmt).strftime('%Y-%m-%d')
                    break
                except Exception:
                    pass
        if f_norm:
            try:
                tgt = datetime.strptime(f_norm, '%Y-%m-%d').date()
                def pdt(v):
                    if v is None:
                        return None
                    if hasattr(v, 'year') and hasattr(v, 'month') and hasattr(v, 'day'):
                        try:
                            return v.date() if hasattr(v, 'date') else datetime(int(getattr(v,'year')), int(getattr(v,'month')), int(getattr(v,'day'))).date()
                        except Exception:
                            return None
                    s = str(v).strip()
                    s0 = s.split('.')[0]
                    try:
                        d0 = datetime.fromisoformat(s0.replace('Z',''))
                        return d0.date()
                    except Exception:
                        pass
                    for fmt in ('%Y-%m-%d %H:%M:%S','%Y-%m-%d','%d/%m/%Y %H:%M:%S','%d/%m/%Y','%d-%m-%Y %H:%M:%S','%d-%m-%Y','%Y/%m/%d %H:%M:%S','%Y/%m/%d'):
                        try:
                            return datetime.strptime(s0, fmt).date()
                        except Exception:
                            pass
                    return None
                rows = [r for r in rows if pdt(r.get('fecha_franja_cierre_ciclo') or r.get('fecha')) == tgt]
            except Exception:
                pass
        tecnico_ids = {str(r.get('tecnico_id')) for r in rows if r.get('tecnico_id') is not None}
        nombres_map = {}
        analistas_map = {}
        supervisores_map = {}
        if tecnico_ids:
            placeholders = ','.join(['%s'] * len(tecnico_ids))
            c2 = connection.cursor()
            c2.execute(
                f"SELECT recurso_operativo_cedula, nombre, analista, super FROM recurso_operativo WHERE CAST(recurso_operativo_cedula AS CHAR) IN ({placeholders})",
                tuple(tecnico_ids)
            )
            for r in c2.fetchall() or []:
                nombres_map[str(r[0])] = r[1]
                analistas_map[str(r[0])] = r[2] if len(r) > 2 else ''
                supervisores_map[str(r[0])] = r[3] if len(r) > 3 else ''
            try:
                c2.execute(
                    f"SELECT id_codigo_consumidor, nombre, analista, super FROM recurso_operativo WHERE CAST(id_codigo_consumidor AS CHAR) IN ({placeholders})",
                    tuple(tecnico_ids)
                )
                for r in c2.fetchall() or []:
                    nombres_map[str(r[0])] = r[1]
                    analistas_map[str(r[0])] = r[2] if len(r) > 2 else ''
                    supervisores_map[str(r[0])] = r[3] if len(r) > 3 else ''
            except Exception:
                pass
            c2.close()
        for r in rows:
            cid = str(r.get('tecnico_id')) if r.get('tecnico_id') is not None else ''
            r['tecnico'] = nombres_map.get(cid, '')
            r['analista'] = analistas_map.get(cid, '')
            r['supervisor'] = supervisores_map.get(cid, '')
            done = False
            val_cierre = r.get('cierre_super')
            if val_cierre is not None:
                try:
                    done = int(val_cierre) == 1
                except Exception:
                    done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
            if not done and r.get('fecha_gestion_super'):
                done = True
            if not done:
                tip1 = r.get('tip_super_1')
                tip2 = r.get('tip_super_2')
                tip2_norm = str(tip2 or '').strip().lower()
                pending2 = (
                    tip2_norm == 'en predio' or
                    tip2_norm == 'cliente no atiende' or
                    tip2_norm == 'reprogramar' or
                    ('reprogramar' in tip2_norm) or
                    ('cliente no atiende' in tip2_norm)
                )
                if tip2 and str(tip2).strip():
                    done = not pending2
                elif tip1 and str(tip1).strip():
                    done = True
            r['estado_super'] = 'Completado' if done else 'Pendiente'
        cur.close(); connection.close()
        return jsonify({'success': True, 'data': rows, 'total': len(rows)})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/pending-list', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo_pending_list():
    tipificacion = (request.args.get('tip') or request.args.get('tipificacion') or '').strip()
    connection = None
    c = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
        cols_type = {}
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        for r in c.fetchall():
            cols_type[r[0].lower()] = str(r[1]).lower()
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols_all:
                    return cols_all[k]
            for k0,v0 in cols_all.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        col_estado = pick(['estado'])
        col_cierre = pick(['cierre_ciclo'])
        col_tip_ok = pick(['tipificacion_ok'])
        col_tip_nov = pick(['tipificacion_novedad'])
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        if not col_ot or not col_cuenta or not col_fecha or not col_ext:
            return jsonify({'success': True, 'items': [], 'total': 0}), 200
        params = []
        where = []
        if col_estado:
            where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
        if col_cierre:
            where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
        try:
            user_role = session.get('user_role')
        except Exception:
            user_role = None
        if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
            val_id = str(session.get('id_codigo_consumidor') or '').strip()
            val_ced = str(session.get('user_cedula') or '').strip()
            col_l = str(col_ext).lower()
            if 'cedula' in col_l:
                if val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
            else:
                if val_id and val_ced:
                    where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                    params.extend([val_id, val_ced])
                elif val_id:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_id)
                elif val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
        elif user_role in ('operativo','Operativo') and col_ext:
            sup_name = str(session.get('user_name') or '').strip()
            tech_keys = []
            try:
                c_sup = connection.cursor()
                try:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE super = %s
                        """,
                        (sup_name,)
                    )
                except Exception:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE supervisor = %s
                        """,
                        (sup_name,)
                    )
                for r0 in c_sup.fetchall() or []:
                    try:
                        if r0[0] is not None:
                            tech_keys.append(str(r0[0]))
                    except Exception:
                        pass
                    try:
                        if r0[1] is not None:
                            tech_keys.append(str(r0[1]))
                    except Exception:
                        pass
                c_sup.close()
            except Exception:
                tech_keys = []
            tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
            if len(tech_keys) == 0:
                return jsonify({'success': True, 'items': [], 'total': 0}), 200
            placeholders = ','.join(['%s'] * len(tech_keys))
            where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
            params.extend(tech_keys)
        if tipificacion:
            if col_tip_ok:
                where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
                params.append(tipificacion)
            elif col_tip_nov:
                where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
                params.append(tipificacion)
        select_parts = [
            f"o.`{col_ot}` AS orden_de_trabajo",
            f"o.`{col_cuenta}` AS numero_de_cuenta",
            f"o.`{col_ext}` AS tecnico_id"
        ]
        tipo_fecha_col_fecha = cols_type.get(col_fecha.lower())
        if tipo_fecha_col_fecha in ('datetime','timestamp','date'):
            select_parts.append(f"DATE_FORMAT(o.`{col_fecha}`, '%Y-%m-%d') AS fecha")
        else:
            select_parts.append(f"o.`{col_fecha}` AS fecha")
        if col_estado:
            select_parts.append(f"o.`{col_estado}` AS estado")
        if col_cierre:
            select_parts.append(f"o.`{col_cierre}` AS cierre_ciclo")
        if col_tip_ok:
            select_parts.append(f"o.`{col_tip_ok}` AS tipificacion_ok")
        if col_tip_nov:
            select_parts.append(f"o.`{col_tip_nov}` AS tipificacion_novedad")
        if col_cierre_super:
            select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
        if col_tip_super_1:
            select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
        if col_tip_super_2:
            select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
        if col_fecha_gestion_super:
            select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
        if col_fecha_franja:
            tipo_fecha_franja = cols_type.get(col_fecha_franja.lower())
            if tipo_fecha_franja in ('datetime','timestamp','date'):
                select_parts.append(f"DATE_FORMAT(o.`{col_fecha_franja}`, '%Y-%m-%d') AS fecha_franja_cierre_ciclo")
            else:
                select_parts.append(f"o.`{col_fecha_franja}` AS fecha_franja_cierre_ciclo")
        if col_franja_cierre:
            select_parts.append(f"o.`{col_franja_cierre}` AS franja_cierre_ciclo")
        if col_alerta:
            select_parts.append(f"o.`{col_alerta}` AS alerta_cierre_ciclo")
        sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
        if where:
            sql += " WHERE " + " AND ".join(where)
        order_col = col_fecha_franja or col_fecha
        tipo_order = cols_type.get(order_col.lower())
        if tipo_order in ('datetime','timestamp','date'):
            sql += f" ORDER BY DATE(o.`{order_col}`) ASC"
        else:
            sql += f" ORDER BY o.`{order_col}` ASC"
        cur = connection.cursor(dictionary=True)
        cur.execute(sql, tuple(params))
        rows = cur.fetchall() or []
        cur.close()
        for r in rows:
            cid = str(r.get('tecnico_id')) if r.get('tecnico_id') is not None else ''
            done = False
            val_cierre = r.get('cierre_super')
            if val_cierre is not None:
                try:
                    done = int(val_cierre) == 1
                except Exception:
                    done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
            if not done and r.get('fecha_gestion_super'):
                done = True
            if not done:
                tip1 = r.get('tip_super_1')
                tip2 = r.get('tip_super_2')
                tip2_norm = str(tip2 or '').strip().lower()
                pending2 = (
                    tip2_norm == 'en predio' or
                    tip2_norm == 'cliente no atiende' or
                    tip2_norm == 'reprogramar' or
                    ('reprogramar' in tip2_norm) or
                    ('cliente no atiende' in tip2_norm)
                )
                if tip2 and str(tip2).strip():
                    done = not pending2
                elif tip1 and str(tip1).strip():
                    done = True
            r['estado_super'] = 'Completado' if done else 'Pendiente'
        rows = [r for r in rows if (r.get('estado_super') or '') != 'Completado']
        tecnico_ids = {str(r.get('tecnico_id')) for r in rows if r.get('tecnico_id') is not None}
        nombres_map = {}
        analistas_map = {}
        supervisores_map = {}
        if tecnico_ids:
            placeholders = ','.join(['%s'] * len(tecnico_ids))
            c2 = connection.cursor()
            c2.execute(
                f"SELECT recurso_operativo_cedula, nombre, analista, super FROM recurso_operativo WHERE CAST(recurso_operativo_cedula AS CHAR) IN ({placeholders})",
                tuple(tecnico_ids)
            )
            for r in c2.fetchall() or []:
                nombres_map[str(r[0])] = r[1]
                analistas_map[str(r[0])] = r[2] if len(r) > 2 else ''
                supervisores_map[str(r[0])] = r[3] if len(r) > 3 else ''
            try:
                c2.execute(
                    f"SELECT id_codigo_consumidor, nombre, analista, super FROM recurso_operativo WHERE CAST(id_codigo_consumidor AS CHAR) IN ({placeholders})",
                    tuple(tecnico_ids)
                )
                for r in c2.fetchall() or []:
                    nombres_map[str(r[0])] = r[1]
                    analistas_map[str(r[0])] = r[2] if len(r) > 2 else ''
                    supervisores_map[str(r[0])] = r[3] if len(r) > 3 else ''
            except Exception:
                pass
            c2.close()
        for r in rows:
            cid = str(r.get('tecnico_id')) if r.get('tecnico_id') is not None else ''
            r['tecnico'] = nombres_map.get(cid, '')
            r['analista'] = analistas_map.get(cid, '')
            r['supervisor'] = supervisores_map.get(cid, '')
        connection.close()
        return jsonify({'success': True, 'items': rows, 'total': len(rows)})
    except Exception as e:
        try:
            if connection:
                connection.close()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/detalle', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos','lider','administrativo'])
def api_operativo_cierre_ciclo_detalle():
    ot = (request.args.get('ot') or '').strip()
    cuenta = (request.args.get('cuenta') or '').strip()
    connection = None
    c = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in c.fetchall()}
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        col_estado = pick(['estado'])
        col_final = pick(['estado_final'])
        col_cierre = pick(['cierre_ciclo'])
        col_tip_ok = pick(['tipificacion_ok'])
        col_tip_nov = pick(['tipificacion_novedad'])
        col_observ = pick(['observacion_cierre'])
        col_observ_super = pick(['observacion_super'])
        col_recomendacion = pick(['recomendacion_tecnico'])
        col_img_falla = pick(['imagen_falla'])
        col_img_sol = pick(['imagen_solucion'])
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        col_fecha_franja = pick(['fecha_franja_cierre_ciclo'])
        col_franja_cierre = pick(['franja_cierre_ciclo'])
        col_alerta = pick(['alerta_cierre_ciclo','nivel_alerta','alerta'])
        tipo_fecha = None
        tipo_fecha_franja = None
        if col_fecha:
            c.execute(
                """
                SELECT DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                """,
                (db_config.get('database'), col_fecha)
            )
            rowt = c.fetchone()
            try:
                tipo_fecha = str(rowt[0]).lower() if rowt and rowt[0] else None
            except Exception:
                tipo_fecha = None
        if col_fecha_franja:
            c.execute(
                """
                SELECT DATA_TYPE FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias' AND column_name=%s
                """,
                (db_config.get('database'), col_fecha_franja)
            )
            rowtf = c.fetchone()
            try:
                tipo_fecha_franja = str(rowtf[0]).lower() if rowtf and rowtf[0] else None
            except Exception:
                tipo_fecha_franja = None
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'message': 'Columnas requeridas no encontradas'}), 200
        select_parts = [
            f"o.`{col_ot}` AS orden_de_trabajo",
            f"o.`{col_cuenta}` AS numero_de_cuenta"
        ]
        if col_fecha:
            if tipo_fecha in ('datetime','timestamp','date'):
                select_parts.append(f"DATE_FORMAT(o.`{col_fecha}`, '%Y-%m-%d') AS fecha")
            else:
                select_parts.append(f"o.`{col_fecha}` AS fecha")
        if col_estado:
            select_parts.append(f"o.`{col_estado}` AS estado")
        if col_final:
            select_parts.append(f"o.`{col_final}` AS estado_final")
        if col_cierre:
            select_parts.append(f"o.`{col_cierre}` AS cierre_ciclo")
        if col_tip_ok:
            select_parts.append(f"o.`{col_tip_ok}` AS tipificacion_ok")
        if col_tip_nov:
            select_parts.append(f"o.`{col_tip_nov}` AS tipificacion_novedad")
        if col_observ:
            select_parts.append(f"o.`{col_observ}` AS observacion_cierre")
        if col_observ_super:
            select_parts.append(f"o.`{col_observ_super}` AS observacion_super")
        if col_recomendacion:
            select_parts.append(f"o.`{col_recomendacion}` AS recomendacion_tecnico")
        if col_img_falla:
            select_parts.append(f"o.`{col_img_falla}` AS imagen_falla")
        if col_img_sol:
            select_parts.append(f"o.`{col_img_sol}` AS imagen_solucion")
        if col_cierre_super:
            select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
        if col_tip_super_1:
            select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
        if col_tip_super_2:
            select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
        if col_fecha_gestion_super:
            select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
        if col_fecha_franja:
            if tipo_fecha_franja in ('datetime','timestamp','date'):
                select_parts.append(f"DATE_FORMAT(o.`{col_fecha_franja}`, '%Y-%m-%d') AS fecha_franja_cierre_ciclo")
            else:
                select_parts.append(f"o.`{col_fecha_franja}` AS fecha_franja_cierre_ciclo")
        if col_franja_cierre:
            select_parts.append(f"o.`{col_franja_cierre}` AS franja_cierre_ciclo")
        if col_alerta:
            select_parts.append(f"o.`{col_alerta}` AS alerta_cierre_ciclo")
        sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o WHERE 1=1"
        params = []
        sql += f" AND o.`{col_ot}` = %s"
        params.append(ot)
        sql += f" AND o.`{col_cuenta}` = %s"
        params.append(cuenta)
        cur = connection.cursor(dictionary=True)
        cur.execute(sql, tuple(params))
        row = cur.fetchone() or {}
        if row:
            cid = str(row.get('tecnico_id') or '')
            if not cid and col_ext:
                cur2 = connection.cursor()
                cur2.execute(
                    f"SELECT `{col_ext}` FROM operaciones_actividades_diarias WHERE `{col_ot}`=%s AND `{col_cuenta}`=%s LIMIT 1",
                    (ot, cuenta)
                )
                rv = cur2.fetchone()
                if rv:
                    cid = str(rv[0])
                cur2.close()
            if cid:
                c2 = connection.cursor()
                c2.execute(
                    "SELECT recurso_operativo_cedula, nombre, analista, super FROM recurso_operativo WHERE CAST(recurso_operativo_cedula AS CHAR)=%s",
                    (cid,)
                )
                r2 = c2.fetchone()
                if r2:
                    row['tecnico'] = r2[1]
                    row['analista'] = r2[2] if len(r2) > 2 else ''
                    row['supervisor'] = r2[3] if len(r2) > 3 else ''
                c2.close()
        cur.close(); connection.close()
        return jsonify({'success': True, 'data': row})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/tipificaciones1', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_tipificaciones1():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='tipificacion_cierre_ciclo_super'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cursor.fetchall()}
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_nivel = pick(['nivel','level','tipo'])
        col_codigo = pick(['codigo','codigo_tipificacion','cod','code'])
        col_nombre = pick(['nombre','nombre_tipificacion','name'])
        col_t1 = pick(['tipificacion_cierre_ciclo_1','tipificacion_1','t1','nivel1'])
        cur = connection.cursor(dictionary=True)
        if col_t1:
            sql = f"SELECT DISTINCT `{col_t1}` AS codigo FROM tipificacion_cierre_ciclo_super"
            sql += f" WHERE `{col_t1}` IS NOT NULL AND TRIM(CAST(`{col_t1}` AS CHAR)) <> ''"
            sql += " ORDER BY 1"
            cur.execute(sql)
            rows_raw = cur.fetchall() or []
            out = []
            for r in rows_raw:
                val = r.get('codigo')
                s = '' if val is None else str(val)
                out.append({'codigo': s, 'nombre': s})
            cur.close(); connection.close()
            return jsonify({'success': True, 'data': out})
        else:
            sql = "SELECT * FROM tipificacion_cierre_ciclo_super"
            where = []
            if col_nivel:
                where.append(f"CAST(`{col_nivel}` AS SIGNED) = 1")
            elif pick(['padre','parent','id_padre','padre_codigo']):
                col_padre_tmp = pick(['padre','parent','id_padre','padre_codigo'])
                where.append(f"(`{col_padre_tmp}` IS NULL OR TRIM(CAST(`{col_padre_tmp}` AS CHAR)) IN ('','0'))")
            if where:
                sql += " WHERE " + " AND ".join(where)
            cur.execute(sql)
            rows_raw = cur.fetchall() or []
            def find_key(keys, patterns):
                for k in keys:
                    kl = k.lower()
                    for p in patterns:
                        if p in kl:
                            return k
                return None
            out = []
            if rows_raw:
                keys = list(rows_raw[0].keys())
                codigo_key = col_codigo or find_key(keys, ['codigo','cod','id']) or keys[0]
                nombre_key = col_nombre or find_key(keys, ['nombre','name','descripcion','desc']) or codigo_key
                for r in rows_raw:
                    cod_val = r.get(codigo_key)
                    nom_val = r.get(nombre_key)
                    out.append({'codigo': '' if cod_val is None else str(cod_val), 'nombre': '' if nom_val is None else str(nom_val)})
            cur.close(); connection.close()
            return jsonify({'success': True, 'data': out})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/tipificaciones2', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_tipificaciones2():
    parent = (request.args.get('parent') or '').strip()
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='tipificacion_cierre_ciclo_super'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cursor.fetchall()}
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_nivel = pick(['nivel','level','tipo'])
        col_codigo = pick(['codigo','codigo_tipificacion','cod','code'])
        col_nombre = pick(['nombre','nombre_tipificacion','name'])
        col_padre = pick(['padre','parent','id_padre','padre_codigo'])
        col_t1 = pick(['tipificacion_cierre_ciclo_1','tipificacion_1','t1','nivel1'])
        col_t2 = pick(['tipificacion_cierre_ciclo_2','tipificacion_2','t2','nivel2'])
        cur = connection.cursor(dictionary=True)
        if col_t1 and col_t2 and parent:
            sql = f"SELECT DISTINCT `{col_t2}` AS codigo FROM tipificacion_cierre_ciclo_super WHERE `{col_t1}` = %s AND `{col_t2}` IS NOT NULL AND TRIM(CAST(`{col_t2}` AS CHAR)) <> '' ORDER BY 1"
            cur.execute(sql, (parent,))
            rows_raw = cur.fetchall() or []
            out = []
            for r in rows_raw:
                val = r.get('codigo')
                s = '' if val is None else str(val)
                out.append({'codigo': s, 'nombre': s})
            cur.close(); connection.close()
            return jsonify({'success': True, 'data': out})
        else:
            sql = "SELECT * FROM tipificacion_cierre_ciclo_super"
            where = []
            params = []
            if col_nivel:
                where.append(f"CAST(`{col_nivel}` AS SIGNED) = 2")
            if col_padre and parent:
                where.append(f"`{col_padre}` = %s")
                params.append(parent)
            elif col_padre and not parent:
                where.append(f"TRIM(CAST(`{col_padre}` AS CHAR)) <> ''")
            if where:
                sql += " WHERE " + " AND ".join(where)
            cur.execute(sql, tuple(params))
            rows_raw = cur.fetchall() or []
            def find_key(keys, patterns):
                for k in keys:
                    kl = k.lower()
                    for p in patterns:
                        if p in kl:
                            return k
                return None
            out = []
            if rows_raw:
                keys = list(rows_raw[0].keys())
                codigo_key = col_codigo or find_key(keys, ['codigo','cod','id']) or keys[0]
                nombre_key = col_nombre or find_key(keys, ['nombre','name','descripcion','desc']) or codigo_key
                for r in rows_raw:
                    cod_val = r.get(codigo_key)
                    nom_val = r.get(nombre_key)
                    out.append({'codigo': '' if cod_val is None else str(cod_val), 'nombre': '' if nom_val is None else str(nom_val)})
            cur.close(); connection.close()
            return jsonify({'success': True, 'data': out})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/gestionar', methods=['POST'])
@login_required_api(role='operativo')
def api_operativo_cierre_ciclo_gestionar():
    data_json = None
    try:
        data_json = request.get_json(silent=True)
    except Exception:
        data_json = None
    data_json = data_json or {}
    form = request.form or {}
    ot = str((data_json.get('ot') or form.get('ot') or '')).strip()
    cuenta = str((data_json.get('cuenta') or form.get('cuenta') or '')).strip()
    tip1 = str((data_json.get('tip_super_1') or form.get('tip_super_1') or '')).strip()
    tip2 = str((data_json.get('tip_super_2') or form.get('tip_super_2') or '')).strip()
    observ = str((data_json.get('observacion_super') or form.get('observacion_super') or '')).strip()
    recomendacion = str((data_json.get('recomendacion_tecnico') or form.get('recomendacion_tecnico') or '')).strip()
    fecha_franja = str((data_json.get('fecha_franja_cierre_ciclo') or form.get('fecha_franja_cierre_ciclo') or '')).strip()
    franja_cierre = str((data_json.get('franja_cierre_ciclo') or form.get('franja_cierre_ciclo') or '')).strip()
    img_falla_url = None
    img_sol_url = None
    connection = None
    cur = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def ensure_col(col, ddl):
            if col.lower() not in cols:
                c2 = connection.cursor()
                c2.execute(ddl)
                c2.close()
                cols[col.lower()] = col
        ensure_col('tip_super_1', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tip_super_1` TEXT NULL")
        ensure_col('tip_super_2', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `tip_super_2` TEXT NULL")
        ensure_col('observacion_super', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `observacion_super` TEXT NULL")
        ensure_col('cierre_super', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `cierre_super` TINYINT(1) NULL DEFAULT 0")
        ensure_col('fecha_gestion_super', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `fecha_gestion_super` DATETIME NULL")
        ensure_col('imagen_falla', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `imagen_falla` TEXT NULL")
        ensure_col('imagen_solucion', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `imagen_solucion` TEXT NULL")
        ensure_col('recomendacion_tecnico', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `recomendacion_tecnico` TEXT NULL")
        ensure_col('fecha_franja_cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `fecha_franja_cierre_ciclo` DATE NULL")
        ensure_col('franja_cierre_ciclo', "ALTER TABLE `operaciones_actividades_diarias` ADD COLUMN `franja_cierre_ciclo` TEXT NULL")
        try:
            c2 = connection.cursor()
            c2.execute(
                """
                SELECT column_name, data_type FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                AND column_name IN ('tip_super_1','tip_super_2','imagen_falla','imagen_solucion','recomendacion_tecnico')
                """,
                (db_config.get('database'),)
            )
            for cname, dtype in c2.fetchall():
                if str(dtype).lower().startswith('varchar'):
                    c2.execute(f"ALTER TABLE `operaciones_actividades_diarias` MODIFY COLUMN `{cname}` TEXT NULL")
            c2.close()
        except Exception:
            pass
        try:
            c2 = connection.cursor()
            c2.execute("ALTER TABLE `operaciones_actividades_diarias` ROW_FORMAT=DYNAMIC")
            c2.close()
        except Exception:
            pass
        cur.execute(
            """
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols = {r[0].lower(): r[0] for r in cur.fetchall()}
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols:
                    return cols[k]
            for k0,v0 in cols.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
        col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
        if not col_ot or not col_cuenta:
            return jsonify({'success': False, 'message': 'Columnas requeridas no encontradas'}), 200
        if not observ or not recomendacion:
            return jsonify({'success': False, 'message': 'Observación del super y recomendación al técnico son obligatorias'}), 200

        try:
            f1 = request.files.get('imagen_falla')
        except Exception:
            f1 = None
        try:
            f2 = request.files.get('imagen_solucion')
        except Exception:
            f2 = None
        if not ((f1 and getattr(f1, 'filename', '')) and (f2 and getattr(f2, 'filename', ''))):
            return jsonify({'success': False, 'message': 'Debe adjuntar imagen de falla y de solución'}), 200
        try:
            base_root = app.config.get('UPLOAD_FOLDER', 'static/uploads')
            base_dir = os.path.join(base_root, 'cierre_ciclo', str(cuenta or 'sin_cuenta'), str(ot or 'sin_ot'))
            os.makedirs(base_dir, exist_ok=True)
            if f1 and getattr(f1, 'filename', ''):
                filename = secure_filename(getattr(f1, 'filename', '') or 'imagen_falla')
                name, ext = os.path.splitext(filename)
                ts = datetime.now().strftime('%Y%m%d%H%M%S%f')
                final_name = f"falla_{ts}{ext or '.bin'}"
                path = os.path.join(base_dir, final_name)
                f1.save(path)
                img_falla_url = '/' + path.replace('\\','/')
            if f2 and getattr(f2, 'filename', ''):
                filename2 = secure_filename(getattr(f2, 'filename', '') or 'imagen_solucion')
                name2, ext2 = os.path.splitext(filename2)
                ts2 = datetime.now().strftime('%Y%m%d%H%M%S%f')
                final_name2 = f"solucion_{ts2}{ext2 or '.bin'}"
                path2 = os.path.join(base_dir, final_name2)
                f2.save(path2)
                img_sol_url = '/' + path2.replace('\\','/')
        except Exception:
            pass
        tip2_norm = tip2.lower().strip()
        should_pending = (
            tip2_norm == 'en predio' or
            tip2_norm == 'cliente no atiende' or
            tip2_norm == 'reprogramar' or
            ('reprogramar' in tip2_norm) or
            ('cliente no atiende' in tip2_norm)
        )
        set_parts = ["`tip_super_1`=%s","`tip_super_2`=%s","`observacion_super`=%s"]
        if fecha_franja:
            set_parts.append("`fecha_franja_cierre_ciclo`=%s")
        if franja_cierre:
            set_parts.append("`franja_cierre_ciclo`=%s")
        if should_pending:
            set_parts.append("`cierre_super`=0")
            set_parts.append("`fecha_gestion_super`=NULL")
        else:
            set_parts.append("`cierre_super`=1")
            set_parts.append("`fecha_gestion_super`=NOW()")
        if recomendacion:
            set_parts.append("`recomendacion_tecnico`=%s")
        if img_falla_url:
            set_parts.append("`imagen_falla`=%s")
        if img_sol_url:
            set_parts.append("`imagen_solucion`=%s")
        params = [tip1, tip2, observ]
        if fecha_franja:
            params.append(fecha_franja)
        if franja_cierre:
            params.append(franja_cierre)
        if recomendacion:
            params.append(recomendacion)
        if img_falla_url:
            params.append(img_falla_url)
        if img_sol_url:
            params.append(img_sol_url)
        sql = f"UPDATE `operaciones_actividades_diarias` SET {', '.join(set_parts)} WHERE `{col_ot}`=%s AND `{col_cuenta}`=%s"
        params.extend([ot, cuenta])
        cur.execute(sql, tuple(params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True, 'pending': should_pending})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/pending-count', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo_pending_count():
    connection = None
    c = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        c = connection.cursor()
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
        cols_type = {}
        c.execute(
            """
            SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
            WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
            """,
            (db_config.get('database'),)
        )
        for r in c.fetchall():
            cols_type[r[0].lower()] = str(r[1]).lower()
        def pick(names):
            for n in names:
                k = n.lower()
                if k in cols_all:
                    return cols_all[k]
            for k0,v0 in cols_all.items():
                for n in names:
                    if n.lower() in k0:
                        return v0
            return None
        col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
        col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
        col_cierre = pick(['cierre_ciclo'])
        col_estado = pick(['estado'])
        col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
        col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
        col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
        col_cierre_super = pick(['cierre_super','estado_super'])
        col_tip_ok = pick(['tipificacion_ok'])
        col_tip_nov = pick(['tipificacion_novedad'])
        if not col_ext:
            return jsonify({'success': True, 'pending': 0})
        params = []
        where = []
        if col_cierre:
            where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
        if col_estado:
            where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
        fecha_arg = (request.args.get('fecha') or '').strip()
        tip_arg = (request.args.get('tip') or '').strip()
        if not tip_arg:
            tip_arg = 'CLIENTE INCONFORME'
        fecha_norm = None
        if fecha_arg:
            fecha_norm = fecha_arg
            for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
                try:
                    fecha_norm = datetime.strptime(fecha_arg, fmt).strftime('%Y-%m-%d')
                    break
                except Exception:
                    pass
        else:
            fecha_norm = datetime.now().strftime('%Y-%m-%d')
        if col_fecha and fecha_norm:
            tipo_fecha = cols_type.get(col_fecha.lower())
            if tipo_fecha in ('datetime','timestamp','date'):
                where.append(f"DATE(o.`{col_fecha}`) = %s")
                params.append(fecha_norm)
            else:
                where.append(f"o.`{col_fecha}` LIKE %s")
                params.append(fecha_norm + '%')
        if tip_arg:
            if col_tip_ok:
                where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
                params.append(tip_arg)
            elif col_tip_nov:
                where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
                params.append(tip_arg)
        user_role = None
        try:
            user_role = session.get('user_role')
        except Exception:
            user_role = None
        if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
            val_id = str(session.get('id_codigo_consumidor') or '').strip()
            val_ced = str(session.get('user_cedula') or '').strip()
            col_l = str(col_ext).lower()
            if 'cedula' in col_l:
                if val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
            else:
                if val_id and val_ced:
                    where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                    params.extend([val_id, val_ced])
                elif val_id:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_id)
                elif val_ced:
                    where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                    params.append(val_ced)
        else:
            sup_name = str(session.get('user_name') or '').strip()
            tech_keys = []
            try:
                c_sup = connection.cursor()
                try:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE super = %s
                        """,
                        (sup_name,)
                    )
                except Exception:
                    c_sup.execute(
                        """
                        SELECT id_codigo_consumidor, recurso_operativo_cedula
                        FROM recurso_operativo
                        WHERE supervisor = %s
                        """,
                        (sup_name,)
                    )
                for r0 in c_sup.fetchall() or []:
                    try:
                        if r0[0] is not None:
                            tech_keys.append(str(r0[0]))
                    except Exception:
                        pass
                    try:
                        if r0[1] is not None:
                            tech_keys.append(str(r0[1]))
                    except Exception:
                        pass
                c_sup.close()
            except Exception:
                tech_keys = []
            tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
            if len(tech_keys) == 0:
                return jsonify({'success': True, 'pending': 0})
            placeholders = ','.join(['%s'] * len(tech_keys))
            where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
            params.extend(tech_keys)
        select_parts = [
            f"o.`{col_ext}` AS tecnico_id"
        ]
        if col_cierre_super:
            select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
        if col_tip_super_1:
            select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
        if col_tip_super_2:
            select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
        if col_fecha_gestion_super:
            select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
        sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
        if where:
            sql += " WHERE " + " AND ".join(where)
        cur = connection.cursor(dictionary=True)
        cur.execute(sql, tuple(params))
        rows = cur.fetchall() or []
        pending = 0
        for r in rows:
            done = False
            val_cierre = r.get('cierre_super')
            if val_cierre is not None:
                try:
                    done = int(val_cierre) == 1
                except Exception:
                    done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
            if not done and r.get('fecha_gestion_super'):
                done = True
            if not done:
                tip1 = r.get('tip_super_1')
                tip2 = r.get('tip_super_2')
                tip2_norm = str(tip2 or '').strip().lower()
                pending2 = (
                    tip2_norm == 'en predio' or
                    tip2_norm == 'cliente no atiende' or
                    tip2_norm == 'reprogramar' or
                    ('reprogramar' in tip2_norm) or
                    ('cliente no atiende' in tip2_norm)
                )
                if tip2 and str(tip2).strip():
                    done = not pending2
                elif tip1 and str(tip1).strip():
                    done = True
            if not done:
                pending += 1
        cur.close(); connection.close()
        return jsonify({'success': True, 'pending': pending})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica')
@login_required(role='logistica')
def logistica_dashboard():
    # Verificar stock bajo para mostrar alertas
    materiales_problematicos = verificar_stock_bajo()
    return render_template('modulos/logistica/dashboard.html', materiales_problematicos=materiales_problematicos)

@app.route('/contabilidad')
@login_required(role='contabilidad')
def contabilidad_dashboard():
    return render_template('modulos/contabilidad/dashboard.html')

@app.route('/admin/buscar_usuarios', methods=['POST'])
@login_required(role='administrativo')
def buscar_usuarios():
    search_query = request.form.get('search_query', '')
    search_type = request.form.get('search_type', 'cedula')
    role = request.form.get('role', '')
    sort = request.form.get('sort', 'cedula')
    
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir la consulta SQL base
        query = """
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                id_roles,
                estado
            FROM recurso_operativo
            WHERE 1=1
        """
        params = []
        
        # Aplicar filtros de búsqueda
        if search_query:
            if search_type == 'cedula':
                query += " AND recurso_operativo_cedula LIKE %s"
                params.append(f"%{search_query}%")
            elif search_type == 'codigo':
                query += " AND id_codigo_consumidor LIKE %s"
                params.append(f"%{search_query}%")
            elif search_type == 'rol':
                query += " AND id_roles = %s"
                role_id = next((k for k, v in ROLES.items() if v.lower() == search_query.lower()), None)
                if role_id:
                    params.append(role_id)
        
        if role:
            role_id = next((k for k, v in ROLES.items() if v == role), None)
            if role_id:
                query += " AND id_roles = %s"
                params.append(role_id)
        
        # Aplicar ordenamiento
        if sort == 'cedula':
            query += " ORDER BY recurso_operativo_cedula"
        
        cursor.execute(query, params)
        users = cursor.fetchall()
        
        # Formatear resultados
        formatted_users = []
        for user in users:
            formatted_users.append({
                'id_codigo_consumidor': user['id_codigo_consumidor'],
                'recurso_operativo_cedula': user['recurso_operativo_cedula'],
                'role': ROLES.get(str(user['id_roles']), 'Desconocido'),
                'estado': user.get('estado', 'Activo')
            })
        
        return jsonify(formatted_users)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/admin/exportar_usuarios_csv', methods=['POST'])
@login_required(role='administrativo')
def exportar_usuarios_csv():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todos los usuarios
        cursor.execute("SELECT id_codigo_consumidor, recurso_operativo_cedula, id_roles, estado FROM recurso_operativo")
        users = cursor.fetchall()
        
        # Crear archivo CSV en memoria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escribir encabezados
        writer.writerow(['Código', 'Cédula', 'Rol', 'Estado'])
        
        # Escribir datos
        for user in users:
            writer.writerow([
                user['id_codigo_consumidor'],
                user['recurso_operativo_cedula'],
                ROLES.get(str(user['id_roles']), 'Desconocido'),
                user.get('estado', 'Activo')
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8')),
            mimetype='text/csv',
            as_attachment=True,
            download_name=f'usuarios_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/admin/estadisticas_usuarios')
@login_required(role='administrativo')
def estadisticas_usuarios():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener estadísticas por rol
        cursor.execute("""
            SELECT id_roles, COUNT(*) as count
            FROM recurso_operativo
            GROUP BY id_roles
        """)
        role_stats = cursor.fetchall()
        
        role_labels = []
        role_data = []
        for stat in role_stats:
            role_labels.append(ROLES.get(str(stat['id_roles']), 'Desconocido'))
            role_data.append(stat['count'])
        
        # Obtener estadísticas de actividad (últimos 30 días)
        activity_dates = [(datetime.now() - timedelta(days=x)).strftime('%Y-%m-%d') for x in range(30)]
        activity_counts = []
        
        for date in activity_dates:
            cursor.execute("""
                SELECT COUNT(*) as count
                FROM recurso_operativo
                WHERE DATE(created_at) = %s
            """, (date,))
            result = cursor.fetchone()
            activity_counts.append(result['count'] if result else 0)
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'role_labels': role_labels,
            'role_data': role_data,
            'activity_labels': activity_dates[::-1],
            'activity_data': activity_counts[::-1]
        })
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/dashboard')
@login_required()
def dashboard():
    user_role = session.get('user_role')
    if user_role == 'administrativo':
        try:
            connection = get_db_connection()
            if connection is None:
                flash('Error al cargar usuarios. Por favor, inténtelo de nuevo.', 'error')
                return render_template('modulos/administrativo/dashboard.html')
                
            cursor = connection.cursor(dictionary=True)
            
            # Obtener usuarios
            cursor.execute("""
                SELECT 
                    id_codigo_consumidor, 
                    recurso_operativo_cedula, 
                    id_roles,
                    estado,
                    nombre,
                    cargo
                FROM recurso_operativo
            """)
            users = cursor.fetchall()
            
            # Obtener estadísticas
            total_users = len(users)
            total_roles = len(set(user['id_roles'] for user in users))
            active_users = sum(1 for user in users if user.get('estado') == 'Activo')
            
            cursor.close()
            connection.close()
            
            return render_template('modulos/administrativo/dashboard.html',
                                users=users,
                                ROLES=ROLES,
                                total_users=total_users,
                                total_roles=total_roles,
                                active_users=active_users)
                                
        except Error as e:
            flash(f'Error al cargar usuarios: {str(e)}', 'error')
            return render_template('modulos/administrativo/dashboard.html')
    elif user_role in ROLES.values():
        # Manejar redirección específica para cada rol
        if user_role == 'analista':
            return redirect(url_for('analistas_index'))
        else:
            return redirect(url_for(f'{user_role}_dashboard'))
    else:
        flash('No tienes un rol válido asignado.', 'error')
        return redirect(url_for('logout'))

@app.route('/administrativo/preoperacional/excepcion')
@login_required(role='administrativo')
def administrativo_excepcion_preoperacional():
    try:
        fecha_param = request.args.get('fecha')
        if fecha_param:
            try:
                fecha_consulta = datetime.strptime(fecha_param, '%Y-%m-%d').date()
            except ValueError:
                fecha_consulta = datetime.now().date()
        else:
            fecha_consulta = datetime.now().date()

        def ensure_preop_excepciones_table():
            c = None
            conn = get_db_connection()
            if conn is None:
                return
            try:
                c = conn.cursor()
                c.execute(
                    """
                    CREATE TABLE IF NOT EXISTS preoperacional_excepciones (
                        id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        cedula VARCHAR(32),
                        id_codigo_consumidor INT NULL,
                        fecha DATE NOT NULL,
                        fecha_inicio DATE NULL,
                        fecha_fin DATE NULL,
                        supervisor VARCHAR(255) NULL,
                        motivo VARCHAR(255) NULL,
                        activo TINYINT(1) NOT NULL DEFAULT 1,
                        creado_por VARCHAR(64) NULL,
                        creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        INDEX idx_fecha_cedula (fecha, cedula),
                        INDEX idx_fecha_id (fecha, id_codigo_consumidor)
                    )
                    """
                )
                # Asegurar columnas de rango si la tabla existe sin ellas
                try:
                    c.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'preoperacional_excepciones' AND column_name = 'fecha_inicio'")
                    has_inicio = (c.fetchone() or [0])[0]
                    if not has_inicio:
                        c.execute("ALTER TABLE preoperacional_excepciones ADD COLUMN fecha_inicio DATE NULL AFTER fecha")
                    c.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'preoperacional_excepciones' AND column_name = 'fecha_fin'")
                    has_fin = (c.fetchone() or [0])[0]
                    if not has_fin:
                        c.execute("ALTER TABLE preoperacional_excepciones ADD COLUMN fecha_fin DATE NULL AFTER fecha_inicio")
                    # Inicializar rango para registros existentes
                    c.execute("UPDATE preoperacional_excepciones SET fecha_inicio = fecha WHERE fecha_inicio IS NULL")
                    c.execute("UPDATE preoperacional_excepciones SET fecha_fin = fecha WHERE fecha_fin IS NULL")
                except Exception:
                    pass
                try:
                    c.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'recurso_operativo' AND column_name = 'excluido_preoperacional'")
                    has_col = (c.fetchone() or [0])[0]
                    if not has_col:
                        c.execute("ALTER TABLE recurso_operativo ADD COLUMN excluido_preoperacional TINYINT(1) NOT NULL DEFAULT 0")
                except Exception:
                    pass
                conn.commit()
            finally:
                try:
                    if c:
                        c.close()
                    if conn and conn.is_connected():
                        conn.close()
                except Exception:
                    pass

        ensure_preop_excepciones_table()

        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return render_template('modulos/administrativo/excepcion_preoperacional.html', registros=[], fecha=str(fecha_consulta))

        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT 
                a.cedula,
                ro.nombre AS tecnico,
                ro.super AS supervisor,
                ro.carpeta AS carpeta,
                COALESCE(t.nombre_tipificacion, a.carpeta_dia) AS evento,
                DATE(a.fecha_asistencia) AS fecha,
                a.hora_inicio,
                a.estado,
                a.novedad,
                CASE WHEN (IFNULL(ro.excluido_preoperacional, 0) = 1) OR (e.id IS NOT NULL) THEN 1 ELSE 0 END AS excluido,
                ro.id_codigo_consumidor AS id_codigo_consumidor
            FROM asistencia a
            LEFT JOIN recurso_operativo ro ON ro.recurso_operativo_cedula = a.cedula
            LEFT JOIN tipificacion_asistencia t ON t.codigo_tipificacion = a.carpeta_dia
            LEFT JOIN preoperacional_excepciones e ON e.activo = 1 
              AND DATE(a.fecha_asistencia) BETWEEN COALESCE(e.fecha_inicio, e.fecha) AND COALESCE(e.fecha_fin, e.fecha)
              AND (e.cedula = a.cedula OR e.id_codigo_consumidor = ro.id_codigo_consumidor)
            WHERE DATE(a.fecha_asistencia) = %s
              AND a.id_asistencia = (
                SELECT MAX(a2.id_asistencia)
                FROM asistencia a2
                WHERE a2.cedula = a.cedula
                  AND DATE(a2.fecha_asistencia) = DATE(a.fecha_asistencia)
              )
            ORDER BY ro.super, ro.carpeta, ro.nombre
            """,
            (fecha_consulta,)
        )
        registros = cursor.fetchall() or []
        cursor.close()
        connection.close()
        return render_template('modulos/administrativo/excepcion_preoperacional.html', registros=registros, fecha=str(fecha_consulta))
    except Error as e:
        flash(f'Error cargando excepciones: {str(e)}', 'error')
        return render_template('modulos/administrativo/excepcion_preoperacional.html', registros=[], fecha=datetime.now().strftime('%Y-%m-%d'))

@app.route('/administrativo/preoperacional/excepcion/toggle', methods=['POST'])
@login_required(role='administrativo')
def administrativo_preoperacional_excepcion_toggle():
    try:
        data = request.get_json(silent=True) or {}
        cedula = str(data.get('cedula') or '').strip()
        id_codigo_consumidor = data.get('id_codigo_consumidor')
        fecha_raw = str(data.get('fecha') or '').strip()
        fecha_fin_raw = str(data.get('fecha_fin') or '').strip()
        checked = bool(data.get('checked'))
        try:
            fecha_obj = datetime.strptime(fecha_raw, '%Y-%m-%d').date()
        except Exception:
            fecha_obj = get_bogota_datetime().date()
        fecha_fin_obj = None
        if fecha_fin_raw:
            try:
                fecha_fin_obj = datetime.strptime(fecha_fin_raw, '%Y-%m-%d').date()
            except Exception:
                fecha_fin_obj = None
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor()
        # Asegurar columna permanente en recurso_operativo
        try:
            cur.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'recurso_operativo' AND column_name = 'excluido_preoperacional'")
            has_col = (cur.fetchone() or [0])[0]
            if not has_col:
                cur.execute("ALTER TABLE recurso_operativo ADD COLUMN excluido_preoperacional TINYINT(1) NOT NULL DEFAULT 0")
                conn.commit()
        except Exception:
            pass

        # Si se proporciona fecha_fin y se marca excluir, crear/activar excepción por rango
        if checked and fecha_fin_obj and fecha_fin_obj >= fecha_obj:
            try:
                # Asegurar columnas de rango en la tabla de excepciones
                cur.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'preoperacional_excepciones' AND column_name = 'fecha_inicio'")
                has_inicio = (cur.fetchone() or [0])[0]
                if not has_inicio:
                    cur.execute("ALTER TABLE preoperacional_excepciones ADD COLUMN fecha_inicio DATE NULL AFTER fecha")
                cur.execute("SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'preoperacional_excepciones' AND column_name = 'fecha_fin'")
                has_fin = (cur.fetchone() or [0])[0]
                if not has_fin:
                    cur.execute("ALTER TABLE preoperacional_excepciones ADD COLUMN fecha_fin DATE NULL AFTER fecha_inicio")
                # Insertar nueva excepción por rango
                creado_por = str(session.get('recurso_operativo_cedula') or '')
                cur.execute(
                    """
                    INSERT INTO preoperacional_excepciones (cedula, id_codigo_consumidor, fecha, fecha_inicio, fecha_fin, activo, creado_por)
                    VALUES (%s, %s, %s, %s, %s, 1, %s)
                    """,
                    (cedula or None, id_codigo_consumidor or None, fecha_obj, fecha_obj, fecha_fin_obj, creado_por or None)
                )
            except Exception:
                pass
        else:
            # Actualizar bandera permanente (sin rango) o desactivar exclusión
            if id_codigo_consumidor:
                cur.execute(
                    "UPDATE recurso_operativo SET excluido_preoperacional = %s WHERE id_codigo_consumidor = %s",
                    (1 if checked else 0, id_codigo_consumidor)
                )
            elif cedula:
                cur.execute(
                    "UPDATE recurso_operativo SET excluido_preoperacional = %s WHERE recurso_operativo_cedula = %s",
                    (1 if checked else 0, cedula)
                )
            # Si se desmarca, desactivar excepciones que cubran la fecha dada
            if not checked:
                try:
                    cur.execute(
                        """
                        UPDATE preoperacional_excepciones
                        SET activo = 0
                        WHERE (id_codigo_consumidor = %s OR cedula = %s)
                          AND %s BETWEEN COALESCE(fecha_inicio, fecha) AND COALESCE(fecha_fin, fecha)
                        """,
                        (id_codigo_consumidor or None, cedula or None, fecha_obj)
                    )
                except Exception:
                    pass
        conn.commit()
        cur.close()
        conn.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/user/edit/<int:user_id>', methods=['GET', 'POST'])
@login_required(role='administrativo')
def edit_user(user_id):
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return redirect(url_for('dashboard'))

        cursor = connection.cursor(dictionary=True)
        
        if request.method == 'POST':
            # Obtener datos del formulario
            new_role = request.form.get('role_id')
            new_password = request.form.get('password')
            
            # Actualizar rol
            if new_role:
                cursor.execute("""
                    UPDATE recurso_operativo 
                    SET id_roles = %s 
                    WHERE id_codigo_consumidor = %s
                """, (new_role, user_id))
            
            # Actualizar contraseña si se proporcionó una nueva
            if new_password:
                hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt())
                cursor.execute("""
                    UPDATE recurso_operativo 
                    SET recurso_operativo_password = %s 
                    WHERE id_codigo_consumidor = %s
                """, (hashed_password, user_id))
            
            connection.commit()
            flash('Usuario actualizado exitosamente.', 'success')
            return redirect(url_for('dashboard'))
        
        # Obtener datos del usuario para el formulario
        cursor.execute("""
            SELECT id_codigo_consumidor, recurso_operativo_cedula, id_roles 
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (user_id,))
        user = cursor.fetchone()
        
        if not user:
            flash('Usuario no encontrado.', 'error')
            return redirect(url_for('dashboard'))
            
        return jsonify({
            'status': 'success',
            'user': user
        })
        
    except Error as e:
        flash(f'Error al editar usuario: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/user/delete/<int:user_id>', methods=['POST'])
@login_required(role='administrativo')
def delete_user(user_id):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos.'})

        cursor = connection.cursor(dictionary=True)
        
        # Verificar que el usuario existe
        cursor.execute("SELECT id_roles FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
        user = cursor.fetchone()
        
        if not user:
            return jsonify({'status': 'error', 'message': 'Usuario no encontrado.'})
        
        # No permitir eliminar al último usuario administrativo
        if user['id_roles'] == 1:  # rol administrativo
            cursor.execute("SELECT COUNT(*) as admin_count FROM recurso_operativo WHERE id_roles = 1")
            admin_count = cursor.fetchone()['admin_count']
            if (admin_count <= 1):
                return jsonify({
                    'status': 'error',
                    'message': 'No se puede eliminar el último usuario administrativo.'
                })
        
        # Eliminar usuario
        cursor.execute("DELETE FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
        connection.commit()
        
        return jsonify({
            'status': 'success',
            'message': 'Usuario eliminado exitosamente.'
        })
        
    except Error as e:
        return jsonify({
            'status': 'error',
            'message': f'Error al eliminar usuario: {str(e)}'
        })
    finally:
        if connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/create_user', methods=['POST'])
@login_required(role='administrativo')
def create_user():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)
        
        # Obtener datos del formulario
        cedula = request.form.get('recurso_operativo_cedula')  # Nombre corregido según el formulario
        password = request.form.get('password')
        rol = request.form.get('role_id')  # Nombre corregido según el formulario
        estado = request.form.get('estado', 'Activo')  # Por defecto 'Activo'
        nombre = request.form.get('nombre')
        cargo = request.form.get('cargo')
        
        # Obtener los nuevos campos
        carpeta = request.form.get('carpeta')
        cliente = request.form.get('cliente')
        ciudad = request.form.get('ciudad')
        super_valor = request.form.get('super')  # Usando super_valor porque 'super' es palabra reservada

        # Validar datos requeridos
        if not all([cedula, password, rol, nombre]):
            return jsonify({'success': False, 'message': 'Los campos cédula, contraseña, rol y nombre son requeridos'}), 400

        # Verificar si la cédula ya existe
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        if cursor.fetchone():
            return jsonify({'success': False, 'message': 'La cédula ya está registrada'}), 400

        # Encriptar contraseña
        hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

        # Insertar nuevo usuario con los campos adicionales
        cursor.execute("""
            INSERT INTO recurso_operativo 
            (recurso_operativo_cedula, recurso_operativo_password, id_roles, estado, nombre, cargo, carpeta, cliente, ciudad, super)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (cedula, hashed_password.decode('utf-8'), rol, estado, nombre, cargo, carpeta, cliente, ciudad, super_valor))

        connection.commit()
        cursor.close()
        connection.close()

        return jsonify({'success': True, 'message': 'Usuario creado exitosamente'})

    except Error as e:
        return jsonify({'success': False, 'message': f'Error al crear usuario: {str(e)}'}), 500
    
@app.route('/get_user/<int:user_id>')
@login_required(role='administrativo')
def get_user(user_id):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                id_roles,
                estado
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (user_id,))
        
        user = cursor.fetchone()
        
        cursor.close()
        connection.close()

        if not user:
            return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404

        return jsonify(user)

    except Error as e:
        return jsonify({'success': False, 'message': f'Error al obtener usuario: {str(e)}'})
    
@app.route('/update_user', methods=['POST'])
@login_required(role='administrativo')
def update_user():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)
        
        # Obtener datos del formulario
        user_id = request.form.get('id_codigo_consumidor')
        cedula = request.form.get('cedula')
        nombre = request.form.get('nombre')
        password = request.form.get('password')
        rol = request.form.get('rol')
        cargo = request.form.get('cargo')
        estado = request.form.get('estado')

        # Validar datos requeridos
        if not all([user_id, cedula, nombre, rol, cargo, estado]):
            return jsonify({'success': False, 'message': 'Faltan campos requeridos'}), 400

        # Verificar si el usuario existe
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
        if not cursor.fetchone():
            return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404

        # Preparar la consulta de actualización
        update_query = """
            UPDATE recurso_operativo 
            SET recurso_operativo_cedula = %s,
                nombre = %s,
                id_roles = %s,
                cargo = %s,
                estado = %s
        """
        params = [cedula, nombre, rol, cargo, estado]

        # Si se proporciona una nueva contraseña, actualizarla
        if password:
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
            update_query += ", recurso_operativo_password = %s"
            params.append(hashed_password.decode('utf-8'))

        update_query += " WHERE id_codigo_consumidor = %s"
        params.append(user_id)

        # Ejecutar la actualización
        cursor.execute(update_query, params)
        connection.commit()

        cursor.close()
        connection.close()

        return jsonify({'success': True, 'message': 'Usuario actualizado exitosamente'})

    except Error as e:
        return jsonify({'success': False, 'message': f'Error al actualizar usuario: {str(e)}'}), 500

@app.route('/preoperacional', methods=['POST'])
@login_required(role=['tecnicos','operativo'])
def registrar_preoperacional():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos.'}), 500

        cursor = connection.cursor(dictionary=True)
        
        id_codigo_consumidor = session['id_codigo_consumidor']
        fecha_actual = get_bogota_datetime().date()
        
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM preoperacional 
            WHERE id_codigo_consumidor = %s 
            AND DATE(CONVERT_TZ(fecha, '+00:00', '-05:00')) = %s
        """, (id_codigo_consumidor, fecha_actual))
        
        resultado = cursor.fetchone()
        app.logger.info(f"Verificación de registro existente: {resultado}")
        
        if resultado['count'] > 0:
            app.logger.warning(f"Ya existe un registro para el usuario {id_codigo_consumidor} en la fecha {fecha_actual}")
            return jsonify({
                'status': 'error',
                'message': 'Ya has registrado un preoperacional para el día de hoy.'
            }), 400

        try:
            cursor.execute("SELECT cargo FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id_codigo_consumidor,))
            cargo_row = cursor.fetchone()
            cargo_usuario = (cargo_row.get('cargo') if cargo_row else '') or ''
            if cargo_usuario.strip().upper() == 'CONDUCTOR':
                limite_str = '09:00'
            else:
                cursor.execute("""
                    SELECT hora_limite_preoperacional
                    FROM hora_preoperacional 
                    ORDER BY id_hora_preoperacional DESC 
                    LIMIT 1
                """)
                r = cursor.fetchone()
                limite_base = str(r['hora_limite_preoperacional']) if r and r.get('hora_limite_preoperacional') else '10:00:00'
                limite_str = limite_base[:5]
            ahora = get_bogota_datetime()
            h_lim, m_lim = tuple(map(int, limite_str.split(':')))
            if (ahora.hour > h_lim) or (ahora.hour == h_lim and ahora.minute > m_lim):
                return jsonify({'status': 'error', 'message': f'Fuera de horario. Permitido hasta las {limite_str} (hora de Bogotá).'}), 400
        except Exception:
            pass

        # Obtener datos del formulario
        data = {
            'centro_de_trabajo': request.form.get('centro_de_trabajo'),
            'ciudad': request.form.get('ciudad'),
            'supervisor': request.form.get('supervisor'),
            'vehiculo_asistio_operacion': request.form.get('vehiculo_asistio_operacion'),
            'tipo_vehiculo': request.form.get('tipo_vehiculo'),
            'placa_vehiculo': request.form.get('placa_vehiculo'),
            'modelo_vehiculo': request.form.get('modelo_vehiculo'),
            'marca_vehiculo': request.form.get('marca_vehiculo'),
            'licencia_conduccion': request.form.get('licencia_conduccion'),
            'fecha_vencimiento_licencia': request.form.get('fecha_vencimiento_licencia'),
            'fecha_vencimiento_soat': request.form.get('fecha_vencimiento_soat'),
            'fecha_vencimiento_tecnomecanica': request.form.get('fecha_vencimiento_tecnomecanica'),
            'estado_espejos': request.form.get('estado_espejos', 0),
            'bocina_pito': request.form.get('bocina_pito', 0),
            'frenos': request.form.get('frenos', 0),
            'encendido': request.form.get('encendido', 0),
            'estado_bateria': request.form.get('estado_bateria', 0),
            'estado_amortiguadores': request.form.get('estado_amortiguadores', 0),
            'estado_llantas': request.form.get('estado_llantas', 0),
            'kilometraje_actual': request.form.get('kilometraje_actual', 0),
            'luces_altas_bajas': request.form.get('luces_altas_bajas', 0),
            'direccionales_delanteras_traseras': request.form.get('direccionales_delanteras_traseras', 0),
            'elementos_prevencion_seguridad_vial_casco': request.form.get('elementos_prevencion_seguridad_vial_casco', 0),
            'casco_certificado': request.form.get('casco_certificado', 0),
            'casco_identificado': request.form.get('casco_identificado', 0),
            'estado_guantes': request.form.get('estado_guantes', 0),
            'elementos_prevencion_seguridad_vial_coderas': request.form.get('elementos_prevencion_seguridad_vial_coderas', 0),
            'elementos_prevencion_seguridad_vial_rodilleras': request.form.get('elementos_prevencion_seguridad_vial_rodilleras', request.form.get('estado_rodilleras', 0)),
            'elementos_prevencion_seguridad_vial_impermeable': request.form.get('elementos_prevencion_seguridad_vial_impermeable', request.form.get('impermeable', 0)),
            'estado_rodilleras': request.form.get('estado_rodilleras', 0),
            'impermeable': request.form.get('impermeable', 0),
            'observaciones': request.form.get('observaciones', '')
        }

        # Bloqueo por vencimientos (SOAT / Tecnomecánica / Licencia) dentro de 30 días o vencidos
        try:
            vencimientos_detectados = []
            placa_form = data.get('placa_vehiculo')

            # Fecha actual (Bogotá)
            fecha_hoy = get_bogota_datetime().date()

            # Consultar último SOAT por placa
            if placa_form:
                cursor.execute("""
                    SELECT fecha_vencimiento
                    FROM mpa_soat
                    WHERE placa = %s
                    ORDER BY fecha_vencimiento DESC
                    LIMIT 1
                """, (placa_form,))
                soat_row = cursor.fetchone()
                if soat_row and soat_row.get('fecha_vencimiento'):
                    dias_restantes = (soat_row['fecha_vencimiento'].date() - fecha_hoy).days
                    if dias_restantes <= 0:
                        vencimientos_detectados.append({
                            'tipo': 'SOAT',
                            'fecha': soat_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                            'dias_restantes': dias_restantes
                        })

                # Consultar Tecnomecánica por placa
                cursor.execute("""
                    SELECT fecha_vencimiento
                    FROM mpa_tecnico_mecanica
                    WHERE placa = %s
                    ORDER BY fecha_vencimiento DESC
                    LIMIT 1
                """, (placa_form,))
                tm_row = cursor.fetchone()
                if tm_row and tm_row.get('fecha_vencimiento'):
                    dias_restantes = (tm_row['fecha_vencimiento'].date() - fecha_hoy).days
                    if dias_restantes <= 0:
                        vencimientos_detectados.append({
                            'tipo': 'Tecnomecánica',
                            'fecha': tm_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                            'dias_restantes': dias_restantes
                        })

            # Consultar Licencia de Conducir por técnico
            cursor.execute("""
                SELECT fecha_vencimiento
                FROM mpa_licencia_conducir
                WHERE id_codigo_consumidor = %s
                ORDER BY fecha_vencimiento DESC
                LIMIT 1
            """, (id_codigo_consumidor,))
            lic_row = cursor.fetchone()
            if lic_row and lic_row.get('fecha_vencimiento'):
                dias_restantes = (lic_row['fecha_vencimiento'].date() - fecha_hoy).days
                if dias_restantes <= 0:
                    vencimientos_detectados.append({
                        'tipo': 'Licencia de Conducir',
                        'fecha': lic_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                        'dias_restantes': dias_restantes
                    })

            # Si existen vencimientos, bloquear
            if vencimientos_detectados:
                cursor.close()
                connection.close()
                return jsonify({
                    'status': 'error',
                    'message': 'No puedes registrar el preoperacional: tienes documentos vencidos.',
                    'bloqueo_por_vencimientos': True,
                    'vencimientos': vencimientos_detectados
                }), 400
        except Error as e:
            app.logger.error(f"Error validando vencimientos en preoperacional: {str(e)}")
            # No bloquear por error en validación, continuar

        # Verificar que el id_codigo_consumidor existe en la tabla recurso_operativo
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id_codigo_consumidor,))
        usuario_existe = cursor.fetchone()
        app.logger.info(f"Verificación de usuario en recurso_operativo: {usuario_existe}")
        
        if usuario_existe is None:
            app.logger.error(f"Usuario {id_codigo_consumidor} no existe en recurso_operativo")
            return jsonify({
                'status': 'error', 
                'message': 'El id_codigo_consumidor no existe en la tabla recurso_operativo.'
            }), 404

        # VALIDACIÓN CRÍTICA: Verificar si el vehículo tiene mantenimientos abiertos
        placa_vehiculo = data.get('placa_vehiculo')
        if placa_vehiculo:
            app.logger.info(f"Verificando mantenimientos abiertos para vehículo: {placa_vehiculo}")
            cursor.execute("""
                SELECT COUNT(*) FROM mpa_mantenimientos 
                WHERE placa = %s AND estado = 'Abierto'
            """, (placa_vehiculo,))
            
            result = cursor.fetchone()
            mantenimientos_abiertos = result['COUNT(*)'] if result else 0
            app.logger.info(f"Mantenimientos abiertos encontrados: {mantenimientos_abiertos}")
            
            if mantenimientos_abiertos > 0:
                app.logger.warning(f"Bloqueando preoperacional: vehículo {placa_vehiculo} tiene {mantenimientos_abiertos} mantenimiento(s) abierto(s)")
                cursor.close()
                connection.close()
                return jsonify({
                    'status': 'error',
                    'message': f'No se puede completar el preoperacional. El vehículo {placa_vehiculo} tiene {mantenimientos_abiertos} mantenimiento(s) abierto(s) pendiente(s). Contacte al área de MPA para finalizar el mantenimiento antes de continuar.',
                    'tiene_mantenimientos_abiertos': True,
                    'placa': placa_vehiculo,
                    'mantenimientos_abiertos': mantenimientos_abiertos
                }), 400

        # Validación de kilometraje antes de insertar
        placa_vehiculo = data.get('placa_vehiculo')
        try:
            kilometraje_propuesto = int(data.get('kilometraje_actual') or 0)
        except Exception:
            kilometraje_propuesto = 0

        ultimo_kilometraje = 0
        fecha_ultimo_registro = None
        if placa_vehiculo:
            placa_norm_insert = (placa_vehiculo or '').strip().upper().replace('-', '').replace(' ', '')
            cursor.execute("""
                SELECT kilometraje_actual, fecha
                FROM preoperacional
                WHERE UPPER(REPLACE(REPLACE(TRIM(placa_vehiculo), '-', ''), ' ', '')) = %s
                ORDER BY fecha DESC
                LIMIT 1
            """, (placa_norm_insert,))
            ultimo_registro = cursor.fetchone()
            if ultimo_registro:
                ultimo_kilometraje = ultimo_registro['kilometraje_actual'] or 0
                fecha_ultimo_registro = ultimo_registro['fecha']

        # Bloquear si supera 1,000,000 km
        if kilometraje_propuesto > 1000000:
            return jsonify({
                'status': 'error',
                'message': f'El kilometraje no puede superar los 1,000,000 km. Último kilometraje registrado: {ultimo_kilometraje} km'
            }), 400

        # Bloquear si es menor que el último registrado
        if ultimo_kilometraje and kilometraje_propuesto < ultimo_kilometraje:
            return jsonify({
                'status': 'error',
                'message': f'El kilometraje no puede ser menor al último registrado: {ultimo_kilometraje} km en fecha {fecha_ultimo_registro.strftime("%d/%m/%Y") if fecha_ultimo_registro else "N/A"}'
            }), 400

        # Construir la consulta SQL dinámicamente
        columns = list(data.keys()) + ['id_codigo_consumidor']
        values = list(data.values()) + [id_codigo_consumidor]
        placeholders = ['%s'] * len(columns)

        sql = f"""
            INSERT INTO preoperacional (
                {', '.join(columns)}, fecha
            ) VALUES (
                {', '.join(placeholders)}, %s
            )
        """
        
        # Agregar la fecha actual de Bogotá a los valores
        fecha_bogota = get_bogota_datetime()
        values.append(fecha_bogota)
        
        app.logger.info(f"SQL a ejecutar: {sql}")
        app.logger.info(f"Valores a insertar: {values}")
        app.logger.info(f"Fecha de Bogotá: {fecha_bogota}")
        
        cursor.execute(sql, tuple(values))
        app.logger.info("SQL ejecutado exitosamente")
        
        connection.commit()
        app.logger.info("Transacción confirmada (commit)")
        cursor.close()
        connection.close()

        return jsonify({
            'status': 'success',
            'message': 'Preoperacional registrado exitosamente'
        })
        
    except Error as e:
        if connection and connection.is_connected():
            cursor.close()
            connection.close()
        return jsonify({
            'status': 'error',
            'message': f'Error al registrar preoperacional: {str(e)}'
        }), 500

@app.route('/preoperacional_operativo', methods=['POST'])
@login_required(role=['operativo'])
def registrar_preoperacional_operativo():
    try:
        # Debug: Log de inicio de función
        app.logger.info("=== INICIO registrar_preoperacional_operativo ===")
        
        # Debug: Log de todos los datos recibidos
        app.logger.info(f"Datos del formulario recibidos: {dict(request.form)}")
        
        connection = get_db_connection()
        if connection is None:
            app.logger.error("Error: No se pudo establecer conexión a la base de datos")
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos.'}), 500

        cursor = connection.cursor(dictionary=True)
        
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        app.logger.info(f"ID código consumidor: {id_codigo_consumidor}")
        
        fecha_actual = get_bogota_datetime().date()
        app.logger.info(f"Fecha actual (Bogotá): {fecha_actual}")
        
        cursor.execute("""
            SELECT COUNT(*) as count 
            FROM preoperacional 
            WHERE id_codigo_consumidor = %s 
            AND DATE(CONVERT_TZ(fecha, '+00:00', '-05:00')) = %s
        """, (id_codigo_consumidor, fecha_actual))
        
        resultado = cursor.fetchone()
        if resultado['count'] > 0:
            return jsonify({
                'status': 'error',
                'message': 'Ya has registrado un preoperacional para el día de hoy.'
            }), 400

        try:
            cursor.execute("SELECT cargo FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id_codigo_consumidor,))
            cargo_row = cursor.fetchone()
            cargo_usuario = (cargo_row.get('cargo') if cargo_row else '') or ''
            if cargo_usuario.strip().upper() == 'CONDUCTOR':
                limite_str = '09:00'
            else:
                cursor.execute("""
                    SELECT hora_limite_preoperacional
                    FROM hora_preoperacional 
                    ORDER BY id_hora_preoperacional DESC 
                    LIMIT 1
                """)
                r = cursor.fetchone()
                limite_base = str(r['hora_limite_preoperacional']) if r and r.get('hora_limite_preoperacional') else '10:00:00'
                limite_str = limite_base[:5]
            ahora = get_bogota_datetime()
            h_lim, m_lim = tuple(map(int, limite_str.split(':')))
            if (ahora.hour > h_lim) or (ahora.hour == h_lim and ahora.minute > m_lim):
                return jsonify({'status': 'error', 'message': f'Fuera de horario. Permitido hasta las {limite_str} (hora de Bogotá).'}), 400
        except Exception:
            pass

        # Obtener datos del formulario
        data = {
            'centro_de_trabajo': request.form.get('centro_de_trabajo'),
            'ciudad': request.form.get('ciudad'),
            'supervisor': request.form.get('supervisor'),
            'vehiculo_asistio_operacion': request.form.get('vehiculo_asistio_operacion'),
            'tipo_vehiculo': request.form.get('tipo_vehiculo'),
            'placa_vehiculo': request.form.get('placa_vehiculo'),
            'modelo_vehiculo': request.form.get('modelo_vehiculo'),
            'marca_vehiculo': request.form.get('marca_vehiculo'),
            'licencia_conduccion': request.form.get('licencia_conduccion'),
            'fecha_vencimiento_licencia': request.form.get('fecha_vencimiento_licencia'),
            'fecha_vencimiento_soat': request.form.get('fecha_vencimiento_soat'),
            'fecha_vencimiento_tecnomecanica': request.form.get('fecha_vencimiento_tecnomecanica'),
            'estado_espejos': request.form.get('estado_espejos', 0),
            'bocina_pito': request.form.get('bocina_pito', 0),
            'frenos': request.form.get('frenos', 0),
            'encendido': request.form.get('encendido', 0),
            'estado_bateria': request.form.get('estado_bateria', 0),
            'estado_amortiguadores': request.form.get('estado_amortiguadores', 0),
            'estado_llantas': request.form.get('estado_llantas', 0),
            'kilometraje_actual': request.form.get('kilometraje_actual', 0),
            'luces_altas_bajas': request.form.get('luces_altas_bajas', 0),
            'direccionales_delanteras_traseras': request.form.get('direccionales_delanteras_traseras', 0),
            'elementos_prevencion_seguridad_vial_casco': request.form.get('elementos_prevencion_seguridad_vial_casco', 0),
            'casco_certificado': request.form.get('casco_certificado', 0),
            'casco_identificado': request.form.get('casco_identificado', 0),
            'estado_guantes': request.form.get('estado_guantes', 0),
            'elementos_prevencion_seguridad_vial_coderas': request.form.get('elementos_prevencion_seguridad_vial_coderas', 0),
            'elementos_prevencion_seguridad_vial_rodilleras': request.form.get('elementos_prevencion_seguridad_vial_rodilleras', request.form.get('estado_rodilleras', 0)),
            'elementos_prevencion_seguridad_vial_impermeable': request.form.get('elementos_prevencion_seguridad_vial_impermeable', request.form.get('impermeable', 0)),
            'estado_rodilleras': request.form.get('estado_rodilleras', 0),
            'impermeable': request.form.get('impermeable', 0),
            'observaciones': request.form.get('observaciones', '')
        }

        # Bloqueo por vencimientos (SOAT / Tecnomecánica / Licencia) dentro de 30 días o vencidos
        try:
            vencimientos_detectados = []
            placa_form = data.get('placa_vehiculo')

            # Fecha actual (Bogotá)
            fecha_hoy = get_bogota_datetime().date()

            # Consultar último SOAT por placa
            if placa_form:
                cursor.execute("""
                    SELECT fecha_vencimiento
                    FROM mpa_soat
                    WHERE placa = %s
                    ORDER BY fecha_vencimiento DESC
                    LIMIT 1
                """, (placa_form,))
                soat_row = cursor.fetchone()
                if soat_row and soat_row.get('fecha_vencimiento'):
                    dias_restantes = (soat_row['fecha_vencimiento'].date() - fecha_hoy).days
                    if dias_restantes <= 0:
                        vencimientos_detectados.append({
                            'tipo': 'SOAT',
                            'fecha': soat_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                            'dias_restantes': dias_restantes
                        })

                # Consultar Tecnomecánica por placa
                cursor.execute("""
                    SELECT fecha_vencimiento
                    FROM mpa_tecnico_mecanica
                    WHERE placa = %s
                    ORDER BY fecha_vencimiento DESC
                    LIMIT 1
                """, (placa_form,))
                tm_row = cursor.fetchone()
                if tm_row and tm_row.get('fecha_vencimiento'):
                    dias_restantes = (tm_row['fecha_vencimiento'].date() - fecha_hoy).days
                    if dias_restantes <= 0:
                        vencimientos_detectados.append({
                            'tipo': 'Tecnomecánica',
                            'fecha': tm_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                            'dias_restantes': dias_restantes
                        })

            # Consultar Licencia de Conducir por operativo (id_codigo_consumidor de la petición)
            cursor.execute("""
                SELECT fecha_vencimiento
                FROM mpa_licencia_conducir
                WHERE id_codigo_consumidor = %s
                ORDER BY fecha_vencimiento DESC
                LIMIT 1
            """, (id_codigo_consumidor,))
            lic_row = cursor.fetchone()
            if lic_row and lic_row.get('fecha_vencimiento'):
                dias_restantes = (lic_row['fecha_vencimiento'].date() - fecha_hoy).days
                if dias_restantes <= 0:
                    vencimientos_detectados.append({
                        'tipo': 'Licencia de Conducir',
                        'fecha': lic_row['fecha_vencimiento'].strftime('%Y-%m-%d'),
                        'dias_restantes': dias_restantes
                    })

            # Si existen vencimientos, bloquear
            if vencimientos_detectados:
                return jsonify({
                    'status': 'error',
                    'message': 'No puedes registrar el preoperacional: tienes documentos vencidos.',
                    'bloqueo_por_vencimientos': True,
                    'vencimientos': vencimientos_detectados
                }), 400
        except Error as e:
            app.logger.error(f"Error validando vencimientos en preoperacional operativo: {str(e)}")
            # No bloquear por error en validación, continuar

        # Verificar que el id_codigo_consumidor existe en la tabla recurso_operativo
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id_codigo_consumidor,))
        if cursor.fetchone() is None:
            return jsonify({
                'status': 'error', 
                'message': 'El id_codigo_consumidor no existe en la tabla recurso_operativo.'
            }), 404

        # Validación de kilometraje contra último registro
        placa_form = request.form.get('placa_vehiculo')
        km_actual_str = request.form.get('kilometraje_actual')
        try:
            km_actual = int(km_actual_str) if km_actual_str is not None and km_actual_str != '' else 0
        except ValueError:
            # Cerrar recursos antes de responder
            cursor.close()
            connection.close()
            return jsonify({
                'status': 'error',
                'message': 'El kilometraje debe ser un número entero.'
            }), 400

        if km_actual < 0:
            cursor.close()
            connection.close()
            return jsonify({
                'status': 'error',
                'message': 'El kilometraje no puede ser negativo.'
            }), 400

        if not placa_form:
            cursor.close()
            connection.close()
            return jsonify({
                'status': 'error',
                'message': 'La placa del vehículo es requerida para validar el kilometraje.'
            }), 400

        # Normalizar placa para comparación robusta
        placa_form_normalizada = (placa_form or '').strip().upper().replace('-', '').replace(' ', '')
        cursor.execute(
            """
            SELECT kilometraje_actual, fecha
            FROM capired.preoperacional
            WHERE UPPER(REPLACE(REPLACE(TRIM(placa_vehiculo), '-', ''), ' ', '')) = %s
            ORDER BY fecha DESC
            LIMIT 1
            """,
            (placa_form_normalizada,)
        )
        ultimo_registro_km = cursor.fetchone()

        if ultimo_registro_km:
            ultimo_km = int(ultimo_registro_km.get('kilometraje_actual') or 0)
            fecha_ultimo = ultimo_registro_km.get('fecha')
            if km_actual < ultimo_km:
                cursor.close()
                connection.close()
                return jsonify({
                    'status': 'error',
                    'message': f'El kilometraje no puede ser menor al último registrado: {ultimo_km} km' + (f" en fecha {fecha_ultimo.strftime('%d/%m/%Y')}" if fecha_ultimo else ''),
                    'ultimo_kilometraje': ultimo_km
                }), 400

        if km_actual > 1000000:
            cursor.close()
            connection.close()
            return jsonify({
                'status': 'error',
                'message': 'El kilometraje no puede superar los 1,000,000 km.'
            }), 400

        # Construir la consulta SQL dinámicamente
        columns = list(data.keys()) + ['id_codigo_consumidor']
        values = list(data.values()) + [id_codigo_consumidor]
        placeholders = ['%s'] * len(columns)

        sql = f"""
            INSERT INTO preoperacional (
                {', '.join(columns)}, fecha
            ) VALUES (
                {', '.join(placeholders)}, %s
            )
        """
        
        # Agregar la fecha actual de Bogotá a los valores
        values.append(get_bogota_datetime())
        
        cursor.execute(sql, tuple(values))
        connection.commit()
        cursor.close()
        connection.close()
        
        app.logger.info("=== Preoperacional registrado exitosamente ===")

        # Devolver respuesta JSON con redirección para que el frontend la maneje
        return jsonify({
            'status': 'success',
            'message': 'Preoperacional registrado exitosamente',
            'redirect_url': '/operativo'
        }) 
        
    except Error as e:
        app.logger.error(f"Error de MySQL: {str(e)}")
        app.logger.error(f"Tipo de error: {type(e)}")
        if 'connection' in locals() and connection and connection.is_connected():
            connection.rollback()
            cursor.close()
            connection.close()
        return jsonify({
            'status': 'error',
            'message': f'Error de base de datos: {str(e)}'
        }), 500
    except Exception as e:
        app.logger.error(f"Error general: {str(e)}")
        app.logger.error(f"Tipo de error: {type(e)}")
        if 'connection' in locals() and connection and connection.is_connected():
            connection.rollback()
            cursor.close()
            connection.close()
        return jsonify({
            'status': 'error',
            'message': f'Error interno del servidor: {str(e)}'
        }), 500

@app.route('/check_submission', methods=['GET'])
def check_submission():
    user_id = request.args.get('user_id')
    submission_date = request.args.get('date')
    
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'submitted': False, 'error': 'Database connection failed.'})

        cursor = connection.cursor(dictionary=True)
        query = """
            SELECT 1 FROM preoperacional 
            WHERE id_codigo_consumidor = %s AND DATE(fecha_creacion) = %s
        """
        cursor.execute(query, (user_id, submission_date))
        submission_exists = cursor.fetchone() is not None

        cursor.close()
        connection.close()

        return jsonify({'submitted': submission_exists})
    except Error as e:
        return jsonify({'submitted': False, 'error': str(e)})

@app.route('/preoperacional/listado')
@login_required(role='administrativo')
def listado_preoperacional():
    try:
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor = request.args.get('supervisor')
        estado_vehiculo = request.args.get('estado_vehiculo')
        
        # Si no se proporcionan filtros de fecha, usar la fecha actual por defecto
        if not fecha_inicio and not fecha_fin:
            fecha_actual = datetime.now().strftime('%Y-%m-%d')
            fecha_inicio = fecha_actual
            fecha_fin = fecha_actual
        
        # Parámetro de paginación
        pagina = request.args.get('pagina', 1, type=int)
        registros_por_pagina = 10

        conn = get_db_connection()
        cur = conn.cursor(dictionary=True)

        # Construir la cláusula WHERE dinámica
        where_clauses = []
        params = []

        if fecha_inicio:
            where_clauses.append("fecha >= %s")
            params.append(fecha_inicio)
        if fecha_fin:
            where_clauses.append("fecha <= %s")
            params.append(fecha_fin + " 23:59:59")
        if supervisor:
            where_clauses.append("supervisor = %s")
            params.append(supervisor)
        
        # Agregar filtro por estado del vehículo
        if estado_vehiculo:
            if estado_vehiculo == 'bueno':
                where_clauses.append("(estado_espejos + bocina_pito + frenos + encendido + estado_bateria + estado_amortiguadores + estado_llantas + luces_altas_bajas + direccionales_delanteras_traseras) = 9")
            elif estado_vehiculo == 'regular':
                where_clauses.append("(estado_espejos + bocina_pito + frenos + encendido + estado_bateria + estado_amortiguadores + estado_llantas + luces_altas_bajas + direccionales_delanteras_traseras) >= 5")
                where_clauses.append("(estado_espejos + bocina_pito + frenos + encendido + estado_bateria + estado_amortiguadores + estado_llantas + luces_altas_bajas + direccionales_delanteras_traseras) < 9")
            elif estado_vehiculo == 'malo':
                where_clauses.append("(estado_espejos + bocina_pito + frenos + encendido + estado_bateria + estado_amortiguadores + estado_llantas + luces_altas_bajas + direccionales_delanteras_traseras) < 5")

        # Construir la consulta SQL completa
        query = """
            SELECT p.*, r.nombre as nombre_tecnico, r.cargo as cargo_tecnico,
                   (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                    estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                    direccionales_delanteras_traseras) as estado_total,
                   CASE 
                       WHEN (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                            estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                            direccionales_delanteras_traseras) = 9 THEN 'Bueno'
                       WHEN (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                            estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                            direccionales_delanteras_traseras) >= 5 THEN 'Regular'
                       ELSE 'Malo'
                   END as estado_vehiculo
            FROM preoperacional p
            LEFT JOIN recurso_operativo r ON p.id_codigo_consumidor = r.id_codigo_consumidor
        """
        
        if where_clauses:
            query += " WHERE " + " AND ".join(where_clauses)
        
        query += " ORDER BY p.fecha DESC"
        
        cur.execute(query, params)
        registros = cur.fetchall()

        # Calcular paginación
        total_registros = len(registros)
        total_paginas = (total_registros + registros_por_pagina - 1) // registros_por_pagina
        
        # Ajustar página actual si está fuera de rango
        if pagina < 1:
            pagina = 1
        elif pagina > total_paginas and total_paginas > 0:
            pagina = total_paginas
        
        # Obtener registros de la página actual
        inicio = (pagina - 1) * registros_por_pagina
        fin = inicio + registros_por_pagina
        pagina_actual = registros[inicio:fin]

        # Obtener lista de supervisores únicos
        cur.execute("""
            SELECT DISTINCT supervisor 
            FROM preoperacional 
            WHERE supervisor IS NOT NULL 
            AND supervisor != '' 
            ORDER BY supervisor
        """)
        supervisores = [row['supervisor'] for row in cur.fetchall()]

        # Calcular estadísticas básicas
        registros_hoy = sum(1 for r in registros if r['fecha'].date() == datetime.now().date())
        registros_semana = sum(1 for r in registros if r['fecha'].date() >= (datetime.now() - timedelta(days=7)).date())
        registros_mes = sum(1 for r in registros if r['fecha'].date() >= (datetime.now() - timedelta(days=30)).date())

        # Preparar datos para el gráfico de tendencias
        fechas = []
        registros_por_dia = []
        if registros:
            fecha_actual = datetime.now().date()
            for i in range(7):
                fecha = fecha_actual - timedelta(days=i)
                fechas.append(fecha.strftime('%Y-%m-%d'))
                registros_por_dia.append(sum(1 for r in registros if r['fecha'].date() == fecha))
            fechas.reverse()
            registros_por_dia.reverse()

        # ESTADÍSTICAS ADICIONALES

        # 1. Distribución por tipo de vehículo
        tipos_vehiculo = {}
        for r in registros:
            tipo = r['tipo_vehiculo'] or 'No especificado'
            if tipo in tipos_vehiculo:
                tipos_vehiculo[tipo] += 1
            else:
                tipos_vehiculo[tipo] = 1
        
        # Ordenar por cantidad y tomar los 5 principales
        tipos_vehiculo_top = sorted(tipos_vehiculo.items(), key=lambda x: x[1], reverse=True)[:5]
        labels_tipo_vehiculo = [t[0] for t in tipos_vehiculo_top]
        datos_tipo_vehiculo = [t[1] for t in tipos_vehiculo_top]

        # 2. Top 5 técnicos con más registros
        tecnicos = {}
        for r in registros:
            tecnico = r['nombre_tecnico'] or 'No especificado'
            if tecnico in tecnicos:
                tecnicos[tecnico] += 1
            else:
                tecnicos[tecnico] = 1
        
        tecnicos_top = sorted(tecnicos.items(), key=lambda x: x[1], reverse=True)[:5]
        labels_tecnicos = [t[0] for t in tecnicos_top]
        datos_tecnicos = [t[1] for t in tecnicos_top]

        # 3. Top 5 centros de trabajo con más registros
        centros_trabajo = {}
        for r in registros:
            centro = r['centro_de_trabajo'] or 'No especificado'
            if centro in centros_trabajo:
                centros_trabajo[centro] += 1
            else:
                centros_trabajo[centro] = 1
        
        centros_top = sorted(centros_trabajo.items(), key=lambda x: x[1], reverse=True)[:5]
        labels_centros = [c[0] for c in centros_top]
        datos_centros = [c[1] for c in centros_top]

        # 4. Elementos críticos en mal estado (conteo)
        elementos_mal_estado = {
            'Frenos': sum(1 for r in registros if r.get('frenos') == '0'),
            'Luces': sum(1 for r in registros if r.get('luces_altas_bajas') == '0'),
            'Direccionales': sum(1 for r in registros if r.get('direccionales_delanteras_traseras') == '0'),
            'Espejos': sum(1 for r in registros if r.get('estado_espejos') == '0'),
            'Llantas': sum(1 for r in registros if r.get('estado_llantas') == '0')
        }
        
        labels_elementos = list(elementos_mal_estado.keys())
        datos_elementos = list(elementos_mal_estado.values())

        # 5. Distribución por ciudad
        ciudades = {}
        for r in registros:
            ciudad = r['ciudad'] or 'No especificado'
            if ciudad in ciudades:
                ciudades[ciudad] += 1
            else:
                ciudades[ciudad] = 1
        
        ciudades_top = sorted(ciudades.items(), key=lambda x: x[1], reverse=True)[:5]
        labels_ciudades = [c[0] for c in ciudades_top]
        datos_ciudades = [c[1] for c in ciudades_top]

        # 6. Comparativa mes actual vs mes anterior
        fecha_actual = datetime.now().date()
        primer_dia_mes_actual = fecha_actual.replace(day=1)
        ultimo_dia_mes_anterior = primer_dia_mes_actual - timedelta(days=1)
        primer_dia_mes_anterior = ultimo_dia_mes_anterior.replace(day=1)
        
        registros_mes_actual = sum(1 for r in registros if r['fecha'].date() >= primer_dia_mes_actual)
        registros_mes_anterior = sum(1 for r in registros if r['fecha'].date() >= primer_dia_mes_anterior and r['fecha'].date() < primer_dia_mes_actual)
        
        comparativa_meses = {
            'labels': [primer_dia_mes_anterior.strftime('%B %Y'), primer_dia_mes_actual.strftime('%B %Y')],
            'datos': [registros_mes_anterior, registros_mes_actual]
        }

        cur.close()
        conn.close()

        return render_template('modulos/administrativo/listado_preoperacional.html', 
                            registros=registros,
                            pagina_actual=pagina_actual,
                            pagina_actual_num=pagina,
                            total_paginas=total_paginas,
                            total_registros=total_registros,
                            supervisores=supervisores,
                            fecha_inicio=fecha_inicio,
                            fecha_fin=fecha_fin,
                            fecha_actual=datetime.now().strftime('%Y-%m-%d'),
                            supervisor=supervisor,
                            estado_vehiculo=estado_vehiculo,
                            registros_hoy=registros_hoy,
                            registros_semana=registros_semana,
                            registros_mes=registros_mes,
                            fechas=fechas,
                            registros_por_dia=registros_por_dia,
                            # Nuevas estadísticas
                            labels_tipo_vehiculo=labels_tipo_vehiculo,
                            datos_tipo_vehiculo=datos_tipo_vehiculo,
                            labels_tecnicos=labels_tecnicos,
                            datos_tecnicos=datos_tecnicos,
                            labels_centros=labels_centros,
                            datos_centros=datos_centros,
                            labels_elementos=labels_elementos,
                            datos_elementos=datos_elementos,
                            labels_ciudades=labels_ciudades,
                            datos_ciudades=datos_ciudades,
                            comparativa_meses=comparativa_meses)

    except Exception as e:
        flash('Error al cargar el listado preoperacional: ' + str(e), 'error')
        return render_template('modulos/administrativo/listado_preoperacional.html',
                            registros=[],
                            pagina_actual=[],
                            pagina_actual_num=1,
                            total_paginas=0,
                            supervisores=[],
                            fecha_inicio=fecha_inicio,
                            fecha_fin=fecha_fin,
                            supervisor=supervisor,
                            estado_vehiculo=estado_vehiculo,
                            total_registros=0,
                            registros_hoy=0,
                            registros_semana=0,
                            registros_mes=0,
                            fechas=[],
                            registros_por_dia=[],
                            # Valores vacíos para nuevas estadísticas
                            labels_tipo_vehiculo=[],
                            datos_tipo_vehiculo=[],
                            labels_tecnicos=[],
                            datos_tecnicos=[],
                            labels_centros=[],
                            datos_centros=[],
                            labels_elementos=[],
                            datos_elementos=[],
                            labels_ciudades=[],
                            datos_ciudades=[],
                            comparativa_meses={'labels': [], 'datos': []})

@app.route('/preoperacional/exportar_csv')
@login_required(role='administrativo')
def exportar_preoperacional_csv():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener parámetros de filtro
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor = request.args.get('supervisor')
        
        # Construir la cláusula WHERE base
        where_clauses = []
        params = []
        
        if fecha_inicio:
            where_clauses.append("DATE(p.fecha) >= %s")
            params.append(fecha_inicio)
        if fecha_fin:
            where_clauses.append("DATE(p.fecha) <= %s")
            params.append(fecha_fin)
        if supervisor:
            where_clauses.append("p.supervisor = %s")
            params.append(supervisor)
            
        where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
        
        # Obtener registros preoperacionales con información del usuario y filtros aplicados
        query = f"""
            SELECT 
                p.*,
                r.nombre as nombre_tecnico,
                r.cargo as cargo_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico
            FROM preoperacional p
            JOIN recurso_operativo r ON p.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE {where_sql}
            ORDER BY p.fecha DESC
        """
        cursor.execute(query, params)
        registros = cursor.fetchall()
        cursor.close()
        connection.close()
        
        # Crear archivo CSV en memoria con codificación UTF-8-SIG (con BOM)
        output = io.StringIO()
        # Usar csv.excel con delimitador explícito para garantizar correcta separación de columnas
        writer = csv.writer(output, delimiter=',', quotechar='"', quoting=csv.QUOTE_ALL)
        
        # Escribir el BOM de UTF-8
        output.write('\ufeff')
        
        # Escribir encabezados
        writer.writerow([
            'Fecha', 'Técnico', 'Cédula', 'Cargo', 'Centro de Trabajo', 'Ciudad', 'Supervisor',
            'Vehículo Asistió', 'Tipo Vehículo', 'Placa', 'Modelo', 'Marca',
            'Licencia Conducción', 'Vencimiento Licencia', 'Vencimiento SOAT',
            'Vencimiento Tecnomecánica', 'Estado Espejos', 'Bocina/Pito',
            'Frenos', 'Encendido', 'Batería', 'Amortiguadores', 'Llantas',
            'Kilometraje', 'Luces Altas/Bajas', 'Direccionales',
            'Elementos Prevención Casco', 'Casco Certificado', 'Casco Identificado',
            'Estado Guantes', 'Estado Rodilleras', 'Coderas', 'Impermeable', 'Observaciones'
        ])
        
        # Escribir datos
        for registro in registros:
            # Convertir fechas a cadena o valor nulo para evitar errores
            fecha_lic = registro['fecha_vencimiento_licencia'].strftime('%Y-%m-%d') if registro['fecha_vencimiento_licencia'] else ''
            fecha_soat = registro['fecha_vencimiento_soat'].strftime('%Y-%m-%d') if registro['fecha_vencimiento_soat'] else ''
            fecha_tec = registro['fecha_vencimiento_tecnomecanica'].strftime('%Y-%m-%d') if registro['fecha_vencimiento_tecnomecanica'] else ''
            
            writer.writerow([
                registro['fecha'].strftime('%Y-%m-%d %H:%M:%S'),
                registro['nombre_tecnico'],
                registro['cedula_tecnico'],
                registro['cargo_tecnico'],
                registro['centro_de_trabajo'] or '',
                registro['ciudad'] or '',
                registro['supervisor'] or '',
                registro['vehiculo_asistio_operacion'] or '',
                registro['tipo_vehiculo'] or '',
                registro['placa_vehiculo'] or '',
                registro['modelo_vehiculo'] or '',
                registro['marca_vehiculo'] or '',
                registro['licencia_conduccion'] or '',
                fecha_lic,
                fecha_soat,
                fecha_tec,
                registro['estado_espejos'] or '',
                registro['bocina_pito'] or '',
                registro['frenos'] or '',
                registro['encendido'] or '',
                registro['estado_bateria'] or '',
                registro['estado_amortiguadores'] or '',
                registro['estado_llantas'] or '',
                registro['kilometraje_actual'] or '',
                registro['luces_altas_bajas'] or '',
                registro['direccionales_delanteras_traseras'] or '',
                registro['elementos_prevencion_seguridad_vial_casco'] or '',
                registro['casco_certificado'] or '',
                registro['casco_identificado'] or '',
                registro['estado_guantes'] or '',
                registro['estado_rodilleras'] or '',
                registro.get('elementos_prevencion_seguridad_vial_coderas','') or '',
                registro['impermeable'] or '',
                registro['observaciones'] or ''
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8-sig')),  # Usar UTF-8 con BOM
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'preoperacional_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/admin/reportes')
@login_required(role='administrativo')
def admin_reportes():
    return render_template('modulos/administrativo/reportes/dashboard_reportes.html')

@app.route('/api/reportes/usuarios')
@login_required(role='administrativo')
def api_reportes_usuarios():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Estadísticas generales de usuarios
        cursor.execute("""
            SELECT 
                COUNT(*) as total_usuarios,
                SUM(CASE WHEN estado = 'Activo' THEN 1 ELSE 0 END) as usuarios_activos,
                id_roles,
                COUNT(*) as cantidad
            FROM recurso_operativo
            GROUP BY id_roles
        """)
        stats_por_rol = cursor.fetchall()
        
        # Usuarios registrados por mes (últimos 12 meses)
        cursor.execute("""
            SELECT 
                DATE_FORMAT(fecha_creacion, '%Y-%m') as mes,
                COUNT(*) as cantidad
            FROM recurso_operativo
            WHERE fecha_creacion >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH)
            GROUP BY DATE_FORMAT(fecha_creacion, '%Y-%m')
            ORDER BY mes
        """)
        registros_por_mes = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        # Formatear datos para gráficos
        roles_labels = [ROLES.get(str(stat['id_roles']), 'Desconocido') for stat in stats_por_rol]
        roles_data = [stat['cantidad'] for stat in stats_por_rol]
        
        meses_labels = []
        meses_data = []
        for registro in registros_por_mes:
            meses_labels.append(registro['mes'])
            meses_data.append(registro['cantidad'])
            
        return jsonify({
            'roles': {
                'labels': roles_labels,
                'data': roles_data
            },
            'registros_mensuales': {
                'labels': meses_labels,
                'data': meses_data
            }
        })
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/reportes/filtros')
@login_required(role='administrativo')
def api_reportes_filtros():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener supervisores únicos
        cursor.execute("""
            SELECT DISTINCT supervisor 
            FROM preoperacional 
            WHERE supervisor IS NOT NULL AND supervisor != ''
            ORDER BY supervisor
        """)
        supervisores = [row['supervisor'] for row in cursor.fetchall()]
        
        # Obtener centros de trabajo únicos
        cursor.execute("""
            SELECT DISTINCT centro_de_trabajo 
            FROM preoperacional 
            WHERE centro_de_trabajo IS NOT NULL AND centro_de_trabajo != ''
            ORDER BY centro_de_trabajo
        """)
        centros_trabajo = [row['centro_de_trabajo'] for row in cursor.fetchall()]
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'supervisores': supervisores,
            'centros_trabajo': centros_trabajo
        })
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/reportes/preoperacional')
@login_required(role='administrativo')
def api_reportes_preoperacional():
    try:
        # Obtener parámetros de filtro
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor = request.args.get('supervisor')
        centro_trabajo = request.args.get('centro_trabajo')
        
        # Construir la cláusula WHERE base
        where_clauses = []
        params = []
        
        if fecha_inicio:
            where_clauses.append("p.fecha >= %s")
            params.append(fecha_inicio)
        if fecha_fin:
            where_clauses.append("p.fecha <= %s")
            params.append(fecha_fin)
        if supervisor:
            where_clauses.append("p.supervisor = %s")
            params.append(supervisor)
        if centro_trabajo:
            where_clauses.append("p.centro_de_trabajo = %s")
            params.append(centro_trabajo)
            
        where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Estadísticas generales con filtros
        stats_query = f"""
            SELECT 
                COUNT(*) as total_preoperacionales,
                COUNT(DISTINCT id_codigo_consumidor) as total_tecnicos,
                COUNT(DISTINCT DATE(fecha)) as total_dias
            FROM preoperacional p
            WHERE {where_sql}
        """
        cursor.execute(stats_query, params)
        stats_generales = cursor.fetchone()
        
        # Preoperacionales por día con filtros
        registros_query = f"""
            SELECT 
                DATE(fecha) as fecha,
                COUNT(*) as cantidad
            FROM preoperacional p
            WHERE {where_sql}
            GROUP BY DATE(fecha)
            ORDER BY fecha
        """
        cursor.execute(registros_query, params)
        registros_por_dia = cursor.fetchall()
        
        # Estado de vehículos con filtros
        estado_query = f"""
            SELECT 
                COUNT(*) as total,
                SUM(CASE 
                    WHEN (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                         estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                         direccionales_delanteras_traseras) = 9 THEN 1 
                    ELSE 0 
                END) as estado_bueno,
                SUM(CASE 
                    WHEN (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                         estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                         direccionales_delanteras_traseras) >= 5 
                    AND (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                         estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                         direccionales_delanteras_traseras) < 9 THEN 1 
                    ELSE 0 
                END) as estado_regular,
                SUM(CASE 
                    WHEN (estado_espejos + bocina_pito + frenos + encendido + estado_bateria + 
                         estado_amortiguadores + estado_llantas + luces_altas_bajas + 
                         direccionales_delanteras_traseras) < 5 THEN 1 
                    ELSE 0 
                END) as estado_malo
            FROM preoperacional p
            WHERE {where_sql}
        """
        cursor.execute(estado_query, params)
        estado_vehiculos = cursor.fetchone()
        
        # Estadísticas por centro de trabajo con filtros
        centro_trabajo_query = f"""
            SELECT 
                COALESCE(centro_de_trabajo, 'No especificado') as centro_de_trabajo,
                COUNT(*) as cantidad
            FROM preoperacional p
            WHERE {where_sql}
            GROUP BY centro_de_trabajo
            ORDER BY cantidad DESC
            LIMIT 5
        """
        cursor.execute(centro_trabajo_query, params)
        stats_centro_trabajo = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        # Formatear datos para la respuesta
        dias_labels = [registro['fecha'].strftime('%Y-%m-%d') for registro in registros_por_dia]
        dias_data = [registro['cantidad'] for registro in registros_por_dia]
        
        total = estado_vehiculos['total'] or 1
        estado_labels = ['Bueno', 'Regular', 'Malo']
        estado_data = [
            round((estado_vehiculos['estado_bueno'] or 0) / total * 100, 2),
            round((estado_vehiculos['estado_regular'] or 0) / total * 100, 2),
            round((estado_vehiculos['estado_malo'] or 0) / total * 100, 2)
        ]
        
        return jsonify({
            'stats_generales': stats_generales,
            'registros_diarios': {
                'labels': dias_labels,
                'data': dias_data
            },
            'estado_vehiculos': {
                'labels': estado_labels,
                'data': estado_data,
                'colores': ['#2dce89', '#fb6340', '#f5365c']  # Verde para Bueno, Naranja para Regular, Rojo para Malo
            },
            'centro_trabajo': {
                'labels': [ct['centro_de_trabajo'] for ct in stats_centro_trabajo],
                'data': [ct['cantidad'] for ct in stats_centro_trabajo]
            }
        })
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/reportes/vencimientos')
@login_required(role='administrativo')
def api_reportes_vencimientos():
    try:
        # Obtener parámetros de filtro
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor = request.args.get('supervisor')
        centro_trabajo = request.args.get('centro_trabajo')
        
        # Construir la cláusula WHERE base
        where_clauses = []
        params = []
        
        if fecha_inicio:
            where_clauses.append("p.fecha >= %s")
            params.append(fecha_inicio)
        if fecha_fin:
            where_clauses.append("p.fecha <= %s")
            params.append(fecha_fin)
        if supervisor:
            where_clauses.append("p.supervisor = %s")
            params.append(supervisor)
        if centro_trabajo:
            where_clauses.append("p.centro_de_trabajo = %s")
            params.append(centro_trabajo)
            
        # Agregar condiciones de vencimiento
        vencimiento_conditions = [
            "p.fecha_vencimiento_licencia IS NOT NULL AND p.fecha_vencimiento_licencia >= CURDATE() AND p.fecha_vencimiento_licencia <= DATE_ADD(CURDATE(), INTERVAL 30 DAY)",
            "p.fecha_vencimiento_soat IS NOT NULL AND p.fecha_vencimiento_soat >= CURDATE() AND p.fecha_vencimiento_soat <= DATE_ADD(CURDATE(), INTERVAL 30 DAY)",
            "p.fecha_vencimiento_tecnomecanica IS NOT NULL AND p.fecha_vencimiento_tecnomecanica >= CURDATE() AND p.fecha_vencimiento_tecnomecanica <= DATE_ADD(CURDATE(), INTERVAL 30 DAY)"
        ]
        
        where_sql = f"""
            ({" OR ".join(vencimiento_conditions)})
            {" AND " + " AND ".join(where_clauses) if where_clauses else ""}
        """
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        query = f"""
            SELECT 
                p.id_preoperacional,
                p.placa_vehiculo,
                p.fecha_vencimiento_licencia,
                p.fecha_vencimiento_soat,
                p.fecha_vencimiento_tecnomecanica,
                r.nombre as nombre_tecnico,
                DATEDIFF(p.fecha_vencimiento_licencia, CURDATE()) as dias_licencia,
                DATEDIFF(p.fecha_vencimiento_soat, CURDATE()) as dias_soat,
                DATEDIFF(p.fecha_vencimiento_tecnomecanica, CURDATE()) as dias_tecnomecanica
            FROM preoperacional p
            JOIN recurso_operativo r ON p.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE {where_sql}
            ORDER BY 
                LEAST(
                    COALESCE(DATEDIFF(p.fecha_vencimiento_licencia, CURDATE()), 999),
                    COALESCE(DATEDIFF(p.fecha_vencimiento_soat, CURDATE()), 999),
                    COALESCE(DATEDIFF(p.fecha_vencimiento_tecnomecanica, CURDATE()), 999)
                )
        """
        
        cursor.execute(query, params)
        vencimientos = cursor.fetchall()
        cursor.close()
        connection.close()
        
        return jsonify({
            'vencimientos': vencimientos
        })
        
    except Error as e:
        return jsonify({'error': str(e)}), 500

@app.route('/verificar_vencimientos')
@login_required()
def verificar_vencimientos():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener el último registro preoperacional del usuario
        cursor.execute("""
            SELECT 
                fecha_vencimiento_licencia,
                fecha_vencimiento_soat,
                fecha_vencimiento_tecnomecanica
            FROM preoperacional 
            WHERE id_codigo_consumidor = %s
            ORDER BY fecha DESC 
            LIMIT 1
        """, (session.get('user_id'),))
        
        ultimo_registro = cursor.fetchone()
        cursor.close()
        connection.close()
        
        if not ultimo_registro:
            return jsonify({'tiene_vencimientos': False})
            
        vencimientos = []
        # Usar fecha de Bogotá en lugar de la fecha del servidor
        fecha_actual = get_bogota_datetime().date()
        print(f"Verificando vencimientos con fecha de Bogotá: {fecha_actual}")
        
        # Verificar cada tipo de vencimiento
        if ultimo_registro['fecha_vencimiento_licencia']:
            dias_licencia = (ultimo_registro['fecha_vencimiento_licencia'] - fecha_actual).days
            if 0 <= dias_licencia <= 30:
                vencimientos.append({
                    'tipo': 'Licencia de Conducción',
                    'fecha': ultimo_registro['fecha_vencimiento_licencia'].strftime('%Y-%m-%d'),
                    'dias_restantes': dias_licencia
                })
                
        if ultimo_registro['fecha_vencimiento_soat']:
            dias_soat = (ultimo_registro['fecha_vencimiento_soat'] - fecha_actual).days
            if 0 <= dias_soat <= 30:
                vencimientos.append({
                    'tipo': 'SOAT',
                    'fecha': ultimo_registro['fecha_vencimiento_soat'].strftime('%Y-%m-%d'),
                    'dias_restantes': dias_soat
                })
                
        if ultimo_registro['fecha_vencimiento_tecnomecanica']:
            dias_tecno = (ultimo_registro['fecha_vencimiento_tecnomecanica'] - fecha_actual).days
            if 0 <= dias_tecno <= 30:
                vencimientos.append({
                    'tipo': 'Tecnomecánica',
                    'fecha': ultimo_registro['fecha_vencimiento_tecnomecanica'].strftime('%Y-%m-%d'),
                    'dias_restantes': dias_tecno
                })
        
        return jsonify({
            'tiene_vencimientos': len(vencimientos) > 0,
            'vencimientos': vencimientos,
            'fecha_bogota': fecha_actual.strftime('%Y-%m-%d')
        })
        
    except Error as e:
        print("Error en verificar_vencimientos:", str(e))
        return jsonify({'error': str(e)}), 500

@app.route('/verificar_registro_preoperacional')
@login_required(role=['tecnicos', 'operativo'])
def verificar_registro_preoperacional():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar si existe registro para el día actual en zona horaria de Bogotá
        fecha_actual = get_bogota_datetime().date()
        print(f"Verificando registro preoperacional para fecha Bogotá: {fecha_actual}")
        
        cursor.execute("""
            SELECT COUNT(*) as count, 
                   MAX(fecha) as ultimo_registro
            FROM preoperacional 
            WHERE id_codigo_consumidor = %s 
            AND DATE(CONVERT_TZ(fecha, '+00:00', '-05:00')) = %s
        """, (session.get('id_codigo_consumidor'), fecha_actual))
        
        resultado = cursor.fetchone()
        tiene_registro = resultado['count'] > 0
        ultimo_registro = resultado['ultimo_registro']
        
        # Convertir el último registro a zona horaria de Bogotá si existe
        ultimo_registro_str = None
        if ultimo_registro:
            ultimo_registro_bogota = convert_to_bogota_time(ultimo_registro)
            ultimo_registro_str = ultimo_registro_bogota.strftime('%Y-%m-%d %H:%M:%S')
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'tiene_registro': tiene_registro,
            'ultimo_registro': ultimo_registro_str,
            'fecha_actual': fecha_actual.strftime('%Y-%m-%d'),
            'hora_bogota': get_bogota_datetime().strftime('%H:%M:%S')
        })
        
    except Error as e:
        print(f"Error en verificar_registro_preoperacional: {str(e)}")
        return jsonify({'error': str(e)}), 500

# API Routes para Analistas
@app.route('/api/analistas/causas-cierre', methods=['GET'])
@login_required
def api_causas_cierre():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify([])
        cursor = connection.cursor(dictionary=True)

        texto_busqueda = request.args.get('busqueda', '').strip()
        tecnologia = request.args.get('tecnologia', '').strip()
        agrupacion = request.args.get('agrupacion', '').strip()
        grupo = request.args.get('grupo', '').strip()

        query = """
            SELECT 
                idbase_causas_cierre,
                codigo_causas_cierre,
                tipo_causas_cierre,
                nombre_causas_cierre,
                tecnologia_causas_cierre,
                instrucciones_de_uso_causas_cierre,
                agrupaciones_causas_cierre,
                todos_los_grupos_causas_cierre,
                facturable_causas_cierre
            FROM base_causas_cierre
            WHERE 1=1
        """

        params = []

        if texto_busqueda:
            query += """
                AND (
                    codigo_causas_cierre LIKE %s OR 
                    nombre_causas_cierre LIKE %s OR 
                    instrucciones_de_uso_causas_cierre LIKE %s
                )
            """
            busqueda_param = f"%{texto_busqueda}%"
            params.extend([busqueda_param, busqueda_param, busqueda_param])

        if tecnologia:
            query += " AND tecnologia_causas_cierre = %s"
            params.append(tecnologia)

        if agrupacion:
            query += " AND agrupaciones_causas_cierre = %s"
            params.append(agrupacion)

        if grupo:
            query += " AND todos_los_grupos_causas_cierre = %s"
            params.append(grupo)

        query += " ORDER BY codigo_causas_cierre ASC"

        cursor.execute(query, params)
        resultados = cursor.fetchall()
        return jsonify(resultados)
    except mysql.connector.Error as e:
        errno = getattr(e, 'errno', None)
        logging.error(f"Error en API causas-cierre: {str(e)} (errno={errno})")
        if errno == 1146:
            return jsonify([])
        return jsonify([])
    except Exception as e:
        logging.error(f"Error inesperado en API causas-cierre: {str(e)}")
        return jsonify([])
    finally:
        if 'cursor' in locals() and cursor:
            try:
                cursor.close()
            except:
                pass
        if 'connection' in locals() and connection:
            try:
                if connection.is_connected():
                    connection.close()
            except:
                pass
def _normalizar_hora(valor):
    """Normaliza distintos formatos de hora a 'HH:MM'."""
    try:
        from datetime import datetime, time as dtime
        import re
        if not valor:
            return None
        # Tipos datetime/time
        if isinstance(valor, dtime):
            return valor.strftime('%H:%M')
        if isinstance(valor, datetime):
            return valor.strftime('%H:%M')

        # Convertir a texto y limpiar variantes
        s = str(valor).strip()
        s = s.replace('.', ':')
        s = (s
             .replace('a. m.', 'AM').replace('p. m.', 'PM')
             .replace('a.m.', 'AM').replace('p.m.', 'PM')
             .replace('A. M.', 'AM').replace('P. M.', 'PM')
             .replace('am', 'AM').replace('pm', 'PM'))
        s = re.sub(r'\s+', ' ', s).strip()

        # Intentar parseo con AM/PM
        for fmt in ('%I:%M %p', '%I:%M%p'):
            try:
                dt = datetime.strptime(s.upper(), fmt)
                return dt.strftime('%H:%M')
            except Exception:
                pass

        # Intentar formato 24h HH:MM
        m = re.search(r'(\d{1,2})[:](\d{2})', s)
        if m:
            h = int(m.group(1)); mnt = int(m.group(2))
            if 0 <= h <= 23 and 0 <= mnt <= 59:
                return f"{h:02d}:{mnt:02d}"

        # Dígitos 3-4 como 830 u 0830
        md = re.search(r'\b(\d{3,4})\b', s)
        if md:
            d = md.group(1)
            if len(d) == 3:
                h = int(d[0]); mnt = int(d[1:])
            else:
                h = int(d[:2]); mnt = int(d[2:])
            if 0 <= h <= 23 and 0 <= mnt <= 59:
                return f"{h:02d}:{mnt:02d}"

        return None
    except Exception:
        # Si ocurre cualquier error inesperado al normalizar, retornar None
        return None

@app.route('/api/analistas/tecnicos-asignados', methods=['GET'])
@login_required()
def main_api_tecnicos_asignados():
    """API endpoint para obtener técnicos asignados al analista actual con su información de asistencia"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener el nombre del analista actual desde la sesión
        analista_nombre = session.get('user_name') if session.get('user_name') else None
        
        if not analista_nombre:
            return jsonify({'error': 'No se pudo identificar al analista actual'}), 401
            
        # Obtener parámetro de fecha (por defecto fecha actual)
        fecha_filtro = request.args.get('fecha')
        if not fecha_filtro:
            from datetime import date
            fecha_filtro = date.today().strftime('%Y-%m-%d')
        
        # Consulta para obtener técnicos asignados al analista actual
        query_tecnicos = """
            SELECT DISTINCT
                ro.id_codigo_consumidor,
                ro.recurso_operativo_cedula as cedula,
                ro.nombre as tecnico,
                ro.carpeta,
                ro.cargo as cargo,
                ro.cliente,
                ro.ciudad,
                ro.super as supervisor,
                ro.analista
            FROM recurso_operativo ro
            WHERE ro.analista = %s
            AND ro.estado = 'Activo'
            ORDER BY ro.nombre
        """
        
        cursor.execute(query_tecnicos, (analista_nombre,))
        tecnicos = cursor.fetchall()
        
        # Para cada técnico, obtener información de asistencia del día actual
        tecnicos_con_asistencia = []
        
        for tecnico in tecnicos:
            # Buscar asistencia del día filtrado
            query_asistencia = """
                SELECT 
                    a.carpeta_dia,
                    a.fecha_asistencia,
                    a.hora_inicio,
                    a.estado,
                    a.novedad,
                    ta.nombre_tipificacion,
                    ta.codigo_tipificacion,
                    ta.grupo as grupo_tipificacion,
                    pc.presupuesto_eventos,
                    pc.presupuesto_diario,
                    pc.presupuesto_carpeta as nombre_presupuesto_carpeta
                FROM asistencia a
                LEFT JOIN tipificacion_asistencia ta ON a.carpeta_dia = ta.codigo_tipificacion
                LEFT JOIN presupuesto_carpeta pc ON ta.nombre_tipificacion = pc.presupuesto_carpeta AND pc.presupuesto_cargo = %s
                WHERE a.cedula = %s
                AND DATE(a.fecha_asistencia) = %s
                ORDER BY a.fecha_asistencia DESC
                LIMIT 1
            """
            
            cursor.execute(query_asistencia, (tecnico.get('cargo'), tecnico['cedula'], fecha_filtro))
            asistencia = cursor.fetchone()
            
            if asistencia:
                try:
                    tip_nom = asistencia.get('nombre_tipificacion')
                    pe = asistencia.get('presupuesto_eventos')
                    pd = asistencia.get('presupuesto_diario')
                    if (tip_nom and str(tip_nom).strip().upper() == 'DX') and (pe is None or pd is None):
                        cargo_tecnico = tecnico.get('cargo')
                        cursor.execute("""
                            SELECT presupuesto_eventos, presupuesto_diario 
                            FROM presupuesto_carpeta 
                            WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s
                            LIMIT 1
                        """, ('ARREGLOS HFC', cargo_tecnico))
                        alt = cursor.fetchone()
                        if not alt:
                            cursor.execute("""
                                SELECT presupuesto_eventos, presupuesto_diario 
                                FROM presupuesto_carpeta 
                                WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s
                                LIMIT 1
                            """, ('MANTENIMIENTO FTTH', cargo_tecnico))
                            alt = cursor.fetchone()
                        if alt:
                            asistencia['presupuesto_eventos'] = alt.get('presupuesto_eventos')
                            asistencia['presupuesto_diario'] = alt.get('presupuesto_diario')
                            asistencia['nombre_presupuesto_carpeta'] = 'DX'
                except Exception:
                    pass
            
            # Agregar información de asistencia al técnico
            tecnico_info = {
                'id_codigo_consumidor': tecnico['id_codigo_consumidor'],
                'cedula': tecnico['cedula'],
                'tecnico': tecnico['tecnico'],
                'carpeta': tecnico['carpeta'],
                'cliente': tecnico['cliente'],
                'ciudad': tecnico['ciudad'],
                'supervisor': tecnico['supervisor'],
                'analista': tecnico['analista'],
                'asistencia_hoy': {
                    'carpeta_dia': asistencia['carpeta_dia'] if asistencia else None,
                    'fecha_asistencia': asistencia['fecha_asistencia'].isoformat() if asistencia and asistencia['fecha_asistencia'] else None,
                    'hora_inicio': _normalizar_hora(asistencia['hora_inicio']) if asistencia and asistencia['hora_inicio'] else None,
                    'estado': asistencia['estado'] if asistencia else None,
                    'novedad': asistencia['novedad'] if asistencia else None,
                    'tipificacion': asistencia['nombre_tipificacion'] if asistencia else 'Sin registro',
                    'codigo_tipificacion': asistencia['codigo_tipificacion'] if asistencia else None,
                    'grupo_tipificacion': asistencia['grupo_tipificacion'] if asistencia else None,
                    'presupuesto_eventos': asistencia['presupuesto_eventos'] if asistencia else None,
                    'presupuesto_diario': asistencia['presupuesto_diario'] if asistencia else None,
                    'nombre_presupuesto_carpeta': asistencia['nombre_presupuesto_carpeta'] if asistencia else None
                }
            }
            
            tecnicos_con_asistencia.append(tecnico_info)
        
        return jsonify({
            'success': True,
            'analista': analista_nombre,
            'total_tecnicos': len(tecnicos_con_asistencia),
            'tecnicos': tecnicos_con_asistencia
        })
        
    except mysql.connector.Error as e:
        logging.error(f"Error en API técnicos asignados: {str(e)}")
        return jsonify({'error': 'Error al consultar la base de datos'}), 500
    except Exception as e:
        logging.error(f"Error inesperado en API técnicos asignados: {str(e)}")
        return jsonify({'error': 'Error interno del servidor'}), 500
    finally:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
        except:
            pass
        try:
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except:
            pass

@app.route('/api/usuario/inspeccion/pendientes', methods=['GET'])
@login_required_api()
def api_usuario_inspeccion_pendientes():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})
        cursor = connection.cursor(dictionary=True)
        cedula = str(session.get('user_cedula') or '').strip()
        idc = session.get('id_codigo_consumidor')
        nombre_user = None
        try:
            if idc:
                cursor.execute(
                    """
                    SELECT nombre
                    FROM recurso_operativo
                    WHERE id_codigo_consumidor = %s
                    LIMIT 1
                    """,
                    (idc,)
                )
                ro_n = cursor.fetchone()
                if ro_n and ro_n.get('nombre'):
                    nombre_user = ro_n.get('nombre')
            if not nombre_user and cedula:
                cursor.execute(
                    """
                    SELECT nombre
                    FROM recurso_operativo
                    WHERE recurso_operativo_cedula = %s
                    LIMIT 1
                    """,
                    (cedula,)
                )
                ro_n2 = cursor.fetchone()
                if ro_n2 and ro_n2.get('nombre'):
                    nombre_user = ro_n2.get('nombre')
        except Exception:
            pass
        ultima = None
        matched_by = None
        if cedula:
            cursor.execute(
                """
                SELECT *
                FROM mpa_inspeccion_vehiculo
                WHERE recurso_operativo_cedula = %s
                ORDER BY fecha_inspeccion DESC
                LIMIT 1
                """,
                (cedula,)
            )
            ultima = cursor.fetchone()
            if ultima:
                matched_by = 'cedula'
        if not ultima and idc:
            cursor.execute(
                """
                SELECT *
                FROM mpa_inspeccion_vehiculo
                WHERE id_codigo_consumidor = %s
                ORDER BY fecha_inspeccion DESC
                LIMIT 1
                """,
                (idc,)
            )
            ultima = cursor.fetchone()
            if ultima:
                matched_by = 'id'
        if not ultima and idc:
            cursor.execute(
                """
                SELECT placa 
                FROM mpa_vehiculos 
                WHERE tecnico_asignado = %s AND estado = 'Activo'
                ORDER BY id_mpa_vehiculos DESC
                LIMIT 1
                """,
                (idc,)
            )
            v = cursor.fetchone()
            if v and v.get('placa'):
                cursor.execute(
                    """
                    SELECT *
                    FROM mpa_inspeccion_vehiculo
                    WHERE placa = %s
                    ORDER BY fecha_inspeccion DESC
                    LIMIT 1
                    """,
                    (v['placa'],)
                )
                ultima = cursor.fetchone()
                if ultima:
                    matched_by = 'placa'
        if not ultima and cedula:
            try:
                cursor.execute(
                    """
                    SELECT placa 
                    FROM mpa_vehiculos 
                    WHERE tecnico_asignado = %s AND estado = 'Activo'
                    ORDER BY id_mpa_vehiculos DESC
                    LIMIT 1
                    """,
                    (cedula,)
                )
                v2 = cursor.fetchone()
                if v2 and v2.get('placa'):
                    cursor.execute(
                        """
                        SELECT *
                        FROM mpa_inspeccion_vehiculo
                        WHERE placa = %s
                        ORDER BY fecha_inspeccion DESC
                        LIMIT 1
                        """,
                        (v2['placa'],)
                    )
                    ultima = cursor.fetchone()
                    if ultima:
                        matched_by = 'placa'
            except Exception:
                pass
        if not ultima and nombre_user:
            try:
                cursor.execute(
                    """
                    SELECT *
                    FROM mpa_inspeccion_vehiculo
                    WHERE nombre = %s
                    ORDER BY fecha_inspeccion DESC
                    LIMIT 1
                    """,
                    (nombre_user,)
                )
                ultima = cursor.fetchone()
                if ultima:
                    matched_by = 'nombre'
            except Exception:
                pass
        bm_fields = [
            'estado_fisico_espejos_laterales','estado_fisico_pito','estado_fisico_freno_servicio','estado_fisico_manillares','estado_fisico_guayas','estado_fisico_tanque_combustible','estado_fisico_encendido','estado_fisico_pedales','estado_fisico_guardabarros','estado_fisico_sillin_tapiceria','estado_fisico_tablero','estado_fisico_mofle_silenciador','estado_fisico_kit_arrastre','estado_fisico_reposa_pies','estado_fisico_pata_lateral_central','estado_fisico_tijera_amortiguador','estado_fisico_bateria','luces_altas_bajas','luces_direccionales_delanteros','luces_direccionales_traseros','luces_luz_placa','luces_stop','prevension_casco','prevension_guantes','prevension_rodilleras','prevension_coderas','llantas_labrado_llantas','llantas_rines','llantas_presion_aire','otros_aceite','otros_suspension_direccion','otros_caja_cambios','otros_conexiones_electricas'
        ]
        bm_synonyms = {
            'prevension_casco': ['prevencion_casco'],
            'prevension_guantes': ['prevencion_guantes'],
            'prevension_rodilleras': ['prevencion_rodilleras'],
            'prevension_coderas': ['prevencion_coderas']
        }
        fecha_str = None
        fi_date = None
        malos = 0
        dias_restantes = None
        placa = None
        if ultima:
            fi = ultima.get('fecha_inspeccion')
            placa = ultima.get('placa')
            if fi:
                try:
                    fi_date = fi.date() if hasattr(fi, 'date') else datetime.strptime(str(fi)[:19], '%Y-%m-%d %H:%M:%S').date()
                except Exception:
                    try:
                        fi_date = datetime.strptime(str(fi)[:10], '%Y-%m-%d').date()
                    except Exception:
                        fi_date = None
                if fi_date:
                    try:
                        fecha_str = fi_date.strftime('%Y-%m-%d')
                    except Exception:
                        fecha_str = str(fi)[:10]
            for k in bm_fields:
                v = ultima.get(k)
                if v is None and k in bm_synonyms:
                    for alt in bm_synonyms[k]:
                        if ultima.get(alt) is not None:
                            v = ultima.get(alt)
                            break
                s = str(v or '').strip().upper()
                if s in ('M','MALO'):
                    malos += 1
            if fi_date:
                try:
                    hoy = get_bogota_datetime().date()
                    transcurridos = (hoy - fi_date).days
                    dias_restantes = 5 - transcurridos
                    if dias_restantes < 0:
                        dias_restantes = 0
                except Exception:
                    dias_restantes = None
        info = {
            'fecha_ultima': fecha_str,
            'items_malos': malos,
            'dias_restantes_subsanar': dias_restantes,
            'placa': placa
        }
        return jsonify({'success': True, 'show_alert': bool(malos), 'matched_by': matched_by, **info})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})
    finally:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
        except:
            pass
        try:
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except:
            pass

@app.route('/logistica/asignaciones')
@login_required()
@role_required('logistica')
def ver_asignaciones():
    try:
        # Verificar stock bajo para mostrar alertas
        materiales_problematicos = verificar_stock_bajo()
        
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
                               
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todas las asignaciones con información del técnico
        cursor.execute("""
            SELECT a.*, r.nombre, r.recurso_operativo_cedula 
            FROM asignacion a 
            LEFT JOIN recurso_operativo r ON a.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY a.asignacion_fecha DESC
        """)
        asignaciones = cursor.fetchall()

        # Obtener lista de técnicos disponibles
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula, cargo 
            FROM recurso_operativo 
            WHERE cargo LIKE '%TECNICO%' OR cargo LIKE '%TÉCNICO%'
            ORDER BY nombre
        """)
        tecnicos = cursor.fetchall()
        
        cursor.close()
        connection.close()

        return render_template('modulos/logistica/asignaciones.html', 
                            asignaciones=asignaciones,
                            tecnicos=tecnicos,
                            materiales_problematicos=materiales_problematicos)

    except Exception as e:
        print(f"Error al obtener asignaciones: {str(e)}")
        return render_template('error.html', 
                           mensaje='Error al cargar las asignaciones',
                           error=str(e))

@app.route('/logistica/registrar_asignacion', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_asignacion():
    connection = None
    cursor = None
    try:
        # Obtener datos básicos
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha = request.form.get('fecha')
        cargo = request.form.get('cargo')

        # Validar campos requeridos
        if not all([id_codigo_consumidor, fecha, cargo]):
            return jsonify({
                'status': 'error',
                'message': 'Los campos ID, fecha y cargo son requeridos'
            }), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar que el técnico existe
        cursor.execute('SELECT nombre FROM recurso_operativo WHERE id_codigo_consumidor = %s', (id_codigo_consumidor,))
        tecnico = cursor.fetchone()
        
        if not tecnico:
            return jsonify({
                'status': 'error',
                'message': 'El técnico seleccionado no existe'
            }), 404

        # Obtener la estructura de la tabla
        cursor.execute("""
            SELECT COLUMN_NAME 
            FROM INFORMATION_SCHEMA.COLUMNS 
            WHERE TABLE_SCHEMA = DATABASE()
            AND TABLE_NAME = 'asignacion'
        """)
        columnas_existentes = {row['COLUMN_NAME'].lower() for row in cursor.fetchall()}
        
        print("Columnas existentes:", columnas_existentes)  # Debug log

        # Campos base que siempre deben existir
        campos = ['id_codigo_consumidor', 'asignacion_fecha', 'asignacion_cargo']
        valores = [id_codigo_consumidor, fecha, cargo]

        # Lista de todas las herramientas posibles
        herramientas = [
            'adaptador_mandril', 'alicate', 'barra_45cm', 'bisturi_metalico',
            'broca_3/8', 'broca_3/8/6_ran', 'broca_1/2/6_ran',
            'broca_metal/madera_1/4', 'broca_metal/madera_3/8', 'broca_metal/madera_5/16',
            'caja_de_herramientas', 'cajon_rojo', 'cinta_de_senal', 'cono_retractil',
            'cortafrio', 'destor_de_estrella', 'destor_de_pala', 'destor_tester',
            'espatula', 'exten_de_corr_10_mts', 'llave_locking_male', 'llave_reliance',
            'llave_torque_rg_11', 'llave_torque_rg_6', 'llaves_mandril',
            'mandril_para_taladro', 'martillo_de_una', 'multimetro',
            'pelacable_rg_6y_rg_11', 'pinza_de_punta', 'pistola_de_silicona',
            'planillero', 'ponchadora_rg_6_y_rg_11', 'ponchadora_rj_45_y_rj11',
            'probador_de_tonos', 'probador_de_tonos_utp', 'puntas_para_multimetro',
            'sonda_metalica', 'tacos_de_madera', 'taladro_percutor',
            'telefono_de_pruebas', 'power_miter', 'bfl_laser', 'cortadora',
            'stripper_fibra', 'pelachaqueta'
        ]

        # Procesar cada herramienta
        for herramienta in herramientas:
            nombre_campo = f'asignacion_{herramienta}'
            if nombre_campo.lower() in columnas_existentes:
                campos.append(nombre_campo)
                valor = request.form.get(herramienta, '0')
                valores.append(valor if valor == '1' else '0')
            else:
                print(f"Campo ignorado (no existe en la tabla): {nombre_campo}")

        # Agregar estado por defecto si existe la columna
        if 'asignacion_estado' in columnas_existentes:
            campos.append('asignacion_estado')
            valores.append('1')

        # Construir y ejecutar la consulta SQL
        sql = f"""
            INSERT INTO asignacion ({', '.join(campos)})
            VALUES ({', '.join(['%s'] * len(valores))})
        """
        
        print("SQL Query:", sql)  # Debug log
        print("Valores:", valores)  # Debug log

        cursor.execute(sql, tuple(valores))
        connection.commit()

        return jsonify({
            'status': 'success',
            'message': 'Asignación registrada exitosamente'
        }), 201

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error al registrar la asignación: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/push/vapid-public-key', methods=['GET'])
def push_vapid_public_key():
    try:
        if not VAPID_PUBLIC_KEY:
            return jsonify({'success': False, 'message': 'VAPID_PUBLIC_KEY no configurada'}), 500
        return jsonify({'success': True, 'publicKey': VAPID_PUBLIC_KEY})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/push/subscribe', methods=['POST'])
@login_required_api()
def api_push_subscribe():
    try:
        data = request.get_json(silent=True) or {}
        sub = data.get('subscription')
        if not sub:
            return jsonify({'success': False, 'message': 'Suscripción inválida'}), 400
        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        role = session.get('user_role')
        if not user_id:
            return jsonify({'success': False, 'message': 'Usuario no autenticado'}), 401
        conn = get_db_connection()
        if not conn:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor()
        cur.execute(
            """
            INSERT INTO webpush_subscriptions (user_id, role, subscription_json)
            VALUES (%s, %s, %s)
            """,
            (str(user_id), role, json.dumps(sub))
        )
        conn.commit()
        cur.close(); conn.close()
        return jsonify({'success': True})
    except Exception as e:
        try:
            if conn:
                conn.rollback()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

def _compute_pending_cierres(connection, fecha_arg, tip_arg):
    c = connection.cursor()
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
    cols_type = {}
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    for r in c.fetchall():
        cols_type[r[0].lower()] = str(r[1]).lower()
    def pick(names):
        for n in names:
            k = n.lower()
            if k in cols_all:
                return cols_all[k]
        for k0,v0 in cols_all.items():
            for n in names:
                if n.lower() in k0:
                    return v0
        return None
    col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
    col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
    col_cierre = pick(['cierre_ciclo'])
    col_estado = pick(['estado'])
    col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
    col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
    col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
    col_cierre_super = pick(['cierre_super','estado_super'])
    col_tip_ok = pick(['tipificacion_ok'])
    col_tip_nov = pick(['tipificacion_novedad'])
    if not col_ext:
        return 0
    params = []
    where = []
    if col_cierre:
        where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
    if col_estado:
        where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
    tip_arg = (tip_arg or '').strip() or 'CLIENTE INCONFORME'
    fecha_norm = None
    if fecha_arg:
        fecha_norm = fecha_arg
        for fmt in ('%Y-%m-%d','%d/%m/%Y','%d-%m-%Y','%Y/%m/%d'):
            try:
                fecha_norm = datetime.strptime(fecha_arg, fmt).strftime('%Y-%m-%d')
                break
            except Exception:
                pass
    else:
        fecha_norm = datetime.now().strftime('%Y-%m-%d')
    if col_fecha and fecha_norm:
        tipo_fecha = cols_type.get(col_fecha.lower())
        if tipo_fecha in ('datetime','timestamp','date'):
            where.append(f"DATE(o.`{col_fecha}`) = %s")
            params.append(fecha_norm)
        else:
            where.append(f"o.`{col_fecha}` LIKE %s")
            params.append(fecha_norm + '%')
    if tip_arg:
        if col_tip_ok:
            where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
            params.append(tip_arg)
        elif col_tip_nov:
            where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
            params.append(tip_arg)
    user_role = session.get('user_role')
    if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
        val_id = str(session.get('id_codigo_consumidor') or '').strip()
        val_ced = str(session.get('user_cedula') or '').strip()
        col_l = str(col_ext).lower()
        if 'cedula' in col_l:
            if val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
        else:
            if val_id and val_ced:
                where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                params.extend([val_id, val_ced])
            elif val_id:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_id)
            elif val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
    else:
        sup_name = str(session.get('user_name') or '').strip()
        tech_keys = []
        try:
            c_sup = connection.cursor()
            try:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE super = %s
                    """,
                    (sup_name,)
                )
            except Exception:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE supervisor = %s
                    """,
                    (sup_name,)
                )
            for r0 in c_sup.fetchall() or []:
                try:
                    if r0[0] is not None:
                        tech_keys.append(str(r0[0]))
                except Exception:
                    pass
                try:
                    if r0[1] is not None:
                        tech_keys.append(str(r0[1]))
                except Exception:
                    pass
            c_sup.close()
        except Exception:
            tech_keys = []
        tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
        if len(tech_keys) == 0:
            return 0
        placeholders = ','.join(['%s'] * len(tech_keys))
        where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
        params.extend(tech_keys)
    select_parts = [f"o.`{col_ext}` AS tecnico_id"]
    if col_cierre_super:
        select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
    if col_tip_super_1:
        select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
    if col_tip_super_2:
        select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
    if col_fecha_gestion_super:
        select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
    sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
    if where:
        sql += " WHERE " + " AND ".join(where)
    cur = connection.cursor(dictionary=True)
    cur.execute(sql, tuple(params))
    rows = cur.fetchall() or []
    pending = 0
    for r in rows:
        done = False
        val_cierre = r.get('cierre_super')
        if val_cierre is not None:
            try:
                done = int(val_cierre) == 1
            except Exception:
                done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
        if not done and r.get('fecha_gestion_super'):
            done = True
        if not done:
            tip1 = r.get('tip_super_1')
            tip2 = r.get('tip_super_2')
            tip2_norm = str(tip2 or '').strip().lower()
            pending2 = (
                tip2_norm == 'en predio' or
                tip2_norm == 'cliente no atiende' or
                tip2_norm == 'reprogramar' or
                ('reprogramar' in tip2_norm) or
                ('cliente no atiende' in tip2_norm)
            )
            if tip2 and str(tip2).strip():
                done = not pending2
            elif tip1 and str(tip1).strip():
                done = True
        if not done:
            pending += 1
    cur.close(); c.close()
    return pending

def _compute_pending_cierres_backlog(connection, tip_arg):
    c = connection.cursor()
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
    cols_type = {}
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    for r in c.fetchall():
        cols_type[r[0].lower()] = str(r[1]).lower()
    def pick(names):
        for n in names:
            k = n.lower()
            if k in cols_all:
                return cols_all[k]
        for k0,v0 in cols_all.items():
            for n in names:
                if n.lower() in k0:
                    return v0
        return None
    col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
    col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
    col_cierre = pick(['cierre_ciclo'])
    col_estado = pick(['estado'])
    col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
    col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
    col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
    col_cierre_super = pick(['cierre_super','estado_super'])
    col_tip_ok = pick(['tipificacion_ok'])
    col_tip_nov = pick(['tipificacion_novedad'])
    if not col_ext:
        return 0
    params = []
    where = []
    if col_cierre:
        where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
    if col_estado:
        where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
    tip_norm = (tip_arg or '').strip()
    today_str = datetime.now().strftime('%Y-%m-%d')
    # Fecha se evaluará en Python para soportar múltiples formatos
    if tip_norm:
        if col_tip_ok:
            where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
            params.append(tip_norm)
        elif col_tip_nov:
            where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
            params.append(tip_norm)
    user_role = session.get('user_role')
    if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
        val_id = str(session.get('id_codigo_consumidor') or '').strip()
        val_ced = str(session.get('user_cedula') or '').strip()
        col_l = str(col_ext).lower()
        if 'cedula' in col_l:
            if val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
        else:
            if val_id and val_ced:
                where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                params.extend([val_id, val_ced])
            elif val_id:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_id)
            elif val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
    else:
        sup_name = str(session.get('user_name') or '').strip()
        tech_keys = []
        try:
            c_sup = connection.cursor()
            try:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE super = %s
                    """,
                    (sup_name,)
                )
            except Exception:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE supervisor = %s
                    """,
                    (sup_name,)
                )
            for r0 in c_sup.fetchall() or []:
                try:
                    if r0[0] is not None:
                        tech_keys.append(str(r0[0]))
                except Exception:
                    pass
                try:
                    if r0[1] is not None:
                        tech_keys.append(str(r0[1]))
                except Exception:
                    pass
            c_sup.close()
        except Exception:
            tech_keys = []
        tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
        if len(tech_keys) == 0:
            return 0
        placeholders = ','.join(['%s'] * len(tech_keys))
        where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
        params.extend(tech_keys)
    select_parts = [f"o.`{col_ext}` AS tecnico_id"]
    if col_cierre_super:
        select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
    if col_tip_super_1:
        select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
    if col_tip_super_2:
        select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
    if col_fecha_gestion_super:
        select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
    if col_fecha:
        select_parts.append(f"o.`{col_fecha}` AS fecha_column")
    sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
    if where:
        sql += " WHERE " + " AND ".join(where)
    cur = connection.cursor(dictionary=True)
    cur.execute(sql, tuple(params))
    rows = cur.fetchall() or []
    pending = 0
    for r in rows:
        done = False
        val_cierre = r.get('cierre_super')
        if val_cierre is not None:
            try:
                done = int(val_cierre) == 1
            except Exception:
                done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
        if not done and r.get('fecha_gestion_super'):
            done = True
        if not done:
            tip1 = r.get('tip_super_1')
            tip2 = r.get('tip_super_2')
            tip2_norm = str(tip2 or '').strip().lower()
            pending2 = (
                tip2_norm == 'en predio' or
                tip2_norm == 'cliente no atiende' or
                tip2_norm == 'reprogramar' or
                ('reprogramar' in tip2_norm) or
                ('cliente no atiende' in tip2_norm)
            )
            if tip2 and str(tip2).strip():
                done = not pending2
            elif tip1 and str(tip1).strip():
                done = True
        if not done:
            try:
                fv = r.get('fecha_column')
                dt = None
                if fv is not None:
                    if hasattr(fv, 'year') and hasattr(fv, 'month') and hasattr(fv, 'day'):
                        if hasattr(fv, 'hour') and hasattr(fv, 'minute'):
                            dt = fv
                        else:
                            dt = datetime(int(getattr(fv, 'year')), int(getattr(fv, 'month')), int(getattr(fv, 'day')))
                    else:
                        s = str(fv).strip()
                        s0 = s.split('.')[0]
                        try:
                            dt = datetime.fromisoformat(s0.replace('Z',''))
                        except Exception:
                            dt = None
                        if dt is None:
                            for fmt in ('%Y-%m-%d %H:%M:%S', '%Y-%m-%d', '%d/%m/%Y %H:%M:%S', '%d/%m/%Y', '%d-%m-%Y %H:%M:%S', '%d-%m-%Y', '%Y/%m/%d %H:%M:%S', '%Y/%m/%d'):
                                try:
                                    dt = datetime.strptime(s0, fmt)
                                    break
                                except Exception:
                                    pass
                if dt is None:
                    continue
                today = get_bogota_datetime().date()
                if dt.date() < today:
                    pending += 1
            except Exception:
                pass
    cur.close(); c.close()
    return pending

def _compute_pending_cierres_month(connection, tip_arg):
    c = connection.cursor()
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    cols_all = {r[0].lower(): r[0] for r in c.fetchall()}
    cols_type = {}
    c.execute(
        """
        SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns
        WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
        """,
        (db_config.get('database'),)
    )
    for r in c.fetchall():
        cols_type[r[0].lower()] = str(r[1]).lower()
    def pick(names):
        for n in names:
            k = n.lower()
            if k in cols_all:
                return cols_all[k]
        for k0,v0 in cols_all.items():
            for n in names:
                if n.lower() in k0:
                    return v0
        return None
    col_ext = pick(['external_id','id_tecnico','id_codigo_consumidor','cedula','recurso_operativo_cedula'])
    col_fecha = pick(['fecha','fecha_actividad','fecha_asignacion','fecha_orden'])
    col_cierre = pick(['cierre_ciclo'])
    col_estado = pick(['estado'])
    col_tip_super_1 = pick(['tip_super_1','tipificacion_super_1'])
    col_tip_super_2 = pick(['tip_super_2','tipificacion_super_2'])
    col_fecha_gestion_super = pick(['fecha_gestion_super','fecha_super'])
    col_cierre_super = pick(['cierre_super','estado_super'])
    col_tip_ok = pick(['tipificacion_ok'])
    col_tip_nov = pick(['tipificacion_novedad'])
    if not col_ext:
        return 0
    params = []
    where = []
    if col_cierre:
        where.append(f"CAST(o.`{col_cierre}` AS SIGNED) = 1")
    if col_estado:
        where.append(f"LOWER(TRIM(o.`{col_estado}`)) = 'completado'")
    tip_norm = (tip_arg or '').strip() or 'CLIENTE INCONFORME'
    if tip_norm:
        if col_tip_ok:
            where.append(f"LOWER(TRIM(o.`{col_tip_ok}`)) = LOWER(TRIM(%s))")
            params.append(tip_norm)
        elif col_tip_nov:
            where.append(f"LOWER(TRIM(o.`{col_tip_nov}`)) = LOWER(TRIM(%s))")
            params.append(tip_norm)
    user_role = session.get('user_role')
    if user_role in ('tecnico','tecnicos','Tecnico','Tecnicos') and col_ext:
        val_id = str(session.get('id_codigo_consumidor') or '').strip()
        val_ced = str(session.get('user_cedula') or '').strip()
        col_l = str(col_ext).lower()
        if 'cedula' in col_l:
            if val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
        else:
            if val_id and val_ced:
                where.append(f"(CAST(o.`{col_ext}` AS CHAR) = %s OR CAST(o.`{col_ext}` AS CHAR) = %s)")
                params.extend([val_id, val_ced])
            elif val_id:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_id)
            elif val_ced:
                where.append(f"CAST(o.`{col_ext}` AS CHAR) = %s")
                params.append(val_ced)
    else:
        sup_name = str(session.get('user_name') or '').strip()
        tech_keys = []
        try:
            c_sup = connection.cursor()
            try:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE super = %s
                    """,
                    (sup_name,)
                )
            except Exception:
                c_sup.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula
                    FROM recurso_operativo
                    WHERE supervisor = %s
                    """,
                    (sup_name,)
                )
            for r0 in c_sup.fetchall() or []:
                try:
                    if r0[0] is not None:
                        tech_keys.append(str(r0[0]))
                except Exception:
                    pass
                try:
                    if r0[1] is not None:
                        tech_keys.append(str(r0[1]))
                except Exception:
                    pass
            c_sup.close()
        except Exception:
            tech_keys = []
        tech_keys = list(dict.fromkeys([k for k in tech_keys if k and k.strip()]))
        if len(tech_keys) == 0:
            return 0
        placeholders = ','.join(['%s'] * len(tech_keys))
        where.append(f"CAST(o.`{col_ext}` AS CHAR) IN ({placeholders})")
        params.extend(tech_keys)
    tipo_fecha = str(cols_type.get((col_fecha or '').lower()) or '').lower() if col_fecha else None
    today = get_bogota_datetime()
    y = today.year
    m = today.month
    from calendar import monthrange
    last_day = monthrange(y, m)[1]
    ini = f"{y}-{str(m).zfill(2)}-01"
    fin = f"{y}-{str(m).zfill(2)}-{str(last_day).zfill(2)}"
    if col_fecha:
        if tipo_fecha in ('datetime','timestamp','date'):
            where.append(f"DATE(o.`{col_fecha}`) BETWEEN %s AND %s")
            params.extend([ini, fin])
        else:
            where.append(f"o.`{col_fecha}` LIKE %s")
            params.append(f"{y}-{str(m).zfill(2)}-%")
    select_parts = [f"o.`{col_ext}` AS tecnico_id"]
    if col_cierre_super:
        select_parts.append(f"o.`{col_cierre_super}` AS cierre_super")
    if col_tip_super_1:
        select_parts.append(f"o.`{col_tip_super_1}` AS tip_super_1")
    if col_tip_super_2:
        select_parts.append(f"o.`{col_tip_super_2}` AS tip_super_2")
    if col_fecha_gestion_super:
        select_parts.append(f"o.`{col_fecha_gestion_super}` AS fecha_gestion_super")
    sql = "SELECT " + ", ".join(select_parts) + " FROM operaciones_actividades_diarias o"
    if where:
        sql += " WHERE " + " AND ".join(where)
    cur = connection.cursor(dictionary=True)
    cur.execute(sql, tuple(params))
    rows = cur.fetchall() or []
    pending = 0
    for r in rows:
        done = False
        val_cierre = r.get('cierre_super')
        if val_cierre is not None:
            try:
                done = int(val_cierre) == 1
            except Exception:
                done = str(val_cierre).strip().lower() in ('1','true','si','sí','completado')
        if not done and r.get('fecha_gestion_super'):
            done = True
        if not done:
            tip1 = r.get('tip_super_1')
            tip2 = r.get('tip_super_2')
            tip2_norm = str(tip2 or '').strip().lower()
            pending2 = (
                tip2_norm == 'en predio' or
                tip2_norm == 'cliente no atiende' or
                tip2_norm == 'reprogramar' or
                ('reprogramar' in tip2_norm) or
                ('cliente no atiende' in tip2_norm)
            )
            if tip2 and str(tip2).strip():
                done = not pending2
            elif tip1 and str(tip1).strip():
                done = True
        if not done:
            pending += 1
    cur.close(); c.close()
    return pending

def _send_push_to_user(user_id, title, body, tag, data):
    conn = get_db_connection()
    if not conn:
        return False
    try:
        cur = conn.cursor(dictionary=True)
        cur.execute("SELECT id, subscription_json FROM webpush_subscriptions WHERE user_id = %s", (str(user_id),))
        subs = cur.fetchall() or []
        payload = json.dumps({'title': title, 'body': body, 'tag': tag, 'data': data})
        ok = False
        for s in subs:
            try:
                info = json.loads(s.get('subscription_json') or '{}')
                webpush(
                    subscription_info=info,
                    data=payload,
                    vapid_private_key=VAPID_PRIVATE_KEY,
                    vapid_claims={'sub': VAPID_SUBJECT}
                )
                ok = True
            except Exception:
                pass
        cur.close(); conn.close()
        return ok
    except Exception:
        try:
            conn.close()
        except Exception:
            pass
        return False

@app.route('/api/operativo/cierre-ciclo/push-pending', methods=['POST'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo_push_pending():
    try:
        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        if not user_id:
            return jsonify({'success': False, 'message': 'Usuario no autenticado'}), 401
        data = request.get_json(silent=True) or {}
        fecha_arg = (data.get('fecha') or '').strip()
        tip_arg = (data.get('tip') or '').strip() or 'CLIENTE INCONFORME'
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        pending_today = _compute_pending_cierres(connection, fecha_arg, tip_arg)
        pending_backlog = _compute_pending_cierres_backlog(connection, tip_arg)
        pending_total = int(pending_today) + int(pending_backlog)
        title = 'Cierres de ciclo pendientes'
        body = f'Hoy: {pending_today} • Días anteriores: {pending_backlog}'
        tag = 'cierre-ciclo'
        data_payload = {'url': '/operativo/cierre-ciclo'}
        sent = _send_push_to_user(user_id, title, body, tag, data_payload)
        return jsonify({'success': True, 'pending': pending_today, 'backlog': pending_backlog, 'total': pending_total, 'sent': bool(sent)})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/pending-backlog', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo_pending_backlog():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        tip_arg = request.args.get('tip', '').strip()
        pending = _compute_pending_cierres_backlog(connection, tip_arg)
        return jsonify({'success': True, 'pending': pending})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/operativo/cierre-ciclo/pending-month', methods=['GET'])
@login_required_api(role=['operativo','tecnico','tecnicos'])
def api_operativo_cierre_ciclo_pending_month():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        tip_arg = request.args.get('tip', '').strip() or 'CLIENTE INCONFORME'
        pending = _compute_pending_cierres_month(connection, tip_arg)
        return jsonify({'success': True, 'pending': pending})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/asignacion/<int:id_asignacion>')
@login_required()
@role_required('logistica')
def ver_detalle_asignacion(id_asignacion):
    connection = None
    cursor = None
    
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener los detalles de la asignación
        cursor.execute("""
            SELECT a.*, r.nombre, r.recurso_operativo_cedula, r.cargo
            FROM asignacion a 
            LEFT JOIN recurso_operativo r ON a.id_codigo_consumidor = r.id_codigo_consumidor 
            WHERE a.id_asignacion = %s
        """, (id_asignacion,))
        
        asignacion = cursor.fetchone()
        
        if not asignacion:
            return jsonify({
                'status': 'error',
                'message': 'No se encontró la asignación'
            }), 404

        # Función auxiliar para formatear valores
        def formatear_valor(valor):
            if valor is None:
                return '0'
            return str(valor)

        # Organizar los datos
        detalles = {
            'info_basica': {
                'tecnico': asignacion['nombre'],
                'cedula': asignacion['recurso_operativo_cedula'],
                'cargo': asignacion.get('asignacion_cargo', 'No especificado'),
                'fecha': asignacion['asignacion_fecha'].strftime('%Y-%m-%d %H:%M:%S'),
                'estado': 'Activo' if str(asignacion.get('asignacion_estado', '0')) == '1' else 'Inactivo'
            },
            'herramientas_basicas': {
                'adaptador_mandril': formatear_valor(asignacion.get('asignacion_adaptador_mandril')),
                'alicate': formatear_valor(asignacion.get('asignacion_alicate')),
                'barra_45cm': formatear_valor(asignacion.get('asignacion_barra_45cm')),
                'bisturi_metalico': formatear_valor(asignacion.get('asignacion_bisturi_metalico')),
                'caja_de_herramientas': formatear_valor(asignacion.get('asignacion_caja_de_herramientas')),
                'cortafrio': formatear_valor(asignacion.get('asignacion_cortafrio')),
                'destor_de_estrella': formatear_valor(asignacion.get('asignacion_destor_de_estrella')),
                'destor_de_pala': formatear_valor(asignacion.get('asignacion_destor_de_pala')),
                'destor_tester': formatear_valor(asignacion.get('asignacion_destor_tester')),
                'espatula': formatear_valor(asignacion.get('asignacion_espatula')),
                'martillo_de_una': formatear_valor(asignacion.get('asignacion_martillo_de_una')),
                'pinza_de_punta': formatear_valor(asignacion.get('asignacion_pinza_de_punta'))
            },
            'brocas': {
                'broca_3/8': formatear_valor(asignacion.get('asignacion_broca_3/8')),
                'broca_3/8/6_ran': formatear_valor(asignacion.get('asignacion_broca_3/8/6_ran')),
                'broca_1/2/6_ran': formatear_valor(asignacion.get('asignacion_broca_1/2/6_ran')),
                'broca_metal/madera_1/4': formatear_valor(asignacion.get('asignacion_broca_metal/madera_1/4')),
                'broca_metal/madera_3/8': formatear_valor(asignacion.get('asignacion_broca_metal/madera_3/8')),
                'broca_metal/madera_5/16': formatear_valor(asignacion.get('asignacion_broca_metal/madera_5/16'))
            },
            'herramientas_red': {
                'cajon_rojo': formatear_valor(asignacion.get('asignacion_cajon_rojo')),
                'cinta_de_senal': formatear_valor(asignacion.get('asignacion_cinta_de_senal')),
                'cono_retractil': formatear_valor(asignacion.get('asignacion_cono_retractil')),
                'exten_de_corr_10_mts': formatear_valor(asignacion.get('asignacion_exten_de_corr_10_mts')),
                'llave_locking_male': formatear_valor(asignacion.get('asignacion_llave_locking_male')),
                'llave_reliance': formatear_valor(asignacion.get('asignacion_llave_reliance')),
                'llave_torque_rg_11': formatear_valor(asignacion.get('asignacion_llave_torque_rg_11')),
                'llave_torque_rg_6': formatear_valor(asignacion.get('asignacion_llave_torque_rg_6')),
                'llaves_mandril': formatear_valor(asignacion.get('asignacion_llaves_mandril')),
                'mandril_para_taladro': formatear_valor(asignacion.get('asignacion_mandril_para_taladro')),
                'pelacable_rg_6y_rg_11': formatear_valor(asignacion.get('asignacion_pelacable_rg_6y_rg_11')),
                'pistola_de_silicona': formatear_valor(asignacion.get('asignacion_pistola_de_silicona')),
                'planillero': formatear_valor(asignacion.get('asignacion_planillero')),
                'ponchadora_rg_6_y_rg_11': formatear_valor(asignacion.get('asignacion_ponchadora_rg_6_y_rg_11')),
                'ponchadora_rj_45_y_rj11': formatear_valor(asignacion.get('asignacion_ponchadora_rj_45_y_rj11')),
                'probador_de_tonos': formatear_valor(asignacion.get('asignacion_probador_de_tonos')),
                'probador_de_tonos_utp': formatear_valor(asignacion.get('asignacion_probador_de_tonos_utp')),
                'puntas_para_multimetro': formatear_valor(asignacion.get('asignacion_puntas_para_multimetro')),
                'sonda_metalica': formatear_valor(asignacion.get('asignacion_sonda_metalica')),
                'tacos_de_madera': formatear_valor(asignacion.get('asignacion_tacos_de_madera')),
                'telefono_de_pruebas': formatear_valor(asignacion.get('asignacion_telefono_de_pruebas')),
                'power_miter': formatear_valor(asignacion.get('asignacion_power_miter')),
                'bfl_laser': formatear_valor(asignacion.get('asignacion_bfl_laser')),
                'cortadora': formatear_valor(asignacion.get('asignacion_cortadora')),
                'stripper_fibra': formatear_valor(asignacion.get('asignacion_stripper_fibra')),
                'pelachaqueta': formatear_valor(asignacion.get('asignacion_pelachaqueta'))
            }
        }

        print("Detalles a enviar:", detalles)  # Debug log
        
        return jsonify({
            'status': 'success',
            'data': detalles
        })

    except Exception as e:
        print(f"Error al obtener detalles de asignación: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener detalles de la asignación: {str(e)}'
        }), 500
        
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/exportar_asignaciones_csv')
@login_required()
@role_required('logistica')
def exportar_asignaciones_csv():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todas las asignaciones con información del técnico
        cursor.execute("""
            SELECT 
                a.*,
                r.nombre as nombre_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico,
                r.cargo as cargo_tecnico
            FROM asignacion a 
            LEFT JOIN recurso_operativo r ON a.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY a.asignacion_fecha DESC
        """)
        asignaciones = cursor.fetchall()
        
        # Crear archivo CSV en memoria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escribir encabezados
        writer.writerow([
            'ID Asignación',
            'Fecha',
            'Técnico',
            'Cédula',
            'Cargo',
            'Estado',
            'Adaptador Mandril',
            'Alicate',
            'Barra 45cm',
            'Bisturí Metálico',
            'Caja de Herramientas',
            'Cortafrío',
            'Destornillador Estrella',
            'Destornillador Pala',
            'Destornillador Tester',
            'Martillo',
            'Pinza de Punta',
            'Multímetro',
            'Taladro Percutor',
            'Ponchadora RG6/RG11',
            'Ponchadora RJ45/RJ11',
            'Power Meter',
            'BFL Laser',
            'Cortadora',
            'Stripper Fibra',
            'Arnés',
            'Eslinga',
            'Casco Tipo II',
            'Araña Casco',
            'Barbuquejo',
            'Guantes de Vaqueta',
            'Gafas',
            'Línea de Vida'
        ])
        
        # Escribir datos
        for asignacion in asignaciones:
            writer.writerow([
                asignacion['id_asignacion'],
                asignacion['asignacion_fecha'].strftime('%Y-%m-%d %H:%M:%S'),
                asignacion.get('nombre_tecnico', 'No asignado'),
                asignacion.get('cedula_tecnico', 'No disponible'),
                asignacion.get('asignacion_cargo', 'No especificado'),
                'Activo' if str(asignacion.get('asignacion_estado', '0')) == '1' else 'Inactivo',
                asignacion.get('asignacion_adaptador_mandril', '0'),
                asignacion.get('asignacion_alicate', '0'),
                asignacion.get('asignacion_barra_45cm', '0'),
                asignacion.get('asignacion_bisturi_metalico', '0'),
                asignacion.get('asignacion_caja_de_herramientas', '0'),
                asignacion.get('asignacion_cortafrio', '0'),
                asignacion.get('asignacion_destor_de_estrella', '0'),
                asignacion.get('asignacion_destor_de_pala', '0'),
                asignacion.get('asignacion_destor_tester', '0'),
                asignacion.get('asignacion_martillo_de_una', '0'),
                asignacion.get('asignacion_pinza_de_punta', '0'),
                asignacion.get('asignacion_multimetro', '0'),
                asignacion.get('asignacion_taladro_percutor', '0'),
                asignacion.get('asignacion_ponchadora_rg_6_y_rg_11', '0'),
                asignacion.get('asignacion_ponchadora_rj_45_y_rj11', '0'),
                asignacion.get('asignacion_power_miter', '0'),
                asignacion.get('asignacion_bfl_laser', '0'),
                asignacion.get('asignacion_cortadora', '0'),
                asignacion.get('asignacion_stripper_fibra', '0'),
                
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8-sig')),  # Usar UTF-8 con BOM para soporte de caracteres especiales
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'asignaciones_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/inventario')
@login_required()
@role_required('logistica')
def ver_inventario():
    try:
        # Verificar stock bajo para mostrar alertas
        materiales_problematicos = verificar_stock_bajo()
        
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
                               
        cursor = connection.cursor(dictionary=True)
        
        # Obtener conteo de herramientas básicas asignadas
        herramientas_basicas_query = """
            SELECT 
                SUM(asignacion_adaptador_mandril) as adaptador_mandril,
                SUM(asignacion_alicate) as alicate,
                SUM(asignacion_barra_45cm) as barra_45cm,
                SUM(asignacion_bisturi_metalico) as bisturi_metalico,
                SUM(asignacion_caja_de_herramientas) as caja_herramientas,
                SUM(asignacion_cortafrio) as cortafrio,
                SUM(asignacion_destor_de_estrella) as destornillador_estrella,
                SUM(asignacion_destor_de_pala) as destornillador_pala,
                SUM(asignacion_destor_tester) as destornillador_tester,
                SUM(asignacion_martillo_de_una) as martillo,
                SUM(asignacion_pinza_de_punta) as pinza_punta
            FROM asignacion 
            WHERE asignacion_estado = '1'
        """
        cursor.execute(herramientas_basicas_query)
        herramientas_basicas = cursor.fetchone()
        
        # Obtener conteo de herramientas especializadas asignadas
        herramientas_especializadas_query = """
            SELECT 
                SUM(asignacion_multimetro) as multimetro,
                SUM(asignacion_taladro_percutor) as taladro_percutor,
                SUM(asignacion_ponchadora_rg_6_y_rg_11) as ponchadora_rg6_rg11,
                SUM(asignacion_ponchadora_rj_45_y_rj11) as ponchadora_rj45_rj11,
                SUM(asignacion_power_miter) as power_meter,
                SUM(asignacion_bfl_laser) as bfl_laser,
                SUM(asignacion_cortadora) as cortadora,
                SUM(asignacion_stripper_fibra) as stripper_fibra
            FROM asignacion 
            WHERE asignacion_estado = '1'
        """
        cursor.execute(herramientas_especializadas_query)
        herramientas_especializadas = cursor.fetchone()
        
       

        # Obtener conteo de material ferretero asignado
        material_ferretero_query = """
            SELECT 
                SUM(silicona) as silicona,
                SUM(amarres_negros) as amarres_negros,
                SUM(amarres_blancos) as amarres_blancos,
                SUM(cinta_aislante) as cinta_aislante,
                SUM(grapas_blancas) as grapas_blancas,
                SUM(grapas_negras) as grapas_negras
            FROM ferretero
        """
        cursor.execute(material_ferretero_query)
        material_ferretero = cursor.fetchone()
        
        # Obtener historial de movimientos de inventario (para gráficos de tendencia)
        historial_movimientos_query = """
            SELECT 
                DATE(fecha_movimiento) as fecha,
                tipo_movimiento,
                item_afectado,
                cantidad,
                usuario,
                ubicacion
            FROM movimientos_inventario
            ORDER BY fecha_movimiento DESC
            LIMIT 100
        """
        cursor.execute(historial_movimientos_query)
        historial_movimientos = cursor.fetchall()
        
        # Generar datos para gráficos de tendencias
        ultimos_30_dias = []
        hoy = datetime.now().date()
        for i in range(30, -1, -1):
            fecha = hoy - timedelta(days=i)
            ultimos_30_dias.append(fecha.strftime('%Y-%m-%d'))
        
        # Conteo de movimientos por fecha para gráfico de tendencia
        movimientos_por_dia = {}
        for fecha in ultimos_30_dias:
            movimientos_por_dia[fecha] = 0
            
        for movimiento in historial_movimientos:
            fecha_str = movimiento['fecha'].strftime('%Y-%m-%d')
            if fecha_str in movimientos_por_dia:
                movimientos_por_dia[fecha_str] += 1
                
        # Conteo por categoría para gráficos de distribución
        categorias = {
            'Herramientas Básicas': sum(value for key, value in herramientas_basicas.items() if value is not None),
            'Herramientas Especializadas': sum(value for key, value in herramientas_especializadas.items() if value is not None),
            'Material Ferretero': sum(value for key, value in material_ferretero.items() if value is not None)
        }
        
        # Información para alertas (items con nivel crítico)
        items_criticos = []
        
        # Definir umbrales para cada tipo de elemento
        umbrales_minimos = {
            'adaptador_mandril': 5, 'alicate': 10, 'barra_45cm': 5,
            'bisturi_metalico': 15, 'caja_herramientas': 10, 'cortafrio': 10,
            'destornillador_estrella': 15, 'destornillador_pala': 15,
            'destornillador_tester': 10, 'martillo': 10, 'pinza_punta': 10,
            'multimetro': 5, 'taladro_percutor': 3, 'ponchadora_rg6_rg11': 5,
            'ponchadora_rj45_rj11': 5, 'power_meter': 3, 'bfl_laser': 3,
            'cortadora': 3, 'stripper_fibra': 3, 'arnes': 10, 'eslinga': 10,
            'casco_tipo_ii': 20, 'arana_casco': 20, 'barbuquejo': 20,
            'guantes_vaqueta': 30, 'gafas': 30, 'linea_vida': 5,
            'silicona': 10, 'amarres_negros': 50, 'amarres_blancos': 50,
            'cinta_aislante': 20, 'grapas_blancas': 100, 'grapas_negras': 100
        }
        
        # Verificar herramientas básicas bajo umbral
        for key, value in herramientas_basicas.items():
            if key in umbrales_minimos and value is not None:
                if value <= umbrales_minimos[key]:
                    nombre_item = key.replace('_', ' ').title()
                    items_criticos.append({
                        'item': nombre_item, 
                        'actual': value, 
                        'minimo': umbrales_minimos[key],
                        'categoria': 'Herramientas Básicas'
                    })
        
        # Verificar herramientas especializadas bajo umbral
        for key, value in herramientas_especializadas.items():
            if key in umbrales_minimos and value is not None:
                if value <= umbrales_minimos[key]:
                    nombre_item = key.replace('_', ' ').title()
                    items_criticos.append({
                        'item': nombre_item, 
                        'actual': value, 
                        'minimo': umbrales_minimos[key],
                        'categoria': 'Herramientas Especializadas'
                    })
        
      
        
        # Verificar material ferretero bajo umbral
        for key, value in material_ferretero.items():
            if key in umbrales_minimos and value is not None:
                if value <= umbrales_minimos[key]:
                    nombre_item = key.replace('_', ' ').title()
                    items_criticos.append({
                        'item': nombre_item, 
                        'actual': value, 
                        'minimo': umbrales_minimos[key],
                        'categoria': 'Material Ferretero'
                    })
        
        # Obtener datos para comparativa periódica (mes actual vs mes anterior)
        # Esta es una simulación - en un caso real se obtendría de los registros históricos
        mes_actual = datetime.now().month
        año_actual = datetime.now().year
        
        comparativa_meses = {
            'labels': ['Mes Anterior', 'Mes Actual'],
            'datos': [215, 243]  # Datos de ejemplo
        }
        
        # Simulación de datos para ubicaciones
        ubicaciones = [
            {'nombre': 'Almacén Principal', 'items': 452},
            {'nombre': 'Bodega Norte', 'items': 230},
            {'nombre': 'Bodega Sur', 'items': 195},
            {'nombre': 'Vehículos', 'items': 123},
            {'nombre': 'Personal', 'items': 87}
        ]
        
        cursor.close()
        connection.close()

        return render_template('modulos/logistica/inventario.html',
                           herramientas_basicas=herramientas_basicas,
                           herramientas_especializadas=herramientas_especializadas,
                           
                           material_ferretero=material_ferretero,
                           historial_movimientos=historial_movimientos,
                           movimientos_por_dia=movimientos_por_dia,
                           ultimos_30_dias=ultimos_30_dias,
                           categorias=categorias,
                           items_criticos=items_criticos,
                           comparativa_meses=comparativa_meses,
                           ubicaciones=ubicaciones,
                           materiales_problematicos=materiales_problematicos)

    except Exception as e:
        print(f"Error al obtener inventario: {str(e)}")
        return render_template('error.html',
                           mensaje='Error al cargar el inventario',
                           error=str(e))

@app.route('/logistica/ferretero')
@login_required()
@role_required('logistica')
def ver_asignaciones_ferretero():
    try:
        # Verificar stock bajo para mostrar alertas
        materiales_problematicos = verificar_stock_bajo()
        
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
                               
        cursor = connection.cursor(dictionary=True)
        
        # Filtro de fecha: mostrar solo registros del día seleccionado (por defecto, hoy)
        fecha_seleccionada = request.args.get('fecha') or datetime.now().strftime('%Y-%m-%d')
        cursor.execute("""
            SELECT f.*, r.nombre, r.recurso_operativo_cedula, r.cargo
            FROM ferretero f 
            LEFT JOIN recurso_operativo r ON f.id_codigo_consumidor = r.id_codigo_consumidor 
            WHERE DATE(f.fecha_asignacion) = %s
            ORDER BY f.fecha_asignacion DESC
        """, (fecha_seleccionada,))
        asignaciones = cursor.fetchall()

        # Obtener lista de técnicos disponibles
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula, cargo, carpeta 
            FROM recurso_operativo 
            WHERE cargo LIKE '%TECNICO%' OR cargo LIKE '%TÉCNICO%'
            ORDER BY nombre
        """)
        tecnicos = cursor.fetchall()
        
        # Preparar información de límites para cada técnico
        fecha_actual = datetime.now()
        tecnicos_con_limites = []
        
        # Función para obtener límites desde la base de datos
        def obtener_limites_desde_db(cursor):
            """Obtiene los límites configurables desde la base de datos"""
            try:
                cursor.execute("""
                    SELECT 
                        area_trabajo,
                        material_tipo,
                        cantidad_limite,
                        periodo_dias,
                        unidad_medida
                    FROM limites_ferretero 
                    WHERE activo = TRUE
                    ORDER BY area_trabajo, material_tipo
                """)
                limites_db = cursor.fetchall()
                
                # Convertir a estructura de diccionario
                limites = {}
                for limite in limites_db:
                    area = limite['area_trabajo']
                    material = limite['material_tipo']
                    
                    if area not in limites:
                        limites[area] = {}
                    
                    limites[area][material] = {
                        'cantidad': limite['cantidad_limite'],
                        'periodo': limite['periodo_dias'],
                        'unidad': limite['unidad_medida']
                    }
                
                return limites
                
            except Exception as e:
                print(f"Error al obtener límites desde DB: {str(e)}")
                # Fallback a límites por defecto en caso de error
                return {
                    'FTTH INSTALACIONES': {
                        'cinta_aislante': {'cantidad': 3, 'periodo': 15, 'unidad': 'días'},
                        'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                        'amarres_negros': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                        'amarres_blancos': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                        'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                        'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
                    }
                }
        
        # Obtener límites configurables desde la base de datos
        limites = obtener_limites_desde_db(cursor)
        
        for tecnico in tecnicos:
            # Determinar área de trabajo basada EXCLUSIVAMENTE en la carpeta asignada
            carpeta = tecnico.get('carpeta', '').upper() if tecnico.get('carpeta') else ''
            
            area_trabajo = None
            
            # Buscar coincidencia exacta en la carpeta del técnico
            if carpeta:
                for area in limites.keys():
                    if area in carpeta:
                        area_trabajo = area
                        print(f"INFO: Técnico {tecnico.get('nombre', 'N/A')} - Carpeta: '{carpeta}' -> Área asignada: '{area_trabajo}'")
                        break
            
            # Si no se encuentra carpeta válida, mostrar error y omitir técnico
            if area_trabajo is None:
                print(f"ERROR: Técnico {tecnico.get('nombre', 'N/A')} - Carpeta '{carpeta}' no está configurada para límites de ferretero")
                continue  # Omitir este técnico de la lista
            
            # Obtener asignaciones previas para este técnico
            cursor.execute("""
                SELECT 
                    fecha_asignacion,
                    silicona,
                    amarres_negros,
                    amarres_blancos,
                    cinta_aislante,
                    grapas_blancas,
                    grapas_negras
                FROM ferretero 
                WHERE id_codigo_consumidor = %s
                ORDER BY fecha_asignacion DESC
            """, (tecnico['id_codigo_consumidor'],))
            asignaciones_tecnico = cursor.fetchall()
            
            # Inicializar contadores para materiales en los períodos correspondientes
            contadores = {
                'cinta_aislante': 0,
                'silicona': 0,
                'amarres_negros': 0,
                'amarres_blancos': 0,
                'grapas_blancas': 0,
                'grapas_negras': 0
            }
            
            lim_area = limites.get(area_trabajo, {})
            for asignacion in asignaciones_tecnico:
                fecha_asignacion = asignacion['fecha_asignacion']
                diferencia_dias = (fecha_actual - fecha_asignacion).days
                if diferencia_dias <= lim_area.get('cinta_aislante', {}).get('periodo', 0):
                    contadores['cinta_aislante'] += int(asignacion.get('cinta_aislante', 0) or 0)
                if diferencia_dias <= lim_area.get('silicona', {}).get('periodo', 0):
                    contadores['silicona'] += int(asignacion.get('silicona', 0) or 0)
                if diferencia_dias <= lim_area.get('amarres_negros', {}).get('periodo', 0):
                    contadores['amarres_negros'] += int(asignacion.get('amarres_negros', 0) or 0)
                if diferencia_dias <= lim_area.get('amarres_blancos', {}).get('periodo', 0):
                    contadores['amarres_blancos'] += int(asignacion.get('amarres_blancos', 0) or 0)
                if diferencia_dias <= lim_area.get('grapas_blancas', {}).get('periodo', 0):
                    contadores['grapas_blancas'] += int(asignacion.get('grapas_blancas', 0) or 0)
                if diferencia_dias <= lim_area.get('grapas_negras', {}).get('periodo', 0):
                    contadores['grapas_negras'] += int(asignacion.get('grapas_negras', 0) or 0)
            
            # Calcular límites disponibles
            limites_disponibles = {
                'area': area_trabajo,
                'cinta_aislante': max(0, lim_area.get('cinta_aislante', {}).get('cantidad', 0) - contadores['cinta_aislante']),
                'silicona': max(0, lim_area.get('silicona', {}).get('cantidad', 0) - contadores['silicona']),
                'amarres_negros': max(0, lim_area.get('amarres_negros', {}).get('cantidad', 0) - contadores['amarres_negros']),
                'amarres_blancos': max(0, lim_area.get('amarres_blancos', {}).get('cantidad', 0) - contadores['amarres_blancos']),
                'grapas_blancas': max(0, lim_area.get('grapas_blancas', {}).get('cantidad', 0) - contadores['grapas_blancas']),
                'grapas_negras': max(0, lim_area.get('grapas_negras', {}).get('cantidad', 0) - contadores['grapas_negras']),
                'periodos': {
                    'cinta_aislante': f"{lim_area.get('cinta_aislante', {}).get('periodo', 0)} {lim_area.get('cinta_aislante', {}).get('unidad', 'días')}",
                    'silicona': f"{lim_area.get('silicona', {}).get('periodo', 0)} {lim_area.get('silicona', {}).get('unidad', 'días')}",
                    'amarres_negros': f"{lim_area.get('amarres_negros', {}).get('periodo', 0)} {lim_area.get('amarres_negros', {}).get('unidad', 'días')}",
                    'amarres_blancos': f"{lim_area.get('amarres_blancos', {}).get('periodo', 0)} {lim_area.get('amarres_blancos', {}).get('unidad', 'días')}",
                    'grapas_blancas': f"{lim_area.get('grapas_blancas', {}).get('periodo', 0)} {lim_area.get('grapas_blancas', {}).get('unidad', 'días')}",
                    'grapas_negras': f"{lim_area.get('grapas_negras', {}).get('periodo', 0)} {lim_area.get('grapas_negras', {}).get('unidad', 'días')}",
                }
            }
            
            # Agregar información de límites al técnico
            tecnico_con_limites = {**tecnico, 'limites': limites_disponibles}
            tecnicos_con_limites.append(tecnico_con_limites)
        
        cursor.close()
        connection.close()

        return render_template('modulos/logistica/ferretero.html', 
                            asignaciones=asignaciones,
                            tecnicos=tecnicos_con_limites,
                            materiales_problematicos=materiales_problematicos,
                            fecha_seleccionada=fecha_seleccionada)

    except Exception as e:
        print(f"Error al obtener asignaciones ferretero: {str(e)}")
        return render_template('error.html', 
                           mensaje='Error al cargar las asignaciones de material ferretero',
                           error=str(e))

@app.route('/logistica/registrar_ferretero', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_ferretero():
    connection = None
    cursor = None
    try:
        # Obtener datos básicos
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha = request.form.get('fecha')
        
        # Obtener cantidades de materiales
        silicona = request.form.get('silicona', '0')
        amarres_negros = request.form.get('amarres_negros', '0')
        amarres_blancos = request.form.get('amarres_blancos', '0')
        cinta_aislante = request.form.get('cinta_aislante', '0')
        grapas_blancas = request.form.get('grapas_blancas', '0')
        grapas_negras = request.form.get('grapas_negras', '0')

        # Validar campos requeridos
        if not all([id_codigo_consumidor, fecha]):
            return jsonify({
                'status': 'error',
                'message': 'El ID del técnico y la fecha son requeridos'
            }), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar que el técnico existe y obtener su área de trabajo (carpeta)
        cursor.execute('SELECT nombre, cargo, carpeta FROM recurso_operativo WHERE id_codigo_consumidor = %s', (id_codigo_consumidor,))
        tecnico = cursor.fetchone()
        
        if not tecnico:
            return jsonify({
                'status': 'error',
                'message': 'El técnico seleccionado no existe'
            }), 404
            
        # Obtener la fecha actual para cálculos
        fecha_actual = datetime.now()
        
        # Verificar asignaciones previas del técnico para controlar los límites
        cursor.execute("""
            SELECT 
                fecha_asignacion,
                silicona,
                amarres_negros,
                amarres_blancos,
                cinta_aislante,
                grapas_blancas,
                grapas_negras
            FROM ferretero 
            WHERE id_codigo_consumidor = %s
            ORDER BY fecha_asignacion DESC
        """, (id_codigo_consumidor,))
        asignaciones_previas = cursor.fetchall()
        
        # Determinar la carpeta del técnico (EXCLUSIVAMENTE)
        carpeta = tecnico.get('carpeta', '').upper() if tecnico.get('carpeta') else ''
        
        # Función para obtener límites desde la base de datos
        def obtener_limites_desde_db(cursor):
            """Obtiene los límites configurables desde la base de datos"""
            try:
                cursor.execute("""
                    SELECT 
                        area_trabajo,
                        material_tipo,
                        cantidad_limite,
                        periodo_dias,
                        unidad_medida
                    FROM limites_ferretero 
                    WHERE activo = TRUE
                    ORDER BY area_trabajo, material_tipo
                """)
                limites_db = cursor.fetchall()
                
                # Convertir a estructura de diccionario
                limites = {}
                for limite in limites_db:
                    area = limite['area_trabajo']
                    material = limite['material_tipo']
                    
                    if area not in limites:
                        limites[area] = {}
                    
                    limites[area][material] = {
                        'cantidad': limite['cantidad_limite'],
                        'periodo': limite['periodo_dias'],
                        'unidad': limite['unidad_medida']
                    }
                
                return limites
                
            except Exception as e:
                print(f"Error al obtener límites desde DB: {str(e)}")
                # Fallback a límites por defecto en caso de error
                return {
                    'FTTH INSTALACIONES': {
                        'cinta_aislante': {'cantidad': 3, 'periodo': 15, 'unidad': 'días'},
                        'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                        'amarres_negros': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                        'amarres_blancos': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                        'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                        'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
                    }
                }
        
        # Obtener límites configurables desde la base de datos
        limites = obtener_limites_desde_db(cursor)
        
        # Determinar área de trabajo basada EXCLUSIVAMENTE en la carpeta asignada
        area_trabajo = None
        
        # Buscar coincidencia exacta en la carpeta del técnico
        if carpeta:
            for area in limites.keys():
                if area in carpeta:
                    area_trabajo = area
                    print(f"INFO: Técnico {tecnico.get('nombre', 'N/A')} - Carpeta: '{carpeta}' -> Área asignada: '{area_trabajo}'")
                    break
        
        # Si no se encuentra carpeta válida, rechazar la asignación
        if area_trabajo is None:
            error_msg = f"La carpeta '{carpeta}' del técnico {tecnico.get('nombre', 'N/A')} no está configurada para límites de ferretero. Carpetas válidas: {', '.join(limites.keys())}"
            print(f"ERROR: {error_msg}")
            return jsonify({
                'status': 'error',
                'message': error_msg
            }), 400
        
        contadores = {
            'cinta_aislante': 0,
            'silicona': 0,
            'amarres_negros': 0,
            'amarres_blancos': 0,
            'grapas_blancas': 0,
            'grapas_negras': 0
        }
        lim_area = limites.get(area_trabajo, {})
        for asignacion in asignaciones_previas:
            fecha_asignacion = asignacion['fecha_asignacion']
            diferencia_dias = (fecha_actual - fecha_asignacion).days
            if diferencia_dias <= lim_area.get('cinta_aislante', {}).get('periodo', 0):
                contadores['cinta_aislante'] += int(asignacion.get('cinta_aislante', 0) or 0)
            if diferencia_dias <= lim_area.get('silicona', {}).get('periodo', 0):
                contadores['silicona'] += int(asignacion.get('silicona', 0) or 0)
            if diferencia_dias <= lim_area.get('amarres_negros', {}).get('periodo', 0):
                contadores['amarres_negros'] += int(asignacion.get('amarres_negros', 0) or 0)
            if diferencia_dias <= lim_area.get('amarres_blancos', {}).get('periodo', 0):
                contadores['amarres_blancos'] += int(asignacion.get('amarres_blancos', 0) or 0)
            if diferencia_dias <= lim_area.get('grapas_blancas', {}).get('periodo', 0):
                contadores['grapas_blancas'] += int(asignacion.get('grapas_blancas', 0) or 0)
            if diferencia_dias <= lim_area.get('grapas_negras', {}).get('periodo', 0):
                contadores['grapas_negras'] += int(asignacion.get('grapas_negras', 0) or 0)
        
        # Calcular cantidades de la asignación actual
        cintas_solicitadas = int(cinta_aislante or 0)
        siliconas_solicitadas = int(silicona or 0)
        amarres_negros_solicitados = int(amarres_negros or 0)
        amarres_blancos_solicitados = int(amarres_blancos or 0)
        grapas_blancas_solicitadas = int(grapas_blancas or 0)
        grapas_negras_solicitadas = int(grapas_negras or 0)
        
        # Validaciones de límites con asignación parcial
        materiales_rechazados = []
        materiales_asignados = []
        
        # Validar cintas
        if contadores['cinta_aislante'] + cintas_solicitadas > lim_area.get('cinta_aislante', {}).get('cantidad', 0):
            limite = lim_area.get('cinta_aislante', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Cinta aislante: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['cinta_aislante']}.")
            cintas_solicitadas = 0
            cinta_aislante = 0
        elif cintas_solicitadas > 0:
            materiales_asignados.append(f"Cinta aislante: {cintas_solicitadas} unidades")
        
        # Validar siliconas
        if contadores['silicona'] + siliconas_solicitadas > lim_area.get('silicona', {}).get('cantidad', 0):
            limite = lim_area.get('silicona', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Silicona: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['silicona']}.")
            siliconas_solicitadas = 0
            silicona = 0
        elif siliconas_solicitadas > 0:
            materiales_asignados.append(f"Silicona: {siliconas_solicitadas} unidades")
        
        # Validar amarres negros
        if contadores['amarres_negros'] + amarres_negros_solicitados > lim_area.get('amarres_negros', {}).get('cantidad', 0):
            limite = lim_area.get('amarres_negros', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Amarres negros: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['amarres_negros']}.")
            amarres_negros_solicitados = 0
            amarres_negros = 0
        elif amarres_negros_solicitados > 0:
            materiales_asignados.append(f"Amarres negros: {amarres_negros_solicitados} unidades")
        
        # Validar amarres blancos
        if contadores['amarres_blancos'] + amarres_blancos_solicitados > lim_area.get('amarres_blancos', {}).get('cantidad', 0):
            limite = lim_area.get('amarres_blancos', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Amarres blancos: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['amarres_blancos']}.")
            amarres_blancos_solicitados = 0
            amarres_blancos = 0
        elif amarres_blancos_solicitados > 0:
            materiales_asignados.append(f"Amarres blancos: {amarres_blancos_solicitados} unidades")
        
        # Validar grapas blancas
        if contadores['grapas_blancas'] + grapas_blancas_solicitadas > lim_area.get('grapas_blancas', {}).get('cantidad', 0):
            limite = lim_area.get('grapas_blancas', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Grapas blancas: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['grapas_blancas']}.")
            grapas_blancas_solicitadas = 0
            grapas_blancas = 0
        elif grapas_blancas_solicitadas > 0:
            materiales_asignados.append(f"Grapas blancas: {grapas_blancas_solicitadas} unidades")
        
        # Validar grapas negras
        if contadores['grapas_negras'] + grapas_negras_solicitadas > lim_area.get('grapas_negras', {}).get('cantidad', 0):
            limite = lim_area.get('grapas_negras', {'cantidad': 0, 'periodo': 0, 'unidad': 'días'})
            materiales_rechazados.append(f"Grapas negras: excede el límite de {limite['cantidad']} cada {limite['periodo']} {limite['unidad']} para {area_trabajo}. Ya se han asignado {contadores['grapas_negras']}.")
            grapas_negras_solicitadas = 0
            grapas_negras = 0
        elif grapas_negras_solicitadas > 0:
            materiales_asignados.append(f"Grapas negras: {grapas_negras_solicitadas} unidades")
        
        # Si todos los materiales fueron rechazados, rechazar la asignación completa
        if materiales_rechazados and not materiales_asignados:
            return jsonify({
                'status': 'error',
                'message': 'Todos los materiales solicitados exceden los límites permitidos',
                'materiales_rechazados': materiales_rechazados
            }), 400
        
        # Validar stock disponible antes de la asignación
        cursor.execute("""
            SELECT codigo_material, cantidad_disponible 
            FROM stock_general 
            WHERE codigo_material IN ('silicona', 'amarres_negros', 'amarres_blancos', 'cinta_aislante', 'grapas_blancas', 'grapas_negras')
        """)
        stock_results = cursor.fetchall()
        
        # Convertir a diccionario para fácil acceso
        stock_actual = {}
        for row in stock_results:
            stock_actual[row['codigo_material']] = row['cantidad_disponible']
        
        if not stock_actual:
            return jsonify({
                'status': 'error',
                'message': 'No se pudo obtener información del stock actual'
            }), 500
        
        # Verificar stock suficiente para cada material
        errores_stock = []
        
        if siliconas_solicitadas > 0 and stock_actual['silicona'] < siliconas_solicitadas:
            errores_stock.append(f"Stock insuficiente de silicona. Disponible: {stock_actual['silicona']}, Solicitado: {siliconas_solicitadas}")
        
        if amarres_negros_solicitados > 0 and stock_actual['amarres_negros'] < amarres_negros_solicitados:
            errores_stock.append(f"Stock insuficiente de amarres negros. Disponible: {stock_actual['amarres_negros']}, Solicitado: {amarres_negros_solicitados}")
        
        if amarres_blancos_solicitados > 0 and stock_actual['amarres_blancos'] < amarres_blancos_solicitados:
            errores_stock.append(f"Stock insuficiente de amarres blancos. Disponible: {stock_actual['amarres_blancos']}, Solicitado: {amarres_blancos_solicitados}")
        
        if cintas_solicitadas > 0 and stock_actual['cinta_aislante'] < cintas_solicitadas:
            errores_stock.append(f"Stock insuficiente de cinta aislante. Disponible: {stock_actual['cinta_aislante']}, Solicitado: {cintas_solicitadas}")
        
        if grapas_blancas_solicitadas > 0 and stock_actual['grapas_blancas'] < grapas_blancas_solicitadas:
            errores_stock.append(f"Stock insuficiente de grapas blancas. Disponible: {stock_actual['grapas_blancas']}, Solicitado: {grapas_blancas_solicitadas}")
        
        if grapas_negras_solicitadas > 0 and stock_actual['grapas_negras'] < grapas_negras_solicitadas:
            errores_stock.append(f"Stock insuficiente de grapas negras. Disponible: {stock_actual['grapas_negras']}, Solicitado: {grapas_negras_solicitadas}")
        
        # Si hay errores de stock, rechazar la asignación
        if errores_stock:
            return jsonify({
                'status': 'error',
                'message': 'Stock insuficiente para completar la asignación',
                'detalles': errores_stock
            }), 400
        
        # Insertar la asignación
        cursor.execute("""
            INSERT INTO ferretero (
                id_codigo_consumidor, 
                fecha_asignacion,
                silicona,
                amarres_negros,
                amarres_blancos,
                cinta_aislante,
                grapas_blancas,
                grapas_negras
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            id_codigo_consumidor,
            fecha,
            silicona,
            amarres_negros,
            amarres_blancos,
            cinta_aislante,
            grapas_blancas,
            grapas_negras
        ))
        
        # NOTA: El stock y movimientos se actualizan automáticamente mediante el trigger actualizar_stock_asignacion
        # No es necesario actualizar manualmente aquí para evitar descuento duplicado
        
        connection.commit()

        # Preparar mensaje de respuesta con información detallada
        if materiales_rechazados:
            # Asignación parcial
            mensaje = f'Asignación parcial completada para {area_trabajo}'
            return jsonify({
                'status': 'partial_success',
                'message': mensaje,
                'materiales_asignados': materiales_asignados,
                'materiales_rechazados': materiales_rechazados,
                'detalle': f'Se asignaron {len(materiales_asignados)} materiales y se rechazaron {len(materiales_rechazados)} por exceder límites'
            }), 201
        else:
            # Asignación completa
            return jsonify({
                'status': 'success',
                'message': f'Material ferretero asignado exitosamente para {area_trabajo}',
                'materiales_asignados': materiales_asignados
            }), 201

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al registrar la asignación: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/exportar_ferretero_csv')
@login_required()
@role_required('logistica')
def exportar_ferretero_csv():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todas las asignaciones con información del técnico
        cursor.execute("""
            SELECT 
                f.*,
                r.nombre as nombre_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico,
                r.cargo as cargo_tecnico
            FROM ferretero f 
            LEFT JOIN recurso_operativo r ON f.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY f.fecha_asignacion DESC
        """)
        asignaciones = cursor.fetchall()
        
        # Crear archivo CSV en memoria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escribir encabezados
        writer.writerow([
            'ID Asignación',
            'Fecha',
            'Técnico',
            'Cédula',
            'Cargo',
            'Silicona',
            'Amarres Negros',
            'Amarres Blancos',
            'Cinta Aislante',
            'Grapas Blancas',
            'Grapas Negras'
        ])
        
        # Escribir datos
        for asignacion in asignaciones:
            writer.writerow([
                asignacion['id_ferretero'],
                asignacion['fecha_asignacion'].strftime('%Y-%m-%d %H:%M:%S'),
                asignacion.get('nombre_tecnico', 'No asignado'),
                asignacion.get('cedula_tecnico', 'No disponible'),
                asignacion.get('cargo_tecnico', 'No especificado'),
                asignacion.get('silicona', '0'),
                asignacion.get('amarres_negros', '0'),
                asignacion.get('amarres_blancos', '0'),
                asignacion.get('cinta_aislante', '0'),
                asignacion.get('grapas_blancas', '0'),
                asignacion.get('grapas_negras', '0')
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8-sig')),
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'material_ferretero_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/estadisticas_ferretero_page')
@login_required()
@role_required('logistica')
def estadisticas_ferretero_page():
    try:
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
        
        # Obtener lista de técnicos disponibles para filtros
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula, cargo, carpeta 
            FROM recurso_operativo 
            WHERE cargo LIKE '%TECNICO%' OR cargo LIKE '%TÉCNICO%'
            ORDER BY nombre
        """)
        tecnicos = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/logistica/estadisticas_ferretero.html', tecnicos=tecnicos)
    
    except Exception as e:
        print(f"Error al cargar página de estadísticas ferretero: {str(e)}")
        return render_template('error.html', 
                           mensaje='Error al cargar la página de estadísticas de material ferretero',
                           error=str(e))

@app.route('/logistica/estadisticas_ferretero')
@login_required()
@role_required('logistica')
def estadisticas_ferretero():
    connection = None
    cursor = None
    try:
        # Obtener parámetros de filtro
        mes = request.args.get('mes', '')
        material = request.args.get('material', '')
        area = request.args.get('area', '')
        anio = request.args.get('anio', '')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir la consulta base
        query = """
            SELECT 
                f.*,
                r.nombre,
                r.recurso_operativo_cedula,
                r.cargo,
                r.carpeta
            FROM ferretero f 
            LEFT JOIN recurso_operativo r ON f.id_codigo_consumidor = r.id_codigo_consumidor 
            WHERE 1=1
        """
        params = []
        
        # Aplicar filtro por mes (independiente del año)
        if mes and mes != 'todos':
            # Extraer el mes del formato 'YYYY-MM' o usar directamente si es solo el número
            try:
                if '-' in mes:
                    # Formato 'YYYY-MM'
                    mes_numero = int(mes.split('-')[1])
                else:
                    # Solo el número del mes
                    mes_numero = int(mes)
                query += " AND MONTH(f.fecha_asignacion) = %s"
                params.append(mes_numero)
            except (ValueError, IndexError) as e:
                print(f"Error al procesar el parámetro mes '{mes}': {e}")
                # Continuar sin filtro de mes si hay error
                pass
            
        if anio and anio != 'todos':
            try:
                anio_numero = int(anio)
                query += " AND YEAR(f.fecha_asignacion) = %s"
                params.append(anio_numero)
            except ValueError:
                pass
        
        # Aplicar filtro por área
        if area and area != 'todos':
            query += " AND (r.carpeta LIKE %s OR r.cargo LIKE %s)"
            area_param = f'%{area}%'
            params.append(area_param)
            params.append(area_param)
        
        # Ejecutar consulta
        cursor.execute(query, params)
        asignaciones = cursor.fetchall()
        
        # Procesar los datos para estadísticas
        estadisticas_por_tecnico = {}
        areas_distribucion = {}
        
        for asignacion in asignaciones:
            id_tecnico = asignacion['id_codigo_consumidor']
            nombre = asignacion.get('nombre', 'Técnico sin nombre')
            
            # Determinar área de trabajo
            carpeta = asignacion.get('carpeta', '')
            carpeta = carpeta.upper() if carpeta else ''
            cargo = asignacion.get('cargo', '')
            cargo = cargo.upper() if cargo else ''
            
            area_trabajo = 'No especificada'
            areas_posibles = ['FTTH INSTALACIONES', 'INSTALACIONES DOBLES', 'POSTVENTA', 
                             'MANTENIMIENTO FTTH', 'ARREGLOS HFC', 'CONDUCTOR']
            
            for area_posible in areas_posibles:
                if area_posible in carpeta or area_posible in cargo:
                    area_trabajo = area_posible
                    break
            
            # Inicializar estadísticas para este técnico si no existe
            if id_tecnico not in estadisticas_por_tecnico:
                estadisticas_por_tecnico[id_tecnico] = {
                    'nombre': nombre,
                    'area': area_trabajo,
                    'silicona': 0,
                    'amarres_negros': 0,
                    'amarres_blancos': 0,
                    'cinta_aislante': 0,
                    'grapas_blancas': 0,
                    'grapas_negras': 0,
                    'total_asignaciones': 0
                }
            
            # Inicializar estadísticas para esta área si no existe
            if area_trabajo not in areas_distribucion:
                areas_distribucion[area_trabajo] = 0
            
            # Actualizar contadores
            estadisticas_por_tecnico[id_tecnico]['silicona'] += int(asignacion.get('silicona', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['amarres_negros'] += int(asignacion.get('amarres_negros', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['amarres_blancos'] += int(asignacion.get('amarres_blancos', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['cinta_aislante'] += int(asignacion.get('cinta_aislante', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['grapas_blancas'] += int(asignacion.get('grapas_blancas', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['grapas_negras'] += int(asignacion.get('grapas_negras', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['total_asignaciones'] += 1
            
            # Actualizar distribución por área
            areas_distribucion[area_trabajo] += 1
        
        # Aplicar filtro por material después de procesar todos los datos
        if material and material != 'todos':
            estadisticas_filtradas = {}
            for id_tecnico, stats in estadisticas_por_tecnico.items():
                incluir_tecnico = False
                if material == 'silicona' and stats['silicona'] > 0:
                    incluir_tecnico = True
                elif material == 'amarres' and (stats['amarres_negros'] + stats['amarres_blancos']) > 0:
                    incluir_tecnico = True
                elif material == 'cinta' and stats['cinta_aislante'] > 0:
                    incluir_tecnico = True
                elif material == 'grapas' and (stats['grapas_blancas'] + stats['grapas_negras']) > 0:
                    incluir_tecnico = True
                
                if incluir_tecnico:
                    estadisticas_filtradas[id_tecnico] = stats
            
            estadisticas_por_tecnico = estadisticas_filtradas
        
        # Calcular promedios y determinar técnicos por encima del promedio
        estadisticas_lista = list(estadisticas_por_tecnico.values())
        
        # Verificar si hay datos para mostrar
        if not estadisticas_lista:
            # No hay datos para los filtros seleccionados
            print(f"No hay datos para los filtros: mes={mes}, material={material}, area={area}")
            return jsonify({
                'status': 'success',
                'estadisticas': [],
                'top_tecnicos': [],
                'distribucion_area': [],
                'message': 'No hay datos disponibles para los filtros seleccionados'
            })
        
        # Calcular promedio de asignaciones por técnico
        total_asignaciones = sum(item['total_asignaciones'] for item in estadisticas_lista)
        promedio_asignaciones = total_asignaciones / len(estadisticas_lista) if estadisticas_lista else 0
        
        # Marcar técnicos por encima del promedio
        for item in estadisticas_lista:
            item['promedio_mensual'] = round(item['total_asignaciones'], 2)
            item['por_encima_promedio'] = item['total_asignaciones'] > promedio_asignaciones
            item['muy_por_encima_promedio'] = item['total_asignaciones'] > (promedio_asignaciones * 1.5)
        
        # Ordenar según el filtro de material aplicado
        if material and material != 'todos':
            # Ordenar por el material específico seleccionado
            if material == 'silicona':
                estadisticas_lista.sort(key=lambda x: x['silicona'], reverse=True)
            elif material == 'amarres':
                estadisticas_lista.sort(key=lambda x: (x['amarres_negros'] + x['amarres_blancos']), reverse=True)
            elif material == 'cinta':
                estadisticas_lista.sort(key=lambda x: x['cinta_aislante'], reverse=True)
            elif material == 'grapas':
                estadisticas_lista.sort(key=lambda x: (x['grapas_blancas'] + x['grapas_negras']), reverse=True)
        else:
            # Ordenar por total de asignaciones (descendente) cuando no hay filtro de material
            estadisticas_lista.sort(key=lambda x: x['total_asignaciones'], reverse=True)
        
        # Preparar top 5 técnicos
        top_tecnicos = estadisticas_lista[:5] if len(estadisticas_lista) >= 5 else estadisticas_lista
        
        # Calcular porcentajes para el top 5
        max_asignaciones = max([item['total_asignaciones'] for item in top_tecnicos]) if top_tecnicos else 1
        for item in top_tecnicos:
            item['porcentaje'] = round((item['total_asignaciones'] / max_asignaciones) * 100)
        
        # Preparar distribución por área
        distribucion_area = [{'area': area, 'total': total} for area, total in areas_distribucion.items()]
        
        return jsonify({
            'status': 'success',
            'estadisticas': estadisticas_lista,
            'top_tecnicos': top_tecnicos,
            'distribucion_area': distribucion_area
        })
        
    except Exception as e:
        print(f"Error al obtener estadísticas ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/exportar_estadisticas_ferretero')
@login_required()
@role_required('logistica')
def exportar_estadisticas_ferretero():
    connection = None
    cursor = None
    try:
        # Obtener parámetros de filtro (igual que en estadisticas_ferretero)
        mes = request.args.get('mes', '')
        material = request.args.get('material', '')
        area = request.args.get('area', '')
        anio = request.args.get('anio', '')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir la consulta base (igual que en estadisticas_ferretero)
        query = """
            SELECT 
                f.*,
                r.nombre,
                r.recurso_operativo_cedula,
                r.cargo,
                r.carpeta
            FROM ferretero f 
            LEFT JOIN recurso_operativo r ON f.id_codigo_consumidor = r.id_codigo_consumidor 
            WHERE 1=1
        """
        params = []
        
        # Aplicar filtro por mes (independiente del año)
        if mes and mes != 'todos':
            # Extraer el mes del formato 'YYYY-MM' o usar directamente si es solo el número
            try:
                if '-' in mes:
                    # Formato 'YYYY-MM'
                    mes_numero = int(mes.split('-')[1])
                else:
                    # Solo el número del mes
                    mes_numero = int(mes)
                query += " AND MONTH(f.fecha_asignacion) = %s"
                params.append(mes_numero)
            except (ValueError, IndexError) as e:
                print(f"Error al procesar el parámetro mes '{mes}': {e}")
                # Continuar sin filtro de mes si hay error
                pass
            
        if anio and anio != 'todos':
            try:
                anio_numero = int(anio)
                query += " AND YEAR(f.fecha_asignacion) = %s"
                params.append(anio_numero)
            except ValueError:
                pass
        
        # Aplicar filtro por área
        if area and area != 'todos':
            query += " AND (r.carpeta LIKE %s OR r.cargo LIKE %s)"
            area_param = f'%{area}%'
            params.append(area_param)
            params.append(area_param)
        
        # Ejecutar consulta
        cursor.execute(query, params)
        asignaciones = cursor.fetchall()
        
        # Procesar los datos para estadísticas (igual que en estadisticas_ferretero)
        estadisticas_por_tecnico = {}
        
        for asignacion in asignaciones:
            id_tecnico = asignacion['id_codigo_consumidor']
            nombre = asignacion.get('nombre', 'Técnico sin nombre')
            
            # Determinar área de trabajo
            carpeta = asignacion.get('carpeta', '').upper() if asignacion.get('carpeta') else ''
            cargo = asignacion.get('cargo', '').upper()
            
            area_trabajo = 'No especificada'
            areas_posibles = ['FTTH INSTALACIONES', 'INSTALACIONES DOBLES', 'POSTVENTA', 
                             'MANTENIMIENTO FTTH', 'ARREGLOS HFC', 'CONDUCTOR']
            
            for area_posible in areas_posibles:
                if area_posible in carpeta or area_posible in cargo:
                    area_trabajo = area_posible
                    break
            
            # Inicializar estadísticas para este técnico si no existe
            if id_tecnico not in estadisticas_por_tecnico:
                estadisticas_por_tecnico[id_tecnico] = {
                    'nombre': nombre,
                    'cedula': asignacion.get('recurso_operativo_cedula', 'No disponible'),
                    'area': area_trabajo,
                    'silicona': 0,
                    'amarres_negros': 0,
                    'amarres_blancos': 0,
                    'cinta_aislante': 0,
                    'grapas_blancas': 0,
                    'grapas_negras': 0,
                    'total_asignaciones': 0
                }
            
            # Actualizar contadores
            estadisticas_por_tecnico[id_tecnico]['silicona'] += int(asignacion.get('silicona', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['amarres_negros'] += int(asignacion.get('amarres_negros', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['amarres_blancos'] += int(asignacion.get('amarres_blancos', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['cinta_aislante'] += int(asignacion.get('cinta_aislante', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['grapas_blancas'] += int(asignacion.get('grapas_blancas', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['grapas_negras'] += int(asignacion.get('grapas_negras', 0) or 0)
            estadisticas_por_tecnico[id_tecnico]['total_asignaciones'] += 1
        
        # Aplicar filtro por material después de procesar todos los datos
        if material and material != 'todos':
            estadisticas_filtradas = {}
            for id_tecnico, stats in estadisticas_por_tecnico.items():
                incluir_tecnico = False
                if material == 'silicona' and stats['silicona'] > 0:
                    incluir_tecnico = True
                elif material == 'amarres' and (stats['amarres_negros'] + stats['amarres_blancos']) > 0:
                    incluir_tecnico = True
                elif material == 'cintas' and stats['cinta_aislante'] > 0:
                    incluir_tecnico = True
                elif material == 'grapas' and (stats['grapas_blancas'] + stats['grapas_negras']) > 0:
                    incluir_tecnico = True
                
                if incluir_tecnico:
                    estadisticas_filtradas[id_tecnico] = stats
            
            estadisticas_por_tecnico = estadisticas_filtradas
        
        # Calcular promedios y determinar técnicos por encima del promedio
        estadisticas_lista = list(estadisticas_por_tecnico.values())
        
        # Calcular promedio de asignaciones por técnico
        total_asignaciones = sum(item['total_asignaciones'] for item in estadisticas_lista)
        promedio_asignaciones = total_asignaciones / len(estadisticas_lista) if estadisticas_lista else 0
        
        # Marcar técnicos por encima del promedio
        for item in estadisticas_lista:
            item['promedio_mensual'] = round(item['total_asignaciones'], 2)
            item['por_encima_promedio'] = item['total_asignaciones'] > promedio_asignaciones
            item['muy_por_encima_promedio'] = item['total_asignaciones'] > (promedio_asignaciones * 1.5)
        
        # Ordenar por total de asignaciones (descendente)
        estadisticas_lista.sort(key=lambda x: x['total_asignaciones'], reverse=True)
        
        # Crear un DataFrame de pandas para generar el Excel
        df = pd.DataFrame(estadisticas_lista)
        
        # Renombrar columnas para el Excel
        columnas = {
            'nombre': 'Nombre',
            'cedula': 'Cédula',
            'area': 'Área',
            'silicona': 'Silicona',
            'amarres_negros': 'Amarres Negros',
            'amarres_blancos': 'Amarres Blancos',
            'cinta_aislante': 'Cinta Aislante',
            'grapas_blancas': 'Grapas Blancas',
            'grapas_negras': 'Grapas Negras',
            'total_asignaciones': 'Total Asignaciones',
            'promedio_mensual': 'Promedio Mensual'
        }
        df = df.rename(columns=columnas)
        
        # Seleccionar y ordenar columnas para el Excel
        columnas_excel = [
            'Nombre', 'Cédula', 'Área', 'Silicona', 'Amarres Negros', 'Amarres Blancos',
            'Cinta Aislante', 'Grapas Blancas', 'Grapas Negras', 'Total Asignaciones', 'Promedio Mensual'
        ]
        df = df[columnas_excel]
        
        # Crear un objeto BytesIO para guardar el Excel
        output = io.BytesIO()
        
        # Crear un objeto ExcelWriter
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            df.to_excel(writer, sheet_name='Estadísticas', index=False)
            
            # Obtener el objeto workbook y worksheet
            workbook = writer.book
            worksheet = writer.sheets['Estadísticas']
            
            # Definir formatos
            header_format = workbook.add_format({
                'bold': True,
                'text_wrap': True,
                'valign': 'top',
                'fg_color': '#D7E4BC',
                'border': 1
            })
            
            # Aplicar formato a los encabezados
            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, header_format)
                
            # Ajustar ancho de columnas
            for i, col in enumerate(df.columns):
                column_width = max(df[col].astype(str).map(len).max(), len(col) + 2)
                worksheet.set_column(i, i, column_width)
        
        # Preparar respuesta
        output.seek(0)
        
        fecha_actual = datetime.now().strftime("%d-%m-%Y")
        nombre_archivo = (
            f"Estadisticas_Ferretero_{anio}_{fecha_actual}.xlsx" if anio and anio != 'todos'
            else f"Estadisticas_Ferretero_{fecha_actual}.xlsx"
        )
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name=nombre_archivo
        )
        
    except Exception as e:
        print(f"Error al exportar estadísticas ferretero a Excel: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# ===== RUTAS PARA GESTIÓN DE STOCK DE MATERIAL FERRETERO =====

@app.route('/logistica/stock_ferretero')
@login_required()
@role_required('logistica')
def obtener_stock_ferretero():
    """Obtener el stock actual de material ferretero con cálculos de inventario"""
    connection = None
    cursor = None
    try:
        # Obtener parámetro de mes del filtro
        mes_filtro = request.args.get('mes', '')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener stock actual
        cursor.execute("""
            SELECT 
                codigo_material as material_tipo,
                cantidad_disponible as cantidad_actual,
                cantidad_minima,
                fecha_actualizacion
            FROM stock_general 
            ORDER BY codigo_material
        """)
        stock = cursor.fetchall()
        
        # Calcular total asignado por mes (filtrado o actual)
        if mes_filtro and mes_filtro != 'todos':
            # Filtrar por mes específico
            cursor.execute("""
                SELECT 
                    SUM(silicona) as total_silicona,
                    SUM(amarres_negros) as total_amarres_negros,
                    SUM(amarres_blancos) as total_amarres_blancos,
                    SUM(cinta_aislante) as total_cinta_aislante,
                    SUM(grapas_blancas) as total_grapas_blancas,
                    SUM(grapas_negras) as total_grapas_negras
                FROM ferretero 
                WHERE MONTH(fecha_asignacion) = %s 
                AND YEAR(fecha_asignacion) = YEAR(CURDATE())
            """, (mes_filtro,))
        else:
            # Usar mes actual por defecto
            cursor.execute("""
                SELECT 
                    SUM(silicona) as total_silicona,
                    SUM(amarres_negros) as total_amarres_negros,
                    SUM(amarres_blancos) as total_amarres_blancos,
                    SUM(cinta_aislante) as total_cinta_aislante,
                    SUM(grapas_blancas) as total_grapas_blancas,
                    SUM(grapas_negras) as total_grapas_negras
                FROM ferretero 
                WHERE MONTH(fecha_asignacion) = MONTH(CURDATE()) 
                AND YEAR(fecha_asignacion) = YEAR(CURDATE())
            """)
        asignado_mes = cursor.fetchone()
        
        # Obtener total de entradas por material
        cursor.execute("""
            SELECT 
                material_tipo,
                SUM(cantidad_entrada) as total_entradas,
                COUNT(*) as numero_entradas,
                MAX(fecha_entrada) as ultima_entrada,
                SUM(precio_total) as valor_total_entradas
            FROM entradas_ferretero
            GROUP BY material_tipo
            ORDER BY material_tipo
        """)
        total_entradas = cursor.fetchall()
        
        # Obtener total asignado histórico por material
        cursor.execute("""
            SELECT 
                'silicona' as material_tipo,
                COALESCE(SUM(silicona), 0) as total_asignado
            FROM ferretero WHERE silicona > 0
            UNION ALL
            SELECT 
                'amarres_negros' as material_tipo,
                COALESCE(SUM(amarres_negros), 0) as total_asignado
            FROM ferretero WHERE amarres_negros > 0
            UNION ALL
            SELECT 
                'amarres_blancos' as material_tipo,
                COALESCE(SUM(amarres_blancos), 0) as total_asignado
            FROM ferretero WHERE amarres_blancos > 0
            UNION ALL
            SELECT 
                'cinta_aislante' as material_tipo,
                COALESCE(SUM(cinta_aislante), 0) as total_asignado
            FROM ferretero WHERE cinta_aislante > 0
            UNION ALL
            SELECT 
                'grapas_blancas' as material_tipo,
                COALESCE(SUM(grapas_blancas), 0) as total_asignado
            FROM ferretero WHERE grapas_blancas > 0
            UNION ALL
            SELECT 
                'grapas_negras' as material_tipo,
                COALESCE(SUM(grapas_negras), 0) as total_asignado
            FROM ferretero WHERE grapas_negras > 0
            ORDER BY material_tipo
        """)
        total_asignado_historico = cursor.fetchall()
        
        # Obtener datos para calcular promedio de consumo diario
        cursor.execute("""
            SELECT 
                'silicona' as material_tipo,
                COALESCE(SUM(silicona), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE silicona > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            UNION ALL
            SELECT 
                'amarres_negros' as material_tipo,
                COALESCE(SUM(amarres_negros), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE amarres_negros > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            UNION ALL
            SELECT 
                'amarres_blancos' as material_tipo,
                COALESCE(SUM(amarres_blancos), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE amarres_blancos > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            UNION ALL
            SELECT 
                'cinta_aislante' as material_tipo,
                COALESCE(SUM(cinta_aislante), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE cinta_aislante > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            UNION ALL
            SELECT 
                'grapas_blancas' as material_tipo,
                COALESCE(SUM(grapas_blancas), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE grapas_blancas > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            UNION ALL
            SELECT 
                'grapas_negras' as material_tipo,
                COALESCE(SUM(grapas_negras), 0) as total_consumido,
                COUNT(DISTINCT DATE(fecha_asignacion)) as dias_con_consumo
            FROM ferretero 
            WHERE grapas_negras > 0 AND fecha_asignacion >= DATE_SUB(CURDATE(), INTERVAL 90 DAY)
            ORDER BY material_tipo
        """)
        consumo_historico = cursor.fetchall()
        
        # Calcular resumen de inventario
        resumen_inventario = []
        materiales = ['silicona', 'amarres_negros', 'amarres_blancos', 'cinta_aislante', 'grapas_blancas', 'grapas_negras']
        
        for material in materiales:
            # Buscar datos de entrada
            entrada = next((item for item in total_entradas if item['material_tipo'] == material), None)
            total_recibido = float(entrada['total_entradas']) if entrada and entrada['total_entradas'] else 0.0
            valor_entradas = float(entrada['valor_total_entradas']) if entrada and entrada['valor_total_entradas'] else 0.0
            ultima_entrada = entrada['ultima_entrada'] if entrada else None
            numero_entradas = int(entrada['numero_entradas']) if entrada and entrada['numero_entradas'] else 0
            
            # Buscar total asignado
            asignado = next((item for item in total_asignado_historico if item['material_tipo'] == material), None)
            total_asignado = float(asignado['total_asignado']) if asignado and asignado['total_asignado'] else 0.0
            
            # Buscar stock actual
            stock_item = next((item for item in stock if item['material_tipo'] == material), None)
            stock_actual = float(stock_item['cantidad_actual']) if stock_item and stock_item['cantidad_actual'] else 0.0
            stock_minimo = float(stock_item['cantidad_minima']) if stock_item and stock_item['cantidad_minima'] else 0.0
            
            # Buscar datos de consumo histórico
            consumo = next((item for item in consumo_historico if item['material_tipo'] == material), None)
            total_consumido = float(consumo['total_consumido']) if consumo and consumo['total_consumido'] else 0.0
            dias_con_consumo = int(consumo['dias_con_consumo']) if consumo and consumo['dias_con_consumo'] else 0
            
            # Calcular promedio de consumo diario y días de alcance
            if dias_con_consumo > 0:
                promedio_consumo_diario = total_consumido / dias_con_consumo
            else:
                promedio_consumo_diario = 0.0
            
            if promedio_consumo_diario > 0:
                dias_alcance = stock_actual / promedio_consumo_diario
            else:
                dias_alcance = float('inf') if stock_actual > 0 else 0
            
            # Formatear días de alcance para mostrar
            if dias_alcance == float('inf'):
                dias_alcance_display = "∞"
            elif dias_alcance > 999:
                dias_alcance_display = ">999"
            else:
                dias_alcance_display = round(dias_alcance, 1)
            
            # Calcular diferencia teórica vs real (mantener para compatibilidad)
            diferencia_teorica = total_recibido - total_asignado
            diferencia_real = diferencia_teorica - stock_actual
            
            resumen_inventario.append({
                'material_tipo': material,
                'total_recibido': int(total_recibido),
                'total_asignado': int(total_asignado),
                'stock_actual': int(stock_actual),
                'stock_minimo': int(stock_minimo),
                'diferencia_teorica': int(diferencia_teorica),
                'diferencia_real': int(diferencia_real),
                'dias_alcance': dias_alcance_display,
                'promedio_consumo_diario': round(promedio_consumo_diario, 2),
                'valor_entradas': float(valor_entradas),
                'ultima_entrada': ultima_entrada,
                'numero_entradas': numero_entradas,
                'estado_stock': 'Crítico' if stock_actual <= stock_minimo else 'Normal'
            })
        
        return jsonify({
            'status': 'success',
            'stock': stock,
            'asignado_mes_actual': asignado_mes,
            'resumen_inventario': resumen_inventario,
            'total_entradas': total_entradas,
            'total_asignado_historico': total_asignado_historico
        })
        
    except Exception as e:
        print(f"Error al obtener stock ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/stock/materiales')
def verificar_disponibilidad_materiales():
    """Endpoint simple para verificar disponibilidad de stock de materiales ferretero"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener stock actual de todos los materiales
        cursor.execute("""
            SELECT 
                codigo_material as material_tipo,
                cantidad_disponible,
                cantidad_minima
            FROM stock_general 
            WHERE activo = 1
            ORDER BY codigo_material
        """)
        stock_data = cursor.fetchall()
        
        # Crear diccionario con disponibilidad por material
        disponibilidad = {}
        for item in stock_data:
            material = item['material_tipo']
            cantidad = float(item['cantidad_disponible']) if item['cantidad_disponible'] else 0.0
            disponibilidad[material] = {
                'disponible': cantidad > 0,
                'cantidad': int(cantidad),
                'cantidad_minima': int(item['cantidad_minima']) if item['cantidad_minima'] else 0
            }
        
        # Asegurar que todos los materiales estén incluidos
        materiales_requeridos = ['silicona', 'cinta_aislante', 'amarres_negros', 'amarres_blancos', 'grapas_blancas', 'grapas_negras']
        for material in materiales_requeridos:
            if material not in disponibilidad:
                disponibilidad[material] = {
                    'disponible': False,
                    'cantidad': 0,
                    'cantidad_minima': 0
                }
        
        return jsonify({
            'status': 'success',
            'disponibilidad': disponibilidad
        })
        
    except Exception as e:
        print(f"Error al verificar disponibilidad de materiales: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/comparacion_mensual_materiales')
def obtener_comparacion_mensual_materiales():
    """Endpoint para obtener datos de comparación mensual de materiales"""
    connection = None
    cursor = None
    try:
        # Obtener parámetros
        material = request.args.get('material', 'silicona')
        anio = request.args.get('anio', '2025')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Consulta para obtener asignaciones mensuales del material específico desde la tabla ferretero
        query = """
            SELECT 
                MONTH(fecha_asignacion) as mes,
                SUM(CASE 
                    WHEN %s = 'silicona' THEN COALESCE(silicona, 0)
                    WHEN %s = 'amarres_negros' THEN COALESCE(amarres_negros, 0)
                    WHEN %s = 'amarres_blancos' THEN COALESCE(amarres_blancos, 0)
                    WHEN %s = 'cinta_aislante' THEN COALESCE(cinta_aislante, 0)
                    WHEN %s = 'grapas_blancas' THEN COALESCE(grapas_blancas, 0)
                    WHEN %s = 'grapas_negras' THEN COALESCE(grapas_negras, 0)
                    ELSE 0
                END) as cantidad_asignada
            FROM ferretero 
            WHERE YEAR(fecha_asignacion) = %s
            AND (
                (%s = 'silicona' AND silicona > 0) OR
                (%s = 'amarres_negros' AND amarres_negros > 0) OR
                (%s = 'amarres_blancos' AND amarres_blancos > 0) OR
                (%s = 'cinta_aislante' AND cinta_aislante > 0) OR
                (%s = 'grapas_blancas' AND grapas_blancas > 0) OR
                (%s = 'grapas_negras' AND grapas_negras > 0)
            )
            GROUP BY MONTH(fecha_asignacion)
            ORDER BY mes
        """
        
        cursor.execute(query, (material, material, material, material, material, material, anio, material, material, material, material, material, material))
        datos_mensuales = cursor.fetchall()
        
        # Transformar datos para el formato esperado por el frontend
        datos_formateados = []
        for dato in datos_mensuales:
            datos_formateados.append({
                'mes': dato['mes'],
                'cantidad_asignada': int(dato['cantidad_asignada']) if dato['cantidad_asignada'] else 0
            })
        
        # Si no hay datos, crear estructura vacía
        if not datos_formateados:
            datos_formateados = []
            for mes in range(1, 13):
                datos_formateados.append({
                    'mes': mes,
                    'cantidad_asignada': 0
                })
        
        return jsonify({
            'status': 'success',
            'datos_mensuales': datos_formateados,
            'material': material,
            'anio': anio
        })
        
    except Exception as e:
        print(f"Error al obtener comparación mensual: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/entradas_ferretero', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_entrada_ferretero():
    """Registrar entrada de material ferretero"""
    connection = None
    cursor = None
    try:
        data = request.get_json()
        
        # Validar datos requeridos
        required_fields = ['material_tipo', 'cantidad', 'precio_unitario']
        for field in required_fields:
            if field not in data or not data[field]:
                return jsonify({
                    'status': 'error',
                    'message': f'El campo {field} es requerido'
                }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Insertar entrada
        cursor.execute("""
            INSERT INTO entradas_ferretero (
                material_tipo, cantidad_entrada, precio_unitario, precio_total,
                proveedor, numero_factura, observaciones, fecha_entrada, usuario_registro
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), %s)
        """, (
            data['material_tipo'],
            data['cantidad'],
            data['precio_unitario'],
            float(data['cantidad']) * float(data['precio_unitario']),
            data.get('proveedor', ''),
            data.get('numero_factura', ''),
            data.get('observaciones', ''),
            session['user_id']
        ))
        
        # El trigger actualizar_stock_entrada se encarga automáticamente de:
        # 1. Actualizar el stock en la tabla stock_ferretero
        # 2. Registrar el movimiento en movimientos_stock_ferretero
        # Por lo tanto, no necesitamos hacer actualizaciones manuales aquí
        
        connection.commit()
        
        return jsonify({
            'status': 'success',
            'message': 'Entrada registrada correctamente'
        })
        
    except Exception as e:
        if connection:
            connection.rollback()
        print(f"Error al registrar entrada ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/movimientos_ferretero')
@login_required()
@role_required('logistica')
def obtener_movimientos_ferretero():
    """Obtener movimientos de stock de material ferretero"""
    connection = None
    cursor = None
    try:
        # Obtener parámetros de filtro
        material = request.args.get('material', '')
        fecha_inicio = request.args.get('fecha_inicio', '')
        fecha_fin = request.args.get('fecha_fin', '')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir consulta con filtros
        query = """
            SELECT 
                material_tipo,
                tipo_movimiento,
                cantidad,
                fecha_movimiento,
                referencia_id,
                observaciones
            FROM movimientos_stock_ferretero 
            WHERE 1=1
        """
        params = []
        
        if material and material != 'todos':
            query += " AND material_tipo = %s"
            params.append(material)
            
        if fecha_inicio:
            query += " AND DATE(fecha_movimiento) >= %s"
            params.append(fecha_inicio)
            
        if fecha_fin:
            query += " AND DATE(fecha_movimiento) <= %s"
            params.append(fecha_fin)
            
        query += " ORDER BY fecha_movimiento DESC LIMIT 100"
        
        cursor.execute(query, params)
        movimientos = cursor.fetchall()
        
        return jsonify({
            'status': 'success',
            'movimientos': movimientos
        })
        
    except Exception as e:
        print(f"Error al obtener movimientos ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

def verificar_stock_bajo():
    """Verificar materiales con stock bajo o agotado"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return []
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener materiales con problemas de stock
        cursor.execute("""
            SELECT 
                material_tipo,
                cantidad_disponible,
                cantidad_minima,
                CASE 
                    WHEN cantidad_disponible = 0 THEN 'agotado'
                    WHEN cantidad_disponible <= cantidad_minima THEN 'bajo'
                    ELSE 'normal'
                END as estado_stock
            FROM stock_ferretero 
            WHERE cantidad_disponible <= cantidad_minima
            ORDER BY 
                CASE 
                    WHEN cantidad_disponible = 0 THEN 1
                    ELSE 2
                END,
                material_tipo
        """)
        
        materiales_problematicos = cursor.fetchall()
        
        # Formatear nombres de materiales para mostrar
        nombres_materiales = {
            'silicona': 'Silicona',
            'amarres_negros': 'Amarres Negros',
            'amarres_blancos': 'Amarres Blancos',
            'cinta_aislante': 'Cinta Aislante',
            'grapas_blancas': 'Grapas Blancas',
            'grapas_negras': 'Grapas Negras'
        }
        
        for material in materiales_problematicos:
            material['nombre_display'] = nombres_materiales.get(material['material_tipo'], material['material_tipo'])
        
        return materiales_problematicos
        
    except Exception as e:
        print(f"Error al verificar stock bajo: {str(e)}")
        return []
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/suministros_ferretero', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_suministros_ferretero():
    """Obtener suministros de la familia 'Material Ferretero'"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener suministros de material ferretero
        query = """
        SELECT 
            id_suministros,
            suministros_codigo,
            suministros_descripcion,
            suministros_cantidad,
            suministros_costo_unitario,
            fecha_registro
        FROM suministros 
        WHERE suministros_familia = 'Material Ferretero' 
        AND suministros_estado = 'Activo'
        ORDER BY suministros_descripcion
        """
        
        cursor.execute(query)
        suministros = cursor.fetchall()
        
        return jsonify({
            'status': 'success',
            'suministros': suministros
        })
        
    except Exception as e:
        print(f"Error al obtener suministros ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/transferir_suministro_ferretero', methods=['POST'])
@login_required()
@role_required('logistica')
def transferir_suministro_ferretero():
    """Transferir suministro a stock ferretero"""
    connection = None
    cursor = None
    try:
        data = request.get_json()
        id_suministro = data.get('id_suministro')
        cantidad_transferir = data.get('cantidad')
        material_tipo = data.get('material_tipo')  # silicona, amarres_negros, etc.
        
        if not all([id_suministro, cantidad_transferir, material_tipo]):
            return jsonify({
                'status': 'error',
                'message': 'Faltan datos requeridos'
            }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Verificar que el suministro existe y tiene cantidad suficiente
        cursor.execute("""
            SELECT suministros_cantidad, suministros_descripcion 
            FROM suministros 
            WHERE id_suministros = %s AND suministros_familia = 'Material Ferretero'
        """, (id_suministro,))
        
        suministro = cursor.fetchone()
        if not suministro:
            return jsonify({
                'status': 'error',
                'message': 'Suministro no encontrado'
            }), 404
        
        if suministro['suministros_cantidad'] < cantidad_transferir:
            return jsonify({
                'status': 'error',
                'message': 'Cantidad insuficiente en suministros'
            }), 400
        
        # Iniciar transacción
        cursor.execute("START TRANSACTION")
        
        # Actualizar cantidad en suministros
        nueva_cantidad_suministro = suministro['suministros_cantidad'] - cantidad_transferir
        cursor.execute("""
            UPDATE suministros 
            SET suministros_cantidad = %s 
            WHERE id_suministros = %s
        """, (nueva_cantidad_suministro, id_suministro))
        
        # Registrar entrada en entradas_ferretero
        cursor.execute("""
            INSERT INTO entradas_ferretero 
            (material_tipo, cantidad_entrada, precio_unitario, proveedor, numero_factura, observaciones, fecha_entrada, usuario_registro)
            VALUES (%s, %s, 0, 'Transferencia desde Suministros', %s, %s, NOW(), %s)
        """, (
            material_tipo, 
            cantidad_transferir, 
            f'SUM-{id_suministro}',
            f'Transferido desde: {suministro["suministros_descripcion"]}',
            session['user_id']
        ))
        
        # Confirmar transacción
        connection.commit()
        
        return jsonify({
            'status': 'success',
            'message': f'Transferencia exitosa: {cantidad_transferir} unidades de {material_tipo}'
        })
        
    except Exception as e:
        print(f"Error al transferir suministro: {str(e)}")
        if connection:
            connection.rollback()
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/actualizar_stock_ferretero', methods=['POST'])
@login_required()
@role_required('logistica')
def actualizar_stock_ferretero():
    """Endpoint para actualizar el stock del ferretero después de asignaciones"""
    try:
        # Este endpoint simplemente confirma que el stock debe ser actualizado
        # La actualización real se hace automáticamente por los triggers de la base de datos
        return jsonify({
            'status': 'success',
            'message': 'Stock actualizado correctamente'
        })
        
    except Exception as e:
        print(f"Error al actualizar stock ferretero: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500

@app.route('/logistica/automotor')
@login_required()
@role_required('logistica')
def ver_parque_automotor():
    try:
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
                               
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todos los vehículos con información del técnico asignado
        cursor.execute("""
            SELECT pa.*, r.nombre as tecnico_nombre, r.recurso_operativo_cedula, r.cargo
            FROM parque_automotor pa 
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY pa.fecha_asignacion DESC
        """)
        vehiculos = cursor.fetchall()

        # Convertir fechas de vencimiento a objetos datetime.date
        for vehiculo in vehiculos:
            if isinstance(vehiculo['soat_vencimiento'], datetime):
                vehiculo['soat_vencimiento'] = vehiculo['soat_vencimiento'].date()
            if isinstance(vehiculo['tecnomecanica_vencimiento'], datetime):
                vehiculo['tecnomecanica_vencimiento'] = vehiculo['tecnomecanica_vencimiento'].date()

        # Obtener lista de técnicos disponibles
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula, cargo 
            FROM recurso_operativo 
            WHERE cargo LIKE '%TECNICO%' OR cargo LIKE '%TÉCNICO%'
            ORDER BY nombre
        """)
        tecnicos = cursor.fetchall()
        
        cursor.close()
        connection.close()

        return render_template('modulos/logistica/automotor.html', 
                            vehiculos=vehiculos,
                            tecnicos=tecnicos,
                            fecha_actual=datetime.now().date())

    except Exception as e:
        print(f"Error al obtener parque automotor: {str(e)}")
        return render_template('error.html', 
                           mensaje='Error al cargar el parque automotor',
                           error=str(e))

@app.route('/logistica/registrar_vehiculo', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_vehiculo():
    connection = None
    cursor = None
    try:
        # Obtener datos del formulario (IDs corregidos para coincidir con el frontend)
        placa = request.form.get('placa_vehiculo')
        tipo_vehiculo = request.form.get('tipo_vehiculo')
        marca = request.form.get('marca_vehiculo')
        modelo = request.form.get('modelo_vehiculo')
        color = request.form.get('color')
        supervisor = request.form.get('supervisor')
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha_asignacion = request.form.get('fecha_asignacion')
        soat_vencimiento = request.form.get('fecha_vencimiento_soat')
        tecnomecanica_vencimiento = request.form.get('fecha_vencimiento_tecnomecanica')
        observaciones = request.form.get('observaciones')

        # Validar campos requeridos
        if not all([placa, tipo_vehiculo, marca, modelo, color, fecha_asignacion]):
            return jsonify({
                'status': 'error',
                'message': 'Todos los campos marcados con * son requeridos'
            }), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar si la placa ya existe
        cursor.execute('SELECT placa FROM parque_automotor WHERE placa = %s', (placa,))
        if cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'Ya existe un vehículo registrado con esta placa'
            }), 400

        # Insertar el nuevo vehículo
        cursor.execute("""
            INSERT INTO parque_automotor (
                placa, tipo_vehiculo, marca, modelo, color, supervisor,
                id_codigo_consumidor, fecha_asignacion,
                soat_vencimiento, tecnomecanica_vencimiento, observaciones
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            placa, tipo_vehiculo, marca, modelo, color, supervisor,
            id_codigo_consumidor, fecha_asignacion,
            soat_vencimiento, tecnomecanica_vencimiento, observaciones
        ))
        
        connection.commit()

        return jsonify({
            'status': 'success',
            'message': 'Vehículo registrado exitosamente'
        }), 201

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al registrar el vehículo: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/actualizar_vehiculo/<int:id_parque_automotor>', methods=['POST'])
@login_required()
@role_required('logistica')
def actualizar_vehiculo(id_parque_automotor):
    connection = None
    cursor = None
    try:
        # Obtener datos del formulario (IDs corregidos para coincidir con el frontend)
        placa = request.form.get('placa_vehiculo')
        tipo_vehiculo = request.form.get('tipo_vehiculo')
        marca = request.form.get('marca_vehiculo')
        modelo = request.form.get('modelo_vehiculo')
        color = request.form.get('color')
        supervisor = request.form.get('supervisor')
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha_asignacion = request.form.get('fecha_asignacion')
        estado = request.form.get('estado', 'Activo')
        soat_vencimiento = request.form.get('fecha_vencimiento_soat')
        tecnomecanica_vencimiento = request.form.get('fecha_vencimiento_tecnomecanica')
        observaciones = request.form.get('observaciones', '')
        
        # Campos adicionales válidos
        vin = request.form.get('vin')
        parque_automotorcol = request.form.get('parque_automotorcol')
        licencia = request.form.get('licencia')
        cedula_propietario = request.form.get('cedula_propietario')
        nombre_propietario = request.form.get('nombre_propietario')
        kilometraje_actual = request.form.get('kilometraje_actual')
        proximo_mantenimiento_km = request.form.get('proximo_mantenimiento_km')
        fecha_ultimo_mantenimiento = request.form.get('fecha_ultimo_mantenimiento')
        fecha_actualizacion = request.form.get('fecha_actualizacion')
        
        # Campos de inspección física
        estado_carroceria = request.form.get('estado_carroceria')
        estado_llantas = request.form.get('estado_llantas')
        estado_frenos = request.form.get('estado_frenos')
        estado_motor = request.form.get('estado_motor')
        estado_luces = request.form.get('estado_luces')
        estado_espejos = request.form.get('estado_espejos')
        estado_vidrios = request.form.get('estado_vidrios')
        estado_asientos = request.form.get('estado_asientos')
        
        # Campos de elementos de seguridad
        cinturon_seguridad = request.form.get('cinturon_seguridad')
        extintor = request.form.get('extintor')
        botiquin = request.form.get('botiquin')
        triangulos_seguridad = request.form.get('triangulos_seguridad')
        llanta_repuesto = request.form.get('llanta_repuesto')
        herramientas = request.form.get('herramientas')
        gato = request.form.get('gato')
        cruceta = request.form.get('cruceta')
        
        # Campos operativos válidos
        centro_de_trabajo = request.form.get('centro_de_trabajo')
        ciudad = request.form.get('ciudad')
        licencia_conduccion = request.form.get('licencia_conduccion')

        # Validar campos requeridos
        if not all([placa, tipo_vehiculo, marca, modelo, color, fecha_asignacion]):
            return jsonify({
                'status': 'error',
                'message': 'Todos los campos marcados con * son requeridos'
            }), 400

        # Convertir id_codigo_consumidor a None si está vacío
        id_codigo_consumidor = None if not id_codigo_consumidor else id_codigo_consumidor

        # Convertir fechas vacías a None
        soat_vencimiento = None if not soat_vencimiento else soat_vencimiento
        tecnomecanica_vencimiento = None if not tecnomecanica_vencimiento else tecnomecanica_vencimiento

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar si el vehículo existe
        cursor.execute('SELECT id_parque_automotor FROM parque_automotor WHERE id_parque_automotor = %s', (id_parque_automotor,))
        if not cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'El vehículo no existe'
            }), 404

        # Verificar si la placa ya existe para otro vehículo
        cursor.execute('SELECT id_parque_automotor FROM parque_automotor WHERE placa = %s AND id_parque_automotor != %s', (placa, id_parque_automotor))
        if cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'Ya existe otro vehículo registrado con esta placa'
            }), 400

        # Convertir fechas vacías a None para los campos válidos
        fecha_ultimo_mantenimiento = None if not fecha_ultimo_mantenimiento else fecha_ultimo_mantenimiento
        fecha_actualizacion = None if not fecha_actualizacion else fecha_actualizacion
        
        # Convertir valores numéricos vacíos a None
        kilometraje_actual = None if not kilometraje_actual else kilometraje_actual
        proximo_mantenimiento_km = None if not proximo_mantenimiento_km else proximo_mantenimiento_km

        # Actualizar el vehículo (solo campos que existen en la tabla)
        cursor.execute("""
            UPDATE parque_automotor SET
                placa = %s,
                tipo_vehiculo = %s,
                marca = %s,
                modelo = %s,
                color = %s,
                supervisor = %s,
                id_codigo_consumidor = %s,
                fecha_asignacion = %s,
                estado = %s,
                soat_vencimiento = %s,
                tecnomecanica_vencimiento = %s,
                observaciones = %s,
                vin = %s,
                parque_automotorcol = %s,
                licencia = %s,
                cedula_propietario = %s,
                nombre_propietario = %s,
                kilometraje_actual = %s,
                proximo_mantenimiento_km = %s,
                fecha_ultimo_mantenimiento = %s,
                fecha_actualizacion = %s,
                estado_carroceria = %s,
                estado_llantas = %s,
                estado_frenos = %s,
                estado_motor = %s,
                estado_luces = %s,
                estado_espejos = %s,
                estado_vidrios = %s,
                estado_asientos = %s,
                cinturon_seguridad = %s,
                extintor = %s,
                botiquin = %s,
                triangulos_seguridad = %s,
                llanta_repuesto = %s,
                herramientas = %s,
                gato = %s,
                cruceta = %s,
                centro_de_trabajo = %s,
                ciudad = %s,
                licencia_conduccion = %s
            WHERE id_parque_automotor = %s
        """, (
            placa, tipo_vehiculo, marca, modelo, color, supervisor,
            id_codigo_consumidor, fecha_asignacion, estado,
            soat_vencimiento, tecnomecanica_vencimiento, observaciones,
            vin, parque_automotorcol, licencia, cedula_propietario, nombre_propietario,
            kilometraje_actual, proximo_mantenimiento_km, fecha_ultimo_mantenimiento,
            fecha_actualizacion, estado_carroceria, estado_llantas, estado_frenos, estado_motor,
            estado_luces, estado_espejos, estado_vidrios, estado_asientos,
            cinturon_seguridad, extintor, botiquin, triangulos_seguridad,
            llanta_repuesto, herramientas, gato, cruceta,
            centro_de_trabajo, ciudad, licencia_conduccion, id_parque_automotor
        ))
        
        connection.commit()

        return jsonify({
            'status': 'success',
            'message': 'Vehículo actualizado exitosamente'
        })

    except mysql.connector.Error as e:
        print(f"Error MySQL en actualización: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al actualizar en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general en actualizar_vehiculo: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al actualizar el vehículo: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/exportar_automotor_csv')
@login_required()
@role_required('logistica')
def exportar_automotor_csv():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todos los vehículos con información del técnico
        cursor.execute("""
            SELECT 
                pa.placa,
                pa.tipo_vehiculo,
                pa.marca,
                pa.modelo,
                pa.color,
                r.nombre as nombre_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico,
                r.cargo as cargo_tecnico,
                pa.fecha_asignacion,
                pa.estado,
                pa.soat_vencimiento,
                pa.tecnomecanica_vencimiento,
                pa.observaciones
            FROM parque_automotor pa 
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY pa.fecha_asignacion DESC
        """)
        vehiculos = cursor.fetchall()
        
        # Crear archivo CSV en memoria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escribir encabezados
        writer.writerow([
            'Placa',
            'Tipo Vehículo',
            'Marca',
            'Modelo',
            'Color',
            'Técnico Asignado',
            'Cédula Técnico',
            'Cargo Técnico',
            'Fecha Asignación',
            'Estado',
            'Vencimiento SOAT',
            'Vencimiento Tecnomecánica',
            'Observaciones'
        ])
        
        # Escribir datos
        for vehiculo in vehiculos:
            writer.writerow([
                vehiculo['placa'],
                vehiculo['tipo_vehiculo'],
                vehiculo['marca'],
                vehiculo['modelo'],
                vehiculo['color'],
                vehiculo.get('nombre_tecnico', 'No asignado'),
                vehiculo.get('cedula_tecnico', 'No disponible'),
                vehiculo.get('cargo_tecnico', 'No especificado'),
                vehiculo['fecha_asignacion'].strftime('%Y-%m-%d') if vehiculo['fecha_asignacion'] else '',
                vehiculo.get('estado', 'Activo'),
                vehiculo['soat_vencimiento'].strftime('%Y-%m-%d') if vehiculo['soat_vencimiento'] else '',
                vehiculo['tecnomecanica_vencimiento'].strftime('%Y-%m-%d') if vehiculo['tecnomecanica_vencimiento'] else '',
                vehiculo.get('observaciones', '')
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8-sig')),
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'parque_automotor_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Alias route for the template's expected endpoint name
@app.route('/logistica/automotor/exportar_csv')
@login_required()
@role_required('logistica')
def exportar_vehiculos_csv():
    """CSV export route with the name expected by the template"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todos los vehículos con información del técnico
        cursor.execute("""
            SELECT 
                pa.placa,
                pa.tipo_vehiculo,
                pa.marca,
                pa.modelo,
                pa.color,
                r.nombre as nombre_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico,
                r.cargo as cargo_tecnico,
                pa.fecha_asignacion,
                pa.estado,
                pa.soat_vencimiento,
                pa.tecnomecanica_vencimiento,
                pa.observaciones
            FROM parque_automotor pa 
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor 
            ORDER BY pa.fecha_asignacion DESC
        """)
        vehiculos = cursor.fetchall()
        
        # Crear archivo CSV en memoria
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Escribir encabezados
        writer.writerow([
            'Placa',
            'Tipo Vehículo',
            'Marca',
            'Modelo',
            'Color',
            'Técnico Asignado',
            'Cédula Técnico',
            'Cargo Técnico',
            'Fecha Asignación',
            'Estado',
            'Vencimiento SOAT',
            'Vencimiento Tecnomecánica',
            'Observaciones'
        ])
        
        # Escribir datos
        for vehiculo in vehiculos:
            writer.writerow([
                vehiculo['placa'],
                vehiculo['tipo_vehiculo'],
                vehiculo['marca'],
                vehiculo['modelo'],
                vehiculo['color'],
                vehiculo.get('nombre_tecnico', 'No asignado'),
                vehiculo.get('cedula_tecnico', 'No disponible'),
                vehiculo.get('cargo_tecnico', 'No especificado'),
                vehiculo['fecha_asignacion'].strftime('%Y-%m-%d') if vehiculo['fecha_asignacion'] else '',
                vehiculo.get('estado', 'Activo'),
                vehiculo['soat_vencimiento'].strftime('%Y-%m-%d') if vehiculo['soat_vencimiento'] else '',
                vehiculo['tecnomecanica_vencimiento'].strftime('%Y-%m-%d') if vehiculo['tecnomecanica_vencimiento'] else '',
                vehiculo.get('observaciones', '')
            ])
        
        # Preparar respuesta
        output.seek(0)
        return send_file(
            io.BytesIO(output.getvalue().encode('utf-8-sig')),
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'vehiculos_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        )
        
    except Error as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/ultima_asignacion')
@login_required()
@role_required('logistica')
def obtener_ultima_asignacion():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)
        
        # Obtener la última asignación creada (por ID, asumiendo que es autoincremental)
        cursor.execute("""
            SELECT id_asignacion 
            FROM asignacion 
            ORDER BY id_asignacion DESC 
            LIMIT 1
        """)
        
        resultado = cursor.fetchone()
        
        if resultado:
            return jsonify({
                'status': 'success',
                'id_asignacion': resultado['id_asignacion'],
                'message': 'Última asignación encontrada'
            })
        else:
            return jsonify({
                'status': 'error',
                'message': 'No se encontraron asignaciones'
            }), 404

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener la última asignación: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/registrar_asignacion_con_firma', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_asignacion_con_firma():
    connection = None
    cursor = None
    try:
        # Obtener datos básicos
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha = request.form.get('fecha')
        cargo = request.form.get('cargo')
        firma = request.form.get('firma')
        id_asignador = request.form.get('id_asignador')

        # Validar campos requeridos
        if not all([id_codigo_consumidor, fecha, cargo, firma, id_asignador]):
            return jsonify({
                'status': 'error',
                'message': 'Faltan campos requeridos para la asignación con firma'
            }), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar que el técnico existe
        cursor.execute('SELECT nombre FROM recurso_operativo WHERE id_codigo_consumidor = %s', (id_codigo_consumidor,))
        tecnico = cursor.fetchone()
        
        if not tecnico:
            return jsonify({
                'status': 'error',
                'message': 'El técnico seleccionado no existe'
            }), 404

        # Obtener la estructura de la tabla
        cursor.execute("""
            SELECT COLUMN_NAME 
            FROM INFORMATION_SCHEMA.COLUMNS 
            WHERE TABLE_SCHEMA = DATABASE()
            AND TABLE_NAME = 'asignacion'
        """)
        columnas_existentes = {row['COLUMN_NAME'].lower() for row in cursor.fetchall()}
        
        print("Columnas existentes:", columnas_existentes)  # Debug log

        # Campos base que siempre deben existir
        campos = ['id_codigo_consumidor', 'asignacion_fecha', 'asignacion_cargo']
        valores = [id_codigo_consumidor, fecha, cargo]

        # Lista de todas las herramientas posibles
        herramientas = [
            'adaptador_mandril', 'alicate', 'barra_45cm', 'bisturi_metalico',
            'broca_3_8', 'broca_386_ran', 'broca_126_ran',
            'broca_metalmadera_14', 'broca_metalmadera_38', 'broca_metalmadera_516',
            'caja_de_herramientas', 'cajon_rojo', 'cinta_de_senal', 'cono_retractil',
            'cortafrio', 'destor_de_estrella', 'destor_de_pala', 'destor_tester',
            'espatula', 'exten_de_corr_10_mts', 'llave_locking_male', 'llave_reliance',
            'llave_torque_rg_11', 'llave_torque_rg_6', 'llaves_mandril',
            'mandril_para_taladro', 'martillo_de_una', 'multimetro',
            'pelacable_rg_6y_rg_11', 'pinza_de_punta', 'pistola_de_silicona',
            'planillero', 'ponchadora_rg_6_y_rg_11', 'ponchadora_rj_45_y_rj11',
            'probador_de_tonos', 'probador_de_tonos_utp', 'puntas_para_multimetro',
            'sonda_metalica', 'tacos_de_madera', 'taladro_percutor',
            'telefono_de_pruebas', 'power_miter', 'bfl_laser', 'cortadora',
            'stripper_fibra', 'pelachaqueta'
        ]

        # Procesar cada herramienta
        for herramienta in herramientas:
            nombre_campo = f'asignacion_{herramienta}'
            if nombre_campo.lower() in columnas_existentes:
                campos.append(nombre_campo)
                valor = request.form.get(herramienta, '0')
                valores.append(valor if valor == '1' else '0')
            else:
                print(f"Campo ignorado (no existe en la tabla): {nombre_campo}")

        # Agregar estado por defecto si existe la columna
        if 'asignacion_estado' in columnas_existentes:
            campos.append('asignacion_estado')
            valores.append('1')
            
        # Agregar campos de firma y asignador
        if 'asignacion_firma' in columnas_existentes:
            campos.append('asignacion_firma')
            valores.append(firma)
            
        if 'id_asignador' in columnas_existentes:
            campos.append('id_asignador')
            valores.append(id_asignador)

        # Construir y ejecutar la consulta SQL
        sql = f"""
            INSERT INTO asignacion ({', '.join(campos)})
            VALUES ({', '.join(['%s'] * len(valores))})
        """
        
        print("SQL Query:", sql)  # Debug log
        print("Valores:", valores)  # Debug log

        cursor.execute(sql, tuple(valores))
        connection.commit()
        
        # Obtener el ID de la asignación recién creada
        cursor.execute("SELECT LAST_INSERT_ID() as id_asignacion")
        id_asignacion = cursor.fetchone()['id_asignacion']

        return jsonify({
            'status': 'success',
            'message': 'Asignación con firma registrada exitosamente',
            'id_asignacion': id_asignacion
        }), 201

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error al registrar la asignación con firma: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/guardar_firma', methods=['POST'])
@login_required()
@role_required('logistica')
def guardar_firma():
    connection = None
    cursor = None
    try:
        # Obtener datos del JSON
        data = request.get_json()
        if not data:
            return jsonify({
                'status': 'error',
                'message': 'No se recibieron datos JSON'
            }), 400
            
        id_asignacion = data.get('id_asignacion')
        firma = data.get('firma')
        id_asignador = data.get('id_asignador')

        # Validar campos requeridos
        if not all([id_asignacion, firma, id_asignador]):
            return jsonify({
                'status': 'error',
                'message': 'Faltan campos requeridos (id_asignacion, firma, id_asignador)'
            }), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500

        cursor = connection.cursor(dictionary=True)

        # Verificar que la asignación existe
        cursor.execute('SELECT id_asignacion FROM asignacion WHERE id_asignacion = %s', (id_asignacion,))
        asignacion = cursor.fetchone()
        
        if not asignacion:
            return jsonify({
                'status': 'error',
                'message': 'La asignación no existe'
            }), 404

        # Actualizar la asignación con la firma
        cursor.execute("""
            UPDATE asignacion 
            SET asignacion_firma = %s, id_asignador = %s 
            WHERE id_asignacion = %s
        """, (firma, id_asignador, id_asignacion))
        
        connection.commit()

        return jsonify({
            'status': 'success',
            'message': 'Firma guardada exitosamente'
        })

    except mysql.connector.Error as e:
        print(f"Error MySQL: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error en la base de datos: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general: {str(e)}")  # Debug log
        return jsonify({
            'status': 'error',
            'message': f'Error al guardar la firma: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/guardar_asignacion', methods=['POST'])
@login_required(role=['administrativo', 'logistica'])
def guardar_asignacion():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos'})
            
        cursor = connection.cursor()
        
        # Obtener datos del formulario
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha = request.form.get('fecha')
        cargo = request.form.get('cargo')
        
        # Manejar la imagen si se proporcionó una
        imagen_path = None
        if 'imagen' in request.files:
            imagen = request.files['imagen']
            if imagen and imagen.filename:
                # Generar nombre único para la imagen
                extension = os.path.splitext(imagen.filename)[1]
                nuevo_nombre = f"asignacion_{datetime.now().strftime('%Y%m%d_%H%M%S')}{extension}"
                
                # Asegurar que el directorio existe
                upload_dir = os.path.join(app.root_path, 'static', 'uploads', 'asignacion')
                os.makedirs(upload_dir, exist_ok=True)
                
                # Guardar la imagen
                imagen_path = os.path.join('uploads', 'asignacion', nuevo_nombre)
                imagen.save(os.path.join(app.root_path, 'static', imagen_path))
        
        # Insertar asignación sin imagen (campo no existe en la tabla)
        cursor.execute("""
            INSERT INTO asignacion (
                id_codigo_consumidor, asignacion_fecha, asignacion_cargo, 
                asignacion_estado
            ) VALUES (%s, %s, %s, %s)
        """, (
            id_codigo_consumidor, fecha, cargo, '1'
        ))
        
        id_asignacion = cursor.lastrowid
        
        # Procesar herramientas usando la nueva tabla asignacion_herramientas
        for key, value in request.form.items():
            if key not in ['id_codigo_consumidor', 'fecha', 'cargo'] and value == '1' and key.strip():
                # Verificar que la clave no esté vacía
                if key.strip():
                    try:
                        # Mantener compatibilidad con el enfoque anterior
                        campo = f"asignacion_{key}"
                        if len(campo) > 11:  # 'asignacion_' tiene 11 caracteres
                            try:
                                # Actualizar la columna en la tabla asignacion si existe
                                query = f"""
                                    UPDATE asignacion 
                                    SET {campo} = '1'
                                    WHERE id_asignacion = %s
                                """
                                cursor.execute(query, (id_asignacion,))
                            except mysql.connector.Error as e:
                                # Si hay error, es probable que la columna no exista
                                # Continuamos con el nuevo enfoque
                                print(f"Columna {campo} no encontrada: {str(e)}")
                        
                        # Insertar en la nueva tabla asignacion_herramientas
                        cursor.execute("""
                            INSERT INTO asignacion_herramientas 
                            (id_asignacion, codigo, descripcion, estado) 
                            VALUES (%s, %s, %s, %s)
                        """, (
                            id_asignacion, 
                            key,  # Usar la clave como código
                            key.replace('_', ' ').title(),  # Convertir a formato legible
                            '1'  # Estado activo
                        ))
                    except mysql.connector.Error as e:
                        # Registrar el error pero continuar con otras herramientas
                        print(f"Error al guardar herramienta {key}: {str(e)}")
                        continue
        
        # Si hay imagen, guardarla en la tabla asignacion_herramientas como un registro especial
        if imagen_path:
            try:
                cursor.execute("""
                    INSERT INTO asignacion_herramientas 
                    (id_asignacion, codigo, descripcion, estado) 
                    VALUES (%s, %s, %s, %s)
                """, (
                    id_asignacion, 
                    'imagen',  
                    imagen_path,  # Guardar la ruta de la imagen
                    '1'  # Estado activo
                ))
            except mysql.connector.Error as e:
                print(f"Error al guardar imagen: {str(e)}")
        
        connection.commit()
        return jsonify({
            'status': 'success',
            'message': 'Asignación guardada correctamente',
            'id_asignacion': id_asignacion
        })
        
    except mysql.connector.Error as e:
        return jsonify({'status': 'error', 'message': f'Error al guardar la asignación: {str(e)}'})
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Modificar la ruta de obtener detalles para incluir la imagen
@app.route('/logistica/guardar_asignacion_simple', methods=['POST'])
@login_required(role=['administrativo', 'logistica'])
def guardar_asignacion_simple():
    connection = None
    cursor = None
    try:
        # Obtener datos básicos del formulario
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha = request.form.get('fecha')
        cargo = request.form.get('cargo')
        
        # Validar datos requeridos
        if not id_codigo_consumidor or not fecha or not cargo:
            return jsonify({
                'status': 'error',
                'message': 'Faltan campos obligatorios'
            }), 400
            
        # Obtener conexión a la base de datos
        connection = get_db_connection()
        if not connection:
            return jsonify({
                'status': 'error',
                'message': 'Error al conectar con la base de datos'
            }), 500
            
        # Obtener información del técnico
        cursor = connection.cursor(dictionary=True)
        
        query_tecnico = """
            SELECT nombre, recurso_operativo_cedula 
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """
        cursor.execute(query_tecnico, (id_codigo_consumidor,))
        tecnico = cursor.fetchone()
        
        if not tecnico:
            return jsonify({
                'status': 'error',
                'message': 'Técnico no encontrado'
            }), 404
            
        # Convertir fecha a formato datetime
        try:
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%dT%H:%M')
            fecha_formateada = fecha_obj.strftime('%Y-%m-%d %H:%M:%S')
        except ValueError:
            return jsonify({
                'status': 'error',
                'message': 'Formato de fecha inválido'
            }), 400
        
        # Insertar asignación básica
        query = """
            INSERT INTO asignacion (
                id_codigo_consumidor, 
                asignacion_cedula, 
                asignacion_nombre, 
                asignacion_fecha, 
                asignacion_cargo, 
                asignacion_estado
            ) VALUES (%s, %s, %s, %s, %s, %s)
        """
        
        # Ejecutar consulta
        cursor.execute(query, [
            id_codigo_consumidor,
            tecnico['recurso_operativo_cedula'],  # cedula
            tecnico['nombre'],  # nombre
            fecha_formateada,
            cargo,
            '1'  # Estado activo
        ])
        
        # Obtener ID de la asignación
        id_asignacion = cursor.lastrowid
        
        # Procesar herramientas seleccionadas
        for key, value in request.form.items():
            if key not in ['id_codigo_consumidor', 'fecha', 'cargo'] and value == '1' and key.strip():
                try:
                    # Insertar en la tabla asignacion_herramientas
                    cursor.execute("""
                        INSERT INTO asignacion_herramientas 
                        (id_asignacion, codigo, descripcion, estado) 
                        VALUES (%s, %s, %s, %s)
                    """, (
                        id_asignacion, 
                        key,  # Usar la clave como código
                        key.replace('_', ' ').title(),  # Convertir a formato legible
                        '1'  # Estado activo
                    ))
                except mysql.connector.Error as e:
                    # Registrar el error pero continuar con otras herramientas
                    print(f"Error al guardar herramienta {key}: {str(e)}")
                    continue
        
        # Hacer commit y devolver respuesta exitosa
        connection.commit()
        return jsonify({
            'status': 'success',
            'message': 'Asignación básica guardada correctamente',
            'id_asignacion': id_asignacion
        }), 200
            
    except mysql.connector.Error as e:
        if connection:
            connection.rollback()
        return jsonify({
            'status': 'error',
            'message': f'Error al guardar la asignación simple: {str(e)}'
        }), 500
    except Exception as e:
        if connection:
            connection.rollback()
        return jsonify({
            'status': 'error',
            'message': f'Error al procesar la solicitud: {str(e)}'
        }), 500
    finally:
        # Asegurarse de cerrar cursor y conexión
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/logistica/asignacion/<int:id>')
@login_required(role=['administrativo', 'logistica'])
def obtener_detalle_asignacion(id):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos'})
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información básica
        cursor.execute("""
            SELECT a.*, ro.nombre, ro.recurso_operativo_cedula
            FROM asignacion a
            JOIN recurso_operativo ro ON a.id_codigo_consumidor = ro.id_codigo_consumidor
            WHERE a.id_asignacion = %s
        """, (id,))
        
        asignacion = cursor.fetchone()
        if not asignacion:
            return jsonify({'status': 'error', 'message': 'Asignación no encontrada'})
            
        # Buscar imagen en la tabla asignacion_herramientas
        cursor.execute("""
            SELECT descripcion
            FROM asignacion_herramientas
            WHERE id_asignacion = %s AND codigo = 'imagen'
        """, (id,))
        
        imagen_result = cursor.fetchone()
        imagen_path = imagen_result['descripcion'] if imagen_result else None
        imagen_url = url_for('static', filename=imagen_path) if imagen_path else None
        
        info_basica = {
            'tecnico': asignacion['nombre'],
            'cedula': asignacion['recurso_operativo_cedula'],
            'cargo': asignacion['asignacion_cargo'],
            'fecha': asignacion['asignacion_fecha'].strftime('%Y-%m-%d %H:%M:%S'),
            'estado': 'Activo' if asignacion['asignacion_estado'] == '1' else 'Inactivo',
            'imagen': imagen_url
        }
        
        # Obtener detalles de herramientas
        cursor.execute("""
            SELECT codigo, descripcion, estado
            FROM asignacion_herramientas
            WHERE id_asignacion = %s
        """, (id,))
        
        herramientas = cursor.fetchall()
        
        # Clasificar herramientas
        herramientas_basicas = {}
        brocas = {}
        herramientas_red = {}
        
        for h in herramientas:
            nombre = h['descripcion']
            estado = h['estado']
            codigo = h['codigo']
            
            if 'broca' in nombre.lower():
                brocas[nombre] = {'estado': estado, 'codigo': codigo}
            elif any(red in nombre.lower() for red in ['cajon', 'cinta', 'cono', 'llave', 'ponchadora']):
                herramientas_red[nombre] = {'estado': estado, 'codigo': codigo}
            else:
                herramientas_basicas[nombre] = {'estado': estado, 'codigo': codigo}
        
        return jsonify({
            'status': 'success',
            'data': {
                'info_basica': info_basica,
                'herramientas_basicas': herramientas_basicas,
                'brocas': brocas,
                'herramientas_red': herramientas_red
            }
        })
        
    except mysql.connector.Error as e:
        return jsonify({'status': 'error', 'message': f'Error de base de datos: {str(e)}'})
    except Exception as e:
        return jsonify({'status': 'error', 'message': f'Error inesperado: {str(e)}'})
    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'connection' in locals() and connection.is_connected():
            connection.close()

@app.route('/logistica/asignacion/<int:id_asignacion>/pdf', methods=['GET'])
@login_required(role=['administrativo', 'logistica'])
def generar_pdf_asignacion(id_asignacion):
    try:
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib import colors
        from reportlab.lib.pagesizes import letter
        from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
        from reportlab.lib.units import inch
        from reportlab.platypus import Image as RLImage
        import base64
        import re
        from io import BytesIO
        
        # Obtener parámetros de la URL
        mostrar_firma = request.args.get('firmado', 'false').lower() == 'true'
        
        connection = get_db_connection()
        if not connection:
            return jsonify({'status': 'error', 'message': 'Error de conexión a la base de datos'})
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información de la asignación incluyendo la firma
        cursor.execute("""
            SELECT a.*, ro.nombre, ro.recurso_operativo_cedula, fa.firma_imagen
            FROM asignacion a
            JOIN recurso_operativo ro ON a.id_codigo_consumidor = ro.id_codigo_consumidor
            LEFT JOIN firmas_asignaciones fa ON a.id_asignacion = fa.id_asignacion
            WHERE a.id_asignacion = %s
        """, (id_asignacion,))
        
        asignacion = cursor.fetchone()
        if not asignacion:
            return jsonify({'status': 'error', 'message': 'Asignación no encontrada'})
            
        # Obtener la firma si existe
        firma_imagen = asignacion.get('firma_imagen') if mostrar_firma else None
        
        # Obtener la imagen de la asignación si existe
        cursor.execute("""
            SELECT descripcion
            FROM asignacion_herramientas
            WHERE id_asignacion = %s AND codigo = 'imagen'
        """, (id_asignacion,))
        
        imagen_result = cursor.fetchone()
        imagen_path = imagen_result['descripcion'] if imagen_result else None
        
        # Crear PDF con ReportLab
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        contenido = []
        
        # Definir todos los estilos necesarios
        styles = getSampleStyleSheet()
        estilo_heading = ParagraphStyle(
            'CustomHeading',
            parent=styles['Heading1'],
            fontSize=14,
            spaceAfter=12,
            spaceBefore=12,
            textColor=colors.black,
            alignment=1  # Centrado
        )
        
        estilo_normal = ParagraphStyle(
            'CustomNormal',
            parent=styles['Normal'],
            fontSize=10,
            spaceBefore=6,
            spaceAfter=6
        )
        
        estilo_titulo = ParagraphStyle(
            'CustomTitle',
            parent=styles['Title'],
            fontSize=16,
            spaceAfter=30,
            alignment=1  # Centrado
        )
        
        # Título
        contenido.append(Paragraph("Formato de Asignación de Herramientas", estilo_titulo))
        
        # Información básica
        data = [
            ["Técnico:", asignacion['nombre']],
            ["Cédula:", asignacion['recurso_operativo_cedula']],
            ["Cargo:", asignacion['asignacion_cargo']],
            ["Fecha:", asignacion['asignacion_fecha'].strftime('%Y-%m-%d %H:%M:%S')],
            ["Estado:", "Activo" if asignacion['asignacion_estado'] == '1' else "Inactivo"]
        ]
        
        # Crear tabla de información básica
        table = Table(data, colWidths=[100, 400])
        table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('PADDING', (0, 0), (-1, -1), 4)
        ]))
        contenido.append(table)
        contenido.append(Spacer(1, 10))
        
        # Agregar imagen de la asignación si existe
        if imagen_path:
            try:
                contenido.append(Paragraph("Imagen de Herramientas", estilo_heading))
                contenido.append(Spacer(1, 10))
                
                # Ruta completa de la imagen
                ruta_completa = os.path.join(app.root_path, 'static', imagen_path)
                
                if os.path.exists(ruta_completa):
                    # Crear imagen para ReportLab con tamaño controlado
                    imagen_asignacion = RLImage(ruta_completa, width=400, height=200, kind='proportional')
                    contenido.append(imagen_asignacion)
                    app.logger.info(f"Imagen añadida al PDF correctamente: {ruta_completa}")
                else:
                    contenido.append(Paragraph("(Imagen no encontrada)", styles['Normal']))
                    app.logger.warning(f"Imagen no encontrada en la ruta: {ruta_completa}")
                
                contenido.append(Spacer(1, 10))
            except Exception as e:
                app.logger.error(f"Error al procesar imagen para PDF: {str(e)}")
                contenido.append(Paragraph("(Error al cargar imagen)", styles['Normal']))
                import traceback
                app.logger.error(traceback.format_exc())
        
        # Sección de herramientas
        contenido.append(Paragraph("Herramientas Asignadas", estilo_heading))
        contenido.append(Spacer(1, 10))
        
        # Lista de herramientas conocidas y sus descripciones
        herramientas_mapping = {
            'adaptador_mandril': 'Adaptador Mandril',
            'alicate': 'Alicate',
            'barra_45cm': 'Barra 45cm',
            'bisturi_metalico': 'Bisturí Metálico',
            'broca_3_8': 'Broca 3/8',
            'broca_386_ran': 'Broca 3/8 6 Ranuras',
            'broca_126_ran': 'Broca 1/2 6 Ranuras',
            'broca_metalmadera_14': 'Broca Metal/Madera 1/4',
            'broca_metalmadera_38': 'Broca Metal/Madera 3/8',
            'broca_metalmadera_516': 'Broca Metal/Madera 5/16',
            'caja_de_herramientas': 'Caja de Herramientas',
            'cajon_rojo': 'Cajón Rojo',
            'cinta_de_senal': 'Cinta de Señal',
            'cono_retractil': 'Cono Retráctil',
            'cortafrio': 'Cortafrío',
            'destor_de_estrella': 'Destornillador de Estrella',
            'destor_de_pala': 'Destornillador de Pala',
            'destor_tester': 'Destornillador Tester',
            'espatula': 'Espátula',
            'exten_de_corr_10_mts': 'Extensión de Corriente 10mts',
            'llave_locking_male': 'Llave Locking Male',
            'llave_reliance': 'Llave Reliance',
            'llave_torque_rg_11': 'Llave Torque RG-11',
            'llave_torque_rg_6': 'Llave Torque RG-6',
            'llaves_mandril': 'Llaves Mandril',
            'mandril_para_taladro': 'Mandril para Taladro',
            'martillo_de_una': 'Martillo de Una',
            'multimetro': 'Multímetro',
            'pelacable_rg_6y_rg_11': 'Pelacable RG-6 y RG-11',
            'pinza_de_punta': 'Pinza de Punta',
            'pistola_de_silicona': 'Pistola de Silicona',
            'planillero': 'Planillero',
            'ponchadora_rg_6_y_rg_11': 'Ponchadora RG-6 y RG-11',
            'ponchadora_rj_45_y_rj11': 'Ponchadora RJ-45 y RJ-11',
            'probador_de_tonos': 'Probador de Tonos',
            'probador_de_tonos_utp': 'Probador de Tonos UTP',
            'puntas_para_multimetro': 'Puntas para Multímetro',
            'sonda_metalica': 'Sonda Metálica',
            'tacos_de_madera': 'Tacos de Madera',
            'taladro_percutor': 'Taladro Percutor',
            'telefono_de_pruebas': 'Teléfono de Pruebas',
            'power_miter': 'Power Miter',
            'bfl_laser': 'BFL Laser',
            'cortadora': 'Cortadora',
            'stripper_fibra': 'Stripper Fibra',
            'pelachaqueta': 'Pelachaqueta'
        }
        
        # Obtener herramientas de la nueva tabla asignacion_herramientas
        cursor.execute("""
            SELECT codigo, descripcion, estado
            FROM asignacion_herramientas
            WHERE id_asignacion = %s AND codigo != 'imagen'
        """, (id_asignacion,))
        
        herramientas_db = cursor.fetchall()
        
        # Crear lista de herramientas asignadas
        herramientas_asignadas = []
        
        # Primero intentar usar las herramientas de la nueva tabla
        if herramientas_db:
            for herramienta in herramientas_db:
                codigo = herramienta['codigo']
                descripcion = herramienta['descripcion']
                estado = 'Asignada' if herramienta['estado'] == '1' else 'Inactiva'
                
                herramientas_asignadas.append([
                    codigo,
                    descripcion,
                    estado
                ])
        else:
            # Compatibilidad con el enfoque anterior
            for campo, valor in asignacion.items():
                if campo.startswith('asignacion_') and campo not in ['asignacion_fecha', 'asignacion_cargo', 'asignacion_estado', 'asignacion_firma']:
                    nombre_herramienta = campo.replace('asignacion_', '')
                    if valor == '1' and nombre_herramienta in herramientas_mapping:
                        herramientas_asignadas.append([
                            nombre_herramienta,
                            herramientas_mapping[nombre_herramienta],
                            'Asignada'
                        ])
        
        if herramientas_asignadas:
            # Crear tabla de herramientas
            headers = ['Código', 'Descripción', 'Estado']
            data_herramientas = [headers] + herramientas_asignadas
            
            tabla_herramientas = Table(data_herramientas, colWidths=[100, 300, 100])
            tabla_herramientas.setStyle(TableStyle([
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('PADDING', (0, 0), (-1, -1), 4),
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey)
            ]))
            contenido.append(tabla_herramientas)
        else:
            contenido.append(Paragraph("No hay herramientas asignadas", styles['Normal']))
        
        contenido.append(Spacer(1, 30))
        
        # Sección de firma si se solicitó
        if mostrar_firma and firma_imagen:
            try:
                contenido.append(Paragraph("Firma de Aceptación", estilo_heading))
                contenido.append(Spacer(1, 10))
                
                # Manejamos la imagen en memoria, evitando archivos temporales
                if firma_imagen.startswith('data:image'):
                    # Extraer la parte base64
                    firma_base64 = re.sub(r'^data:image/[^;]+;base64,', '', firma_imagen)
                    
                    # Decodificar a bytes
                    firma_bytes = base64.b64decode(firma_base64)
                    
                    # Crear buffer de memoria para la imagen
                    firma_buffer = BytesIO(firma_bytes)
                    
                    # Crear imagen para ReportLab
                    firma_img = RLImage(firma_buffer, width=200, height=100)
                    
                    # Añadir al contenido
                    contenido.append(firma_img)
                    app.logger.info("Firma añadida al PDF correctamente")
                else:
                    contenido.append(Paragraph("(Formato de firma no válido)", styles['Normal']))
                    app.logger.warning("Formato de firma no válido para incluir en PDF")
            except Exception as e:
                app.logger.error(f"Error al procesar firma para PDF: {str(e)}")
                contenido.append(Paragraph("(Error al cargar firma)", styles['Normal']))
                import traceback
                app.logger.error(traceback.format_exc())
        
        contenido.append(Spacer(1, 20))
        
        # Pie de página con fecha de generación
        fecha_generacion = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        pie = Paragraph(f"Documento generado el {fecha_generacion}", styles['Normal'])
        contenido.append(pie)
        
        # Construir el PDF
        doc.build(contenido)
        
        # Obtener los datos del buffer
        pdf_data = buffer.getvalue()
        buffer.close()
        
        # Crear respuesta
        response = make_response(pdf_data)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'inline; filename=asignacion_{id_asignacion}.pdf'
        
        app.logger.info(f"PDF generado correctamente para asignación {id_asignacion}")
        return response
        
    except Exception as e:
        app.logger.error(f"Error al generar PDF: {str(e)}")
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({
            'status': 'error',
            'message': f'Error al generar el PDF: {str(e)}'
        }), 500

@app.route('/logistica/asignacion/<int:id_asignacion>/firmar', methods=['POST'])
@login_required()
@role_required('logistica')
def firmar_asignacion(id_asignacion):
    try:
        # Verificar que el usuario tiene derechos para firmar
        usuario_id = session.get('user_id')
        app.logger.info(f"Intento de firma para asignación {id_asignacion} por usuario {usuario_id}")
        
        # Obtener la conexión a la base de datos
        connection = get_db_connection()
        if not connection:
            app.logger.error("Error al conectar con la base de datos al intentar firmar")
            return jsonify({
                'status': 'error',
                'message': 'Error al conectar con la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información de la asignación para verificar permisos
        query = """
            SELECT a.*, r.nombre, r.recurso_operativo_cedula
            FROM asignacion a
            JOIN recurso_operativo r ON a.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE a.id_asignacion = %s
        """
        cursor.execute(query, (id_asignacion,))
        asignacion = cursor.fetchone()
        
        if not asignacion:
            cursor.close()
            connection.close()
            app.logger.warning(f"Intento de firma para asignación inexistente: {id_asignacion}")
            return jsonify({
                'status': 'error',
                'message': 'Asignación no encontrada'
            }), 404
        
        # Obtener los datos de la firma manuscrita
        data = request.json
        if not data or 'signature' not in data:
            app.logger.warning("Datos de firma incompletos o inválidos")
            return jsonify({
                'status': 'error',
                'message': 'No se recibieron datos de firma'
            }), 400
        
        # Validar formato de la firma
        firma_imagen = data['signature']
        if not firma_imagen.startswith('data:image/'):
            app.logger.warning("Formato de imagen de firma inválido")
            return jsonify({
                'status': 'error',
                'message': 'Formato de imagen de firma inválido'
            }), 400
        
        # Verificar el tamaño de la firma (para evitar datos demasiado grandes)
        if len(firma_imagen) > 500000:  # Limitar a ~500KB
            app.logger.warning("Imagen de firma demasiado grande")
            return jsonify({
                'status': 'error',
                'message': 'La imagen de firma es demasiado grande'
            }), 400
            
        fecha_firma = datetime.now()
        app.logger.info(f"Firma recibida correctamente para asignación {id_asignacion}")
        
        # Verificar que la firma se puede procesar correctamente
        try:
            # Extraer la parte base64 de la firma
            if 'data:image' in firma_imagen:
                imagen_base64 = re.sub(r'^data:image/[^;]+;base64,', '', firma_imagen)
            
            # Verificar que la decodificación funciona
            imagen_bytes = base64.b64decode(imagen_base64)
            
            # Verificar que la imagen es válida creando un objeto Image con ella
            with PILImage.open(BytesIO(imagen_bytes)) as img:
                formato = img.format
                width, height = img.size
                app.logger.info(f"Imagen de firma validada: formato={formato}, dimensiones={width}x{height}")
        except Exception as e:
            app.logger.error(f"Error al validar la imagen de firma: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': f'Error al procesar la imagen de firma: {str(e)}'
            }), 400
        
        # Primero verificar si existe la tabla para firmas
        try:
            check_table_query = """
                CREATE TABLE IF NOT EXISTS firmas_asignaciones (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    id_asignacion INT NOT NULL,
                    id_usuario INT NOT NULL,
                    firma_imagen LONGTEXT,
                    fecha_firma DATETIME,
                    FOREIGN KEY (id_asignacion) REFERENCES asignacion(id_asignacion)
                )
            """
            cursor.execute(check_table_query)
            connection.commit()
            app.logger.info("Tabla firmas_asignaciones verificada/creada correctamente")
        except Exception as e:
            app.logger.error(f"Error al verificar tabla de firmas: {str(e)}")
            # Continuar aún si falla la verificación, ya que podría existir
        
        # Guardar la firma en la base de datos
        firma_guardada = False
        try:
            # Verificar si ya existe una firma para esta asignación
            cursor.execute("SELECT id FROM firmas_asignaciones WHERE id_asignacion = %s", (id_asignacion,))
            firma_existente = cursor.fetchone()
            
            if firma_existente:
                # Actualizar firma existente
                update_query = """
                    UPDATE firmas_asignaciones 
                    SET firma_imagen = %s, fecha_firma = %s, id_usuario = %s
                    WHERE id_asignacion = %s
                """
                cursor.execute(update_query, (firma_imagen, fecha_firma, usuario_id, id_asignacion))
                app.logger.info(f"Firma actualizada para asignación {id_asignacion}")
            else:
                # Insertar nueva firma
                insert_query = """
                    INSERT INTO firmas_asignaciones 
                    (id_asignacion, id_usuario, firma_imagen, fecha_firma) 
                    VALUES (%s, %s, %s, %s)
                """
                cursor.execute(insert_query, (id_asignacion, usuario_id, firma_imagen, fecha_firma))
                app.logger.info(f"Nueva firma guardada para asignación {id_asignacion}")
            
            connection.commit()
            firma_guardada = True
        except Exception as e:
            app.logger.error(f"Error al guardar firma en base de datos: {str(e)}")
            connection.rollback()
            # Si falla, seguimos para intentar generar el PDF igualmente
            import traceback
            app.logger.error(traceback.format_exc())
            
        # Generar un token JWT como respaldo o para verificación alternativa
        payload = {
            'asignacion_id': id_asignacion,
            'usuario_id': usuario_id,
            'fecha': fecha_firma.strftime('%Y-%m-%d %H:%M:%S'),
            'firma_guardada': firma_guardada,
            'iat': fecha_firma.timestamp(),
            'exp': (fecha_firma + timedelta(days=365)).timestamp()
        }
        
        # En un entorno real, este secreto estaría almacenado de manera segura
        clave_secreta = os.getenv('JWT_SECRET_KEY', 'clave_secreta_para_firmas')
        token = jwt.encode(payload, clave_secreta, algorithm='HS256')
        
        # Cerrar cursor y conexión
        cursor.close()
        connection.close()
        
        # Devolver URL al PDF firmado
        url_pdf_firmado = url_for('generar_pdf_asignacion', id_asignacion=id_asignacion, firmado='true', _external=True)
        
        app.logger.info(f"Proceso de firma completado exitosamente para asignación {id_asignacion}")
        return jsonify({
            'status': 'success',
            'message': 'Documento firmado correctamente',
            'token': token,
            'url_pdf': url_pdf_firmado,
            'firma_guardada': firma_guardada
        })
        
    except Exception as e:
        app.logger.error(f"Error inesperado al firmar documento: {str(e)}")
        
        # Log detallado para diagnóstico
        import traceback
        app.logger.error(traceback.format_exc())
        
        return jsonify({
            'status': 'error',
            'message': f'Error al firmar el documento: {str(e)}'
        }), 500

@app.route('/api/inventario/filtrar', methods=['POST'])
@login_required()
@role_required('logistica')
def filtrar_inventario():
    try:
        # Obtener parámetros del filtro
        filtros = request.json
        categoria = filtros.get('categoria', 'todos')
        ubicacion = filtros.get('ubicacion', 'todos')
        fecha_inicio = filtros.get('fecha_inicio')
        fecha_fin = filtros.get('fecha_fin')
        estado = filtros.get('estado', 'todos')
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Construir consultas según filtros
        params = []
        where_clauses = []
        
        # Base de la consulta para movimientos
        movimientos_query = """
            SELECT 
                DATE(fecha_movimiento) as fecha,
                tipo_movimiento,
                item_afectado,
                cantidad,
                usuario,
                ubicacion
            FROM movimientos_inventario
            WHERE 1=1
        """
        
        # Aplicar filtros de fecha
        if fecha_inicio:
            where_clauses.append("fecha_movimiento >= %s")
            params.append(fecha_inicio)
        
        if fecha_fin:
            where_clauses.append("fecha_movimiento <= %s")
            params.append(fecha_fin)
        
        # Aplicar filtro de categoría
        if categoria != 'todos':
            # Mapeo de categorías a items
            categoria_items = {
                'herramientas_basicas': ['Adaptador Mandril', 'Alicate', 'Barra 45cm', 'Bisturí Metálico', 
                                         'Caja de Herramientas', 'Cortafrío', 'Destornillador Estrella', 
                                         'Destornillador Pala', 'Destornillador Tester', 'Martillo', 'Pinza de Punta'],
                'herramientas_especializadas': ['Multímetro', 'Taladro Percutor', 'Ponchadora RG6/RG11', 
                                               'Ponchadora RJ45/RJ11', 'Power Meter', 'BFL Laser', 
                                               'Cortadora', 'Stripper Fibra'],
               'material_ferretero': ['Silicona', 'Amarres Negros', 'Amarres Blancos', 
                                      'Cinta Aislante', 'Grapas Blancas', 'Grapas Negras']
            }
            
            if categoria in categoria_items:
                item_placeholders = ', '.join(['%s'] * len(categoria_items[categoria]))
                where_clauses.append(f"item_afectado IN ({item_placeholders})")
                params.extend(categoria_items[categoria])
        
        # Aplicar filtro de ubicación
        if ubicacion != 'todos':
            where_clauses.append("ubicacion = %s")
            params.append(ubicacion)
        
        # Construir consulta final
        if where_clauses:
            movimientos_query += " AND " + " AND ".join(where_clauses)
        
        movimientos_query += " ORDER BY fecha_movimiento DESC LIMIT 100"
        
        # Ejecutar consulta
        cursor.execute(movimientos_query, params)
        movimientos = cursor.fetchall()
        
        # Procesar datos para el gráfico de tendencia
        ultimos_30_dias = []
        hoy = datetime.now().date()
        for i in range(30, -1, -1):
            fecha = hoy - timedelta(days=i)
            ultimos_30_dias.append(fecha.strftime('%Y-%m-%d'))
        
        movimientos_por_dia = {}
        for fecha in ultimos_30_dias:
            movimientos_por_dia[fecha] = 0
            
        for movimiento in movimientos:
            fecha_str = movimiento['fecha'].strftime('%Y-%m-%d')
            if fecha_str in movimientos_por_dia:
                movimientos_por_dia[fecha_str] += 1
        
        # Preparar datos del gráfico de tendencia
        datos_tendencia = {
            'labels': ultimos_30_dias,
            'datos': [movimientos_por_dia.get(fecha, 0) for fecha in ultimos_30_dias]
        }
        
        # Simular estadísticas según los filtros
        # En una implementación real, estos datos se obtendrían de la base de datos
        estadisticas = {
            'total_items': len(movimientos),
            'entradas': sum(1 for m in movimientos if m['tipo_movimiento'] == 'entrada'),
            'salidas': sum(1 for m in movimientos if m['tipo_movimiento'] == 'salida'),
            'transferencias': sum(1 for m in movimientos if m['tipo_movimiento'] == 'transferencia'),
            'ajustes': sum(1 for m in movimientos if m['tipo_movimiento'] == 'ajuste')
        }
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'movimientos': movimientos,
            'tendencia': datos_tendencia,
            'estadisticas': estadisticas
        })
        
    except Exception as e:
        print(f"Error al filtrar inventario: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/inventario/exportar-csv', methods=['POST'])
@login_required()
@role_required('logistica')
def exportar_inventario_csv():
    try:
        # Obtener parámetros del filtro (similar a filtrar_inventario)
        filtros = request.json
        
        # Obtener datos según filtros...
        # (Código similar a filtrar_inventario para obtener los datos)
        
        # Para este ejemplo, usaremos datos simulados
        datos = []
        
        # Herramientas básicas
        for item in ['Adaptador Mandril', 'Alicate', 'Barra 45cm', 'Bisturí Metálico', 
                    'Caja de Herramientas', 'Cortafrío', 'Destornillador Estrella']:
            datos.append({
                'categoria': 'Herramientas Básicas',
                'item': item,
                'cantidad': 15,
                'ubicacion': 'Almacén Principal',
                'estado': 'Disponible'
            })
        
        # Herramientas especializadas
        for item in ['Multímetro', 'Taladro Percutor', 'Ponchadora RG6/RG11']:
            datos.append({
                'categoria': 'Herramientas Especializadas',
                'item': item,
                'cantidad': 8,
                'ubicacion': 'Bodega Norte',
                'estado': 'Disponible'
            })
        
        # Material ferretero
        for item in ['Silicona', 'Amarres Negros', 'Amarres Blancos']:
            datos.append({
                'categoria': 'Material Ferretero',
                'item': item,
                'cantidad': 50,
                'ubicacion': 'Bodega Sur',
                'estado': 'Disponible'
            })
        
        # Crear DataFrame y exportar a CSV
        df = pd.DataFrame(datos)
        csv_data = df.to_csv(index=False, sep=';')
        
        # Crear un objeto de archivo en memoria
        output = io.StringIO()
        output.write(csv_data)
        output.seek(0)
        
        # Devolver el archivo CSV
        return Response(
            output.getvalue(),
            mimetype="text/csv",
            headers={"Content-disposition": "attachment; filename=inventario.csv"}
        )
        
    except Exception as e:
        print(f"Error al exportar inventario a CSV: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/suministros', methods=['GET', 'POST'])
def suministros():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return redirect(url_for('dashboard'))
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todos los suministros
        cursor.execute("SELECT * FROM suministros")
        suministros_data = cursor.fetchall()
        
        return render_template('modulos/administrativo/suministros.html', suministros=suministros_data)
    
    except mysql.connector.Error as e:
        flash(f'Error de base de datos: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/guardar_suministro', methods=['POST'])
@login_required()
def guardar_suministro():
    connection = None
    cursor = None
    try:
        # Obtener datos del formulario
        suministros_codigo = request.form.get('suministros_codigo')
        suministros_descripcion = request.form.get('suministros_descripcion')
        suministros_unidad_medida = request.form.get('suministros_unidad_medida')
        suministros_familia = request.form.get('suministros_familia')
        suministros_cliente = request.form.get('suministros_cliente')
        suministros_tipo = request.form.get('suministros_tipo')
        suministros_estado = request.form.get('suministros_estado', 'Activo')
        suministros_requiere_serial = request.form.get('suministros_requiere_serial', 'no')
        suministros_serial = request.form.get('suministros_serial', '')
        suministros_costo_unitario = request.form.get('suministros_costo_unitario')
        suministros_cantidad = request.form.get('suministros_cantidad')
        fecha_registro = request.form.get('fecha_registro')
        id_codigo_consumidor = request.form.get('id_codigo_consumidor', session.get('user_id'))
        
        # Validar datos requeridos
        if not all([suministros_codigo, suministros_descripcion, suministros_unidad_medida, 
                    suministros_familia, suministros_costo_unitario, suministros_cantidad]):
            flash('Por favor complete todos los campos requeridos.', 'error')
            return redirect(url_for('suministros'))
        
        # Conectar a la base de datos
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return redirect(url_for('suministros'))
        
        cursor = connection.cursor()
        
        # Insertar nuevo suministro
        query = """
        INSERT INTO suministros (
            suministros_codigo, suministros_descripcion, suministros_unidad_medida,
            suministros_familia, suministros_cliente, suministros_tipo, suministros_estado,
            suministros_requiere_serial, suministros_serial, suministros_costo_unitario,
            suministros_cantidad, fecha_registro, id_codigo_consumidor
        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        values = (
            suministros_codigo, suministros_descripcion, suministros_unidad_medida,
            suministros_familia, suministros_cliente, suministros_tipo, suministros_estado,
            suministros_requiere_serial, suministros_serial, suministros_costo_unitario,
            suministros_cantidad, fecha_registro, id_codigo_consumidor
        )
        
        cursor.execute(query, values)
        connection.commit()
        
        flash('Suministro guardado exitosamente.', 'success')
        return redirect(url_for('suministros'))
        
    except mysql.connector.Error as e:
        flash(f'Error al guardar suministro: {str(e)}', 'error')
        return redirect(url_for('suministros'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/obtener_suministro/<int:id>', methods=['GET'])
@login_required()
def obtener_suministro(id):
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener suministro por ID
        cursor.execute("SELECT * FROM suministros WHERE id_suministros = %s", (id,))
        suministro = cursor.fetchone()
        
        if not suministro:
            return jsonify({'error': 'Suministro no encontrado'}), 404
        
        return jsonify(suministro)
        
    except mysql.connector.Error as e:
        return jsonify({'error': str(e)}), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/actualizar_suministro', methods=['POST'])
@login_required()
def actualizar_suministro():
    connection = None
    cursor = None
    try:
        # Obtener datos del formulario
        id_suministros = request.form.get('id_suministros')
        suministros_codigo = request.form.get('suministros_codigo')
        suministros_descripcion = request.form.get('suministros_descripcion')
        suministros_unidad_medida = request.form.get('suministros_unidad_medida')
        suministros_familia = request.form.get('suministros_familia')
        suministros_cliente = request.form.get('suministros_cliente')
        suministros_tipo = request.form.get('suministros_tipo')
        suministros_estado = request.form.get('suministros_estado', 'Activo')
        suministros_requiere_serial = request.form.get('suministros_requiere_serial', 'no')
        suministros_serial = request.form.get('suministros_serial', '')
        suministros_costo_unitario = request.form.get('suministros_costo_unitario')
        suministros_cantidad = request.form.get('suministros_cantidad')
        
        # Validar datos requeridos
        if not all([id_suministros, suministros_codigo, suministros_descripcion, suministros_unidad_medida, 
                    suministros_familia, suministros_costo_unitario, suministros_cantidad]):
            flash('Por favor complete todos los campos requeridos.', 'error')
            return redirect(url_for('suministros'))
        
        # Conectar a la base de datos
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return redirect(url_for('suministros'))
        
        cursor = connection.cursor()
        
        # Actualizar suministro
        query = """
        UPDATE suministros SET 
            suministros_codigo = %s, 
            suministros_descripcion = %s, 
            suministros_unidad_medida = %s,
            suministros_familia = %s, 
            suministros_cliente = %s, 
            suministros_tipo = %s, 
            suministros_estado = %s,
            suministros_requiere_serial = %s, 
            suministros_serial = %s, 
            suministros_costo_unitario = %s,
            suministros_cantidad = %s
        WHERE id_suministros = %s
        """
        values = (
            suministros_codigo, suministros_descripcion, suministros_unidad_medida,
            suministros_familia, suministros_cliente, suministros_tipo, suministros_estado,
            suministros_requiere_serial, suministros_serial, suministros_costo_unitario,
            suministros_cantidad, id_suministros
        )
        
        cursor.execute(query, values)
        connection.commit()
        
        flash('Suministro actualizado exitosamente.', 'success')
        return redirect(url_for('suministros'))
        
    except mysql.connector.Error as e:
        flash(f'Error al actualizar suministro: {str(e)}', 'error')
        return redirect(url_for('suministros'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/eliminar_suministro/<int:id>', methods=['POST'])
@login_required()
def eliminar_suministro(id):
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor()
        
        # Eliminar suministro
        cursor.execute("DELETE FROM suministros WHERE id_suministros = %s", (id,))
        connection.commit()
        
        return jsonify({'success': True, 'message': 'Suministro eliminado correctamente'})
        
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error al eliminar suministro: {str(e)}'}), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/admin/usuarios', methods=['GET'])
@login_required(role='administrativo')
def usuarios():
    connection = None
    cursor = None
    try:
        page = request.args.get('page', 1, type=int)
        items_per_page = 10  # Número de usuarios por página (solo para referencia en la plantilla)
        
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos.', 'error')
            return redirect(url_for('dashboard'))
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener total de usuarios para calcular el número de páginas
        cursor.execute("SELECT COUNT(*) as total FROM recurso_operativo")
        total_users = cursor.fetchone()['total']
        total_pages = (total_users + items_per_page - 1) // items_per_page  # Redondeo hacia arriba
        
        # Obtener TODOS los usuarios sin paginación para permitir filtrado completo
        query = """
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                nombre,
                id_roles,
                estado,
                cargo
            FROM recurso_operativo
            ORDER BY id_codigo_consumidor
        """
        cursor.execute(query)
        usuarios = cursor.fetchall()
        
        # Convertir id_roles a nombres legibles
        for usuario in usuarios:
            usuario['role'] = ROLES.get(str(usuario['id_roles']), 'Desconocido')
        
        return render_template('modulos/administrativo/usuarios.html', 
                              usuarios=usuarios, 
                              current_page=page, 
                              total_pages=total_pages,
                              items_per_page=items_per_page,
                              ROLES=ROLES)  # Pasar el diccionario ROLES al contexto
        
    except mysql.connector.Error as e:
        flash(f'Error de base de datos: {str(e)}', 'error')
        return redirect(url_for('dashboard'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/obtener_usuario/<int:id>', methods=['GET'])
@login_required(role='administrativo')
def obtener_usuario(id):
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener usuario por ID incluyendo los nuevos campos
        cursor.execute("""
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                nombre,
                id_roles,
                estado,
                cargo,
                carpeta,
                cliente,
                ciudad,
                super,
                analista,
                fecha_ingreso,
                fecha_retiro,
                fecha_cumpleanos,
                presentado_dico
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (id,))
        
        usuario = cursor.fetchone()
        
        if not usuario:
            return jsonify({'error': 'Usuario no encontrado'}), 404
        
        # Formatear fechas para input type="date" (YYYY-MM-DD)
        if usuario['fecha_ingreso']:
            if isinstance(usuario['fecha_ingreso'], datetime):
                usuario['fecha_ingreso'] = usuario['fecha_ingreso'].strftime('%Y-%m-%d')
        
        if usuario['fecha_retiro']:
            if isinstance(usuario['fecha_retiro'], datetime):
                usuario['fecha_retiro'] = usuario['fecha_retiro'].strftime('%Y-%m-%d')
        if usuario.get('fecha_cumpleanos'):
            try:
                s = str(usuario['fecha_cumpleanos'])
                usuario['fecha_cumpleanos'] = s.split(' ')[0]
            except Exception:
                usuario['fecha_cumpleanos'] = None
        
        return jsonify(usuario)
        
    except mysql.connector.Error as e:
        return jsonify({'error': str(e)}), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/obtener_opciones_usuario', methods=['GET'])
@login_required(role='administrativo')
def obtener_opciones_usuario():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener valores únicos para carpeta
        cursor.execute("SELECT DISTINCT carpeta FROM recurso_operativo WHERE carpeta IS NOT NULL AND carpeta != '' ORDER BY carpeta")
        carpetas = [row['carpeta'] for row in cursor.fetchall()]
        
        # Obtener valores únicos para cliente
        cursor.execute("SELECT DISTINCT cliente FROM recurso_operativo WHERE cliente IS NOT NULL AND cliente != '' ORDER BY cliente")
        clientes = [row['cliente'] for row in cursor.fetchall()]
        
        # Obtener valores únicos para ciudad
        cursor.execute("SELECT DISTINCT ciudad FROM recurso_operativo WHERE ciudad IS NOT NULL AND ciudad != '' ORDER BY ciudad")
        ciudades = [row['ciudad'] for row in cursor.fetchall()]
        
        # Obtener valores únicos para super
        cursor.execute("SELECT DISTINCT super FROM recurso_operativo WHERE super IS NOT NULL AND super != '' ORDER BY super")
        supers = [row['super'] for row in cursor.fetchall()]
        
        return jsonify({
            'carpetas': carpetas,
            'clientes': clientes,
            'ciudades': ciudades,
            'supers': supers
        })
        
    except mysql.connector.Error as e:
        return jsonify({'error': str(e)}), 500
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/admin/usuarios/export', methods=['GET'])
@login_required_api(role='administrativo')
def api_admin_usuarios_export():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT 
                id_codigo_consumidor,
                recurso_operativo_cedula,
                nombre,
                id_roles,
                estado,
                cargo,
                carpeta,
                super,
                analista,
                fecha_ingreso,
                fecha_retiro
            FROM recurso_operativo
            ORDER BY id_codigo_consumidor
            """
        )
        usuarios = cursor.fetchall()

        for u in usuarios:
            u['role'] = ROLES.get(str(u['id_roles']), 'Desconocido')
            fi = u.get('fecha_ingreso')
            fr = u.get('fecha_retiro')
            if fi and isinstance(fi, datetime):
                u['fecha_ingreso'] = fi.strftime('%Y-%m-%d')
            if fr and isinstance(fr, datetime):
                u['fecha_retiro'] = fr.strftime('%Y-%m-%d')

        return jsonify({'success': True, 'data': usuarios})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/actualizar_usuario', methods=['POST'])
@login_required(role='administrativo')
def actualizar_usuario():
    connection = None
    cursor = None
    try:
        # Obtener datos del formulario
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        recurso_operativo_cedula = request.form.get('recurso_operativo_cedula')
        nombre = request.form.get('nombre')
        id_roles = request.form.get('id_roles')
        estado = request.form.get('estado', 'Activo')
        cargo = request.form.get('cargo', '')
        carpeta = request.form.get('carpeta', '')
        cliente = request.form.get('cliente', '')
        ciudad = request.form.get('ciudad', '')
        super_valor = request.form.get('super', '')
        password = request.form.get('password', '')
        analista = request.form.get('analista', '')
        fecha_ingreso = request.form.get('fecha_ingreso', '')
        fecha_retiro = request.form.get('fecha_retiro', '')
        fecha_cumpleanos = request.form.get('fecha_cumpleanos', '')
        presentado_dico = request.form.get('presentado_dico', '')
        
        # Validar datos requeridos
        if not all([id_codigo_consumidor, recurso_operativo_cedula, nombre, id_roles]):
            return jsonify({'success': False, 'message': 'Por favor complete todos los campos requeridos.'})
        
        # Conectar a la base de datos
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos.'})
        
        cursor = connection.cursor()
        
        # Preparar la consulta base
        query_fields = [
            'recurso_operativo_cedula = %s',
            'nombre = %s',
            'id_roles = %s',
            'estado = %s',
            'cargo = %s',
            'carpeta = %s',
            'cliente = %s',
            'ciudad = %s',
            'super = %s',
            'analista = %s',
            'fecha_ingreso = %s',
            'fecha_retiro = %s',
            'fecha_cumpleanos = %s',
            'presentado_dico = %s'
        ]
        
        values = [
            recurso_operativo_cedula, 
            nombre, 
            id_roles,
            estado,
            cargo,
            carpeta,
            cliente,
            ciudad,
            super_valor,
            analista,
            fecha_ingreso if fecha_ingreso else None,
            fecha_retiro if fecha_retiro else None,
            fecha_cumpleanos if fecha_cumpleanos else None,
            presentado_dico
        ]
        
        # Si se proporciona una nueva contraseña, agregarla a la actualización
        if password and password.strip():
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            query_fields.append('recurso_operativo_password = %s')
            values.append(hashed_password)
        
        # Agregar el ID al final para la cláusula WHERE
        values.append(id_codigo_consumidor)
        
        # Construir la consulta final
        query = f"""
        UPDATE recurso_operativo SET 
            {', '.join(query_fields)}
        WHERE id_codigo_consumidor = %s
        """
        
        cursor.execute(query, values)
        connection.commit()
        
        return jsonify({'success': True, 'message': 'Usuario actualizado exitosamente.'})
        
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error al actualizar usuario: {str(e)}'})
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/eliminar_usuario/<int:id>', methods=['POST'])
@login_required(role='administrativo')
def eliminar_usuario(id):
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})
            
        cursor = connection.cursor()
        
        # Verificar si el usuario existe
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id,))
        if not cursor.fetchone():
            return jsonify({'success': False, 'message': 'Usuario no encontrado'})
        
        # Eliminar el usuario
        cursor.execute("DELETE FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id,))
        connection.commit()
        
        return jsonify({'success': True, 'message': 'Usuario eliminado correctamente'})
        
    except mysql.connector.Error as e:
        if connection:
            connection.rollback()
        return jsonify({'success': False, 'message': f'Error al eliminar usuario: {str(e)}'})
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/estadisticas_inventario')
@login_required(role='administrativo')
def estadisticas_inventario():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('dashboard'))
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener usuarios para el filtro
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre
            FROM recurso_operativo
            WHERE estado = 'Activo'
            ORDER BY nombre
        """)
        usuarios = cursor.fetchall()
        
        # Obtener datos iniciales para los contadores usando las tablas existentes
        # Usaremos asignacion para herramientas y ferretero para materiales
        cursor.execute("""
            SELECT 
                COUNT(*) as total_elementos,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as elementos_asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as elementos_disponibles,
                0 as elementos_mantenimiento
            FROM asignacion
        """)
        contadores_asignacion = cursor.fetchone()
        
        cursor.execute("""
            SELECT 
                COUNT(*) as total_elementos
            FROM ferretero
        """)
        contadores_ferretero = cursor.fetchone()
        
        # Combinar contadores
        contadores = {
            'total_elementos': (contadores_asignacion['total_elementos'] or 0) + (contadores_ferretero['total_elementos'] or 0),
            'elementos_asignados': contadores_asignacion['elementos_asignados'] or 0,
            'elementos_disponibles': contadores_asignacion['elementos_disponibles'] or 0,
            'elementos_mantenimiento': 0  # No hay datos de mantenimiento en las tablas actuales
        }
        
        # Obtener top 10 de herramientas (usando asignacion para herramientas básicas)
        cursor.execute("""
            SELECT 
                'Adaptador Mandril' as descripcion,
                'HD-001' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_adaptador_mandril) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_adaptador_mandril > 0
            UNION ALL
            SELECT 
                'Alicate' as descripcion,
                'HD-002' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_alicate) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_alicate > 0
            UNION ALL
            SELECT 
                'Barra 45cm' as descripcion,
                'HD-003' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_barra_45cm) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_barra_45cm > 0
            ORDER BY frecuencia_uso DESC
            LIMIT 10
        """)
        top_herramientas = cursor.fetchall()
        
        # Obtener top 10 de herramientas especializadas
        cursor.execute("""
            SELECT 
                'Multímetro' as descripcion,
                'HE-001' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_multimetro) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_multimetro > 0
            UNION ALL
            SELECT 
                'Taladro Percutor' as descripcion,
                'HE-002' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_taladro_percutor) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_taladro_percutor > 0
            ORDER BY frecuencia_uso DESC
            LIMIT 10
        """)
        top_dotaciones = cursor.fetchall()
        
        # Obtener top 10 de EPPs (Elementos de Protección Personal)
        cursor.execute("""
            SELECT 
                'Arnés' as descripcion,
                'EPP-001' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_arnes) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_arnes > 0
            UNION ALL
            SELECT 
                'Eslinga' as descripcion,
                'EPP-002' as codigo,
                COUNT(*) as cantidad_total,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                ROUND((SUM(asignacion_eslinga) / COUNT(*)) * 100) as frecuencia_uso
            FROM asignacion 
            WHERE asignacion_eslinga > 0
            ORDER BY frecuencia_uso DESC
            LIMIT 10
        """)
        top_epps = cursor.fetchall()
        
        # Obtener top 10 de ferretero
        cursor.execute("""
            SELECT 
                'Silicona' as descripcion,
                'F-001' as codigo,
                COUNT(*) as cantidad_total,
                SUM(silicona) as asignados,
                0 as disponibles,
                ROUND((SUM(silicona) / COUNT(*)) * 100) as frecuencia_uso
            FROM ferretero 
            WHERE silicona > 0
            UNION ALL
            SELECT 
                'Amarres Negros' as descripcion,
                'F-002' as codigo,
                COUNT(*) as cantidad_total,
                SUM(amarres_negros) as asignados,
                0 as disponibles,
                ROUND((SUM(amarres_negros) / COUNT(*)) * 100) as frecuencia_uso
            FROM ferretero 
            WHERE amarres_negros > 0
            UNION ALL
            SELECT 
                'Amarres Blancos' as descripcion,
                'F-003' as codigo,
                COUNT(*) as cantidad_total,
                SUM(amarres_blancos) as asignados,
                0 as disponibles,
                ROUND((SUM(amarres_blancos) / COUNT(*)) * 100) as frecuencia_uso
            FROM ferretero 
            WHERE amarres_blancos > 0
            UNION ALL
            SELECT 
                'Cinta Aislante' as descripcion,
                'F-004' as codigo,
                COUNT(*) as cantidad_total,
                SUM(cinta_aislante) as asignados,
                0 as disponibles,
                ROUND((SUM(cinta_aislante) / COUNT(*)) * 100) as frecuencia_uso
            FROM ferretero 
            WHERE cinta_aislante > 0
            ORDER BY frecuencia_uso DESC
            LIMIT 10
        """)
        top_ferretero = cursor.fetchall()
        
        # Obtener datos para el gráfico de distribución por categorías
        cursor.execute("""
            SELECT 
                SUM(CASE 
                    WHEN asignacion_adaptador_mandril > 0 OR 
                         asignacion_alicate > 0 OR 
                         asignacion_barra_45cm > 0 OR 
                         asignacion_bisturi_metalico > 0 OR 
                         asignacion_caja_de_herramientas > 0 OR 
                         asignacion_cortafrio > 0 OR 
                         asignacion_destor_de_estrella > 0 OR 
                         asignacion_destor_de_pala > 0 OR 
                         asignacion_destor_tester > 0 OR 
                         asignacion_martillo_de_una > 0 OR 
                         asignacion_pinza_de_punta > 0 
                    THEN 1 ELSE 0 END) as herramientas,
                SUM(CASE 
                    WHEN asignacion_multimetro > 0 OR 
                         asignacion_taladro_percutor > 0 OR 
                         asignacion_ponchadora_rg_6_y_rg_11 > 0 OR 
                         asignacion_ponchadora_rj_45_y_rj11 > 0 OR 
                         asignacion_power_miter > 0 OR 
                         asignacion_bfl_laser > 0 OR 
                         asignacion_cortadora > 0 OR 
                         asignacion_stripper_fibra > 0 
                    THEN 1 ELSE 0 END) as dotaciones,
                SUM(CASE 
                    WHEN asignacion_arnes > 0 OR 
                         asignacion_eslinga > 0 OR 
                         asignacion_casco_tipo_ii > 0 OR 
                         asignacion_arana_casco > 0 OR 
                         asignacion_barbuquejo > 0 OR 
                         asignacion_guantes_vaqueta > 0 OR 
                         asignacion_gafas > 0 OR 
                         asignacion_linea_vida > 0 
                    THEN 1 ELSE 0 END) as epps
            FROM asignacion
        """)
        categorias_asignacion = cursor.fetchone()
        
        cursor.execute("""
            SELECT COUNT(*) as ferretero
            FROM ferretero
        """)
        categorias_ferretero = cursor.fetchone()
        
        # Formatear datos para gráficos
        categorias = {
            'herramientas': categorias_asignacion['herramientas'] or 0,
            'dotaciones': categorias_asignacion['dotaciones'] or 0,
            'epps': categorias_asignacion['epps'] or 0,
            'ferretero': categorias_ferretero['ferretero'] or 0
        }
        
        # Convertir valores a float para evitar problemas con Decimal
        datos_categorias = json.dumps([
            float(categorias['herramientas'] or 0), 
            float(categorias['dotaciones'] or 0), 
            float(categorias['epps'] or 0), 
            float(categorias['ferretero'] or 0)
        ])
        
        # Obtener datos para el gráfico de distribución por estado
        cursor.execute("""
            SELECT 
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                0 as en_mantenimiento,
                0 as de_baja
            FROM asignacion
        """)
        estados = cursor.fetchone()
        
        # Convertir valores a float para evitar problemas con Decimal
        datos_estados = json.dumps([
            float(estados['disponibles'] or 0), 
            float(estados['asignados'] or 0), 
            float(estados['en_mantenimiento'] or 0), 
            float(estados['de_baja'] or 0)
        ])
        
        # Obtener datos para el gráfico de elementos más asignados
        cursor.execute("""
            SELECT 
                'Adaptador Mandril' as descripcion,
                SUM(asignacion_adaptador_mandril) as total_asignaciones
            FROM asignacion 
            WHERE asignacion_adaptador_mandril > 0
            UNION ALL
            SELECT 
                'Alicate' as descripcion,
                SUM(asignacion_alicate) as total_asignaciones
            FROM asignacion 
            WHERE asignacion_alicate > 0
            UNION ALL
            SELECT 
                'Barra 45cm' as descripcion,
                SUM(asignacion_barra_45cm) as total_asignaciones
            FROM asignacion 
            WHERE asignacion_barra_45cm > 0
            UNION ALL
            SELECT 
                'Silicona' as descripcion,
                SUM(silicona) as total_asignaciones
            FROM ferretero 
            WHERE silicona > 0
            UNION ALL
            SELECT 
                'Amarres Negros' as descripcion,
                SUM(amarres_negros) as total_asignaciones
            FROM ferretero 
            WHERE amarres_negros > 0
            UNION ALL
            SELECT 
                'Cinta Aislante' as descripcion,
                SUM(cinta_aislante) as total_asignaciones
            FROM ferretero 
            WHERE cinta_aislante > 0
            ORDER BY total_asignaciones DESC
            LIMIT 6
        """)
        mas_asignados = cursor.fetchall()
        
        
        if mas_asignados:
            labels_mas_asignados = json.dumps([item['descripcion'] for item in mas_asignados])
            datos_mas_asignados = json.dumps([float(item['total_asignaciones'] or 0) for item in mas_asignados])
        else:
            labels_mas_asignados = json.dumps(["Taladro", "Guantes", "Martillo", "Pulidora", "Destornillador", "Llaves"])
            datos_mas_asignados = json.dumps([120, 98, 85, 74, 65, 60])
        
        # Obtener datos para el gráfico de tendencia de asignaciones
        cursor.execute("""
            SELECT 
                DATE_FORMAT(asignacion_fecha, '%b') as mes,
                MIN(asignacion_fecha) as fecha_referencia,
                COUNT(*) as total
            FROM asignacion
            WHERE asignacion_fecha >= DATE_SUB(NOW(), INTERVAL 6 MONTH)
            GROUP BY DATE_FORMAT(asignacion_fecha, '%Y-%m')
            ORDER BY MIN(asignacion_fecha)
        """)
        tendencia_asignacion = cursor.fetchall()
        
        cursor.execute("""
            SELECT 
                DATE_FORMAT(fecha_asignacion, '%b') as mes,
                MIN(fecha_asignacion) as fecha_referencia,
                COUNT(*) as total
            FROM ferretero
            WHERE fecha_asignacion >= DATE_SUB(NOW(), INTERVAL 6 MONTH)
            GROUP BY DATE_FORMAT(fecha_asignacion, '%Y-%m')
            ORDER BY MIN(fecha_asignacion)
        """)
        tendencia_ferretero = cursor.fetchall()
        
        # Combinar tendencias
        tendencia_meses = {}
        
        # Agregar datos de asignación
        for item in tendencia_asignacion:
            mes = item['mes']
            if mes not in tendencia_meses:
                tendencia_meses[mes] = 0
            tendencia_meses[mes] += item['total']
        
        # Agregar datos de ferretero
        for item in tendencia_ferretero:
            mes = item['mes']
            if mes not in tendencia_meses:
                tendencia_meses[mes] = 0
            tendencia_meses[mes] += item['total']
        
        # Convertir a lista ordenada por mes
        tendencia = [{'mes': k, 'total': v} for k, v in tendencia_meses.items()]
        tendencia.sort(key=lambda x: {'Ene': 1, 'Feb': 2, 'Mar': 3, 'Abr': 4, 'May': 5, 'Jun': 6, 
                                  'Jul': 7, 'Ago': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dic': 12}.get(x['mes'], 0))
        
        if tendencia:
            labels_tendencia = json.dumps([item['mes'] for item in tendencia])
            datos_tendencia = json.dumps([float(item['total'] or 0) for item in tendencia])
        else:
            labels_tendencia = json.dumps(["Ene", "Feb", "Mar", "Abr", "May", "Jun"])
            datos_tendencia = json.dumps([65, 72, 78, 90, 85, 95])
        
        return render_template('modulos/administrativo/estadisticas_inventario.html',
                               usuarios=usuarios,
                               total_elementos=contadores['total_elementos'],
                               elementos_disponibles=contadores['elementos_disponibles'],
                               elementos_asignados=contadores['elementos_asignados'],
                               elementos_mantenimiento=contadores['elementos_mantenimiento'],
                               top_herramientas=top_herramientas,
                               top_dotaciones=top_dotaciones,
                               top_epps=top_epps,
                               top_ferretero=top_ferretero,
                               datos_categorias=datos_categorias,
                               datos_estados=datos_estados,
                               labels_mas_asignados=labels_mas_asignados,
                               datos_mas_asignados=datos_mas_asignados,
                               labels_tendencia=labels_tendencia,
                               datos_tendencia=datos_tendencia)
        
    except mysql.connector.Error as e:
        flash(f'Error al cargar datos: {str(e)}', 'danger')
        return redirect(url_for('dashboard'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/estadisticas/inventario', methods=['GET'])
@login_required(role='administrativo')
def api_estadisticas_inventario():
    from decimal import Decimal
    
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            })
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener parámetros de filtro
        dias = request.args.get('dias', default='30', type=str)
        categoria = request.args.get('categoria', default='todos', type=str)
        estado = request.args.get('estado', default='todos', type=str)
        usuario = request.args.get('usuario', default='todos', type=str)
        
        # Construir condiciones de filtro
        condicion_fecha = "1=1"
        if dias != 'todos':
            condicion_fecha = f"asignacion_fecha >= DATE_SUB(NOW(), INTERVAL {dias} DAY)"
            
        condicion_categoria = "1=1"
        if categoria != 'todos':
            if categoria == 'herramientas':
                condicion_categoria = """(
                    asignacion_adaptador_mandril > 0 OR 
                    asignacion_alicate > 0 OR 
                    asignacion_barra_45cm > 0 OR 
                    asignacion_bisturi_metalico > 0 OR 
                    asignacion_caja_de_herramientas > 0 OR 
                    asignacion_cortafrio > 0 OR 
                    asignacion_destor_de_estrella > 0 OR 
                    asignacion_destor_de_pala > 0 OR 
                    asignacion_destor_tester > 0 OR 
                    asignacion_martillo_de_una > 0 OR 
                    asignacion_pinza_de_punta > 0
                )"""
            elif categoria == 'dotaciones':
                condicion_categoria = """(
                    asignacion_multimetro > 0 OR 
                    asignacion_taladro_percutor > 0 OR 
                    asignacion_ponchadora_rg_6_y_rg_11 > 0 OR 
                    asignacion_ponchadora_rj_45_y_rj11 > 0 OR 
                    asignacion_power_miter > 0 OR 
                    asignacion_bfl_laser > 0 OR 
                    asignacion_cortadora > 0 OR 
                    asignacion_stripper_fibra > 0
                )"""
            elif categoria == 'epps':
                condicion_categoria = """(
                    asignacion_arnes > 0 OR 
                    asignacion_eslinga > 0 OR 
                    asignacion_casco_tipo_ii > 0 OR 
                    asignacion_arana_casco > 0 OR 
                    asignacion_barbuquejo > 0 OR 
                    asignacion_guantes_vaqueta > 0 OR 
                    asignacion_gafas > 0 OR 
                    asignacion_linea_vida > 0
                )"""
            
        condicion_estado = "1=1"
        if estado != 'todos':
            condicion_estado = f"asignacion_estado = '{estado}'"
            
        condicion_usuario = "1=1"
        if usuario != 'todos':
            condicion_usuario = f"recurso_id = '{usuario}'"
        
        # Obtener datos para los contadores 
        cursor.execute(f"""
            SELECT 
                COUNT(*) as total_elementos,
                SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as elementos_asignados,
                SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as elementos_disponibles,
                0 as elementos_mantenimiento
            FROM asignacion
            WHERE {condicion_fecha} AND {condicion_categoria} AND {condicion_estado} AND {condicion_usuario}
        """)
        contadores_asignacion = cursor.fetchone()
        
        # Si la categoría no es ferretero, incluir contadores de ferretero
        contadores_ferretero = {'total_elementos': 0}
        if categoria == 'todos' or categoria == 'ferretero':
            condicion_fecha_ferretero = "1=1"
            if dias != 'todos':
                condicion_fecha_ferretero = f"fecha_asignacion >= DATE_SUB(NOW(), INTERVAL {dias} DAY)"
                
            condicion_usuario_ferretero = "1=1"
            if usuario != 'todos':
                condicion_usuario_ferretero = f"id_tecnico = '{usuario}'"
                
            cursor.execute(f"""
                SELECT 
                    COUNT(*) as total_elementos
                FROM ferretero
                WHERE {condicion_fecha_ferretero} AND {condicion_usuario_ferretero}
            """)
            contadores_ferretero = cursor.fetchone()
        
        # Combinar contadores
        contadores = {
            'total_elementos': (contadores_asignacion['total_elementos'] or 0) + (contadores_ferretero['total_elementos'] or 0),
            'elementos_asignados': contadores_asignacion['elementos_asignados'] or 0,
            'elementos_disponibles': contadores_asignacion['elementos_disponibles'] or 0,
            'elementos_mantenimiento': 0
        }
        
        # Obtener Top 10 según la categoría seleccionada
        resultados = {}
        
        if categoria == 'todos' or categoria == 'herramientas':
            cursor.execute(f"""
                SELECT 
                    'Adaptador Mandril' as descripcion,
                    'HD-001' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_adaptador_mandril) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_adaptador_mandril > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Alicate' as descripcion,
                    'HD-002' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_alicate) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_alicate > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Barra 45cm' as descripcion,
                    'HD-003' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_barra_45cm) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_barra_45cm > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                ORDER BY frecuencia_uso DESC
                LIMIT 10
            """)
            top_herramientas = cursor.fetchall()
            # Formatear los valores para JSON
            for item in top_herramientas:
                for k, v in item.items():
                    if v is None:
                        item[k] = 0
                    elif isinstance(v, Decimal):
                        item[k] = float(v)
            resultados['top_herramientas'] = top_herramientas
        
        if categoria == 'todos' or categoria == 'dotaciones':
            cursor.execute(f"""
                SELECT 
                    'Multímetro' as descripcion,
                    'HE-001' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_multimetro) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_multimetro > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Taladro Percutor' as descripcion,
                    'HE-002' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_taladro_percutor) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_taladro_percutor > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                ORDER BY frecuencia_uso DESC
                LIMIT 10
            """)
            top_dotaciones = cursor.fetchall()
            # Formatear los valores para JSON
            for item in top_dotaciones:
                for k, v in item.items():
                    if v is None:
                        item[k] = 0
                    elif isinstance(v, Decimal):
                        item[k] = float(v)
            resultados['top_dotaciones'] = top_dotaciones
        
        if categoria == 'todos' or categoria == 'epps':
            cursor.execute(f"""
                SELECT 
                    'Arnés' as descripcion,
                    'EPP-001' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_arnes) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_arnes > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Eslinga' as descripcion,
                    'EPP-002' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(CASE WHEN asignacion_estado = '1' THEN 1 ELSE 0 END) as asignados,
                    SUM(CASE WHEN asignacion_estado = '0' THEN 1 ELSE 0 END) as disponibles,
                    ROUND((SUM(asignacion_eslinga) / COUNT(*)) * 100) as frecuencia_uso
                FROM asignacion 
                WHERE asignacion_eslinga > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                ORDER BY frecuencia_uso DESC
                LIMIT 10
            """)
            top_epps = cursor.fetchall()
            # Formatear los valores para JSON
            for item in top_epps:
                for k, v in item.items():
                    if v is None:
                        item[k] = 0
                    elif isinstance(v, Decimal):
                        item[k] = float(v)
            resultados['top_epps'] = top_epps
        
        if categoria == 'todos' or categoria == 'ferretero':
            cursor.execute(f"""
                SELECT 
                    'Silicona' as descripcion,
                    'F-001' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(silicona) as asignados,
                    0 as disponibles,
                    ROUND((SUM(silicona) / COUNT(*)) * 100) as frecuencia_uso
                FROM ferretero 
                WHERE silicona > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Amarres Negros' as descripcion,
                    'F-002' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(amarres_negros) as asignados,
                    0 as disponibles,
                    ROUND((SUM(amarres_negros) / COUNT(*)) * 100) as frecuencia_uso
                FROM ferretero 
                WHERE amarres_negros > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Amarres Blancos' as descripcion,
                    'F-003' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(amarres_blancos) as asignados,
                    0 as disponibles,
                    ROUND((SUM(amarres_blancos) / COUNT(*)) * 100) as frecuencia_uso
                FROM ferretero 
                WHERE amarres_blancos > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                UNION ALL
                SELECT 
                    'Cinta Aislante' as descripcion,
                    'F-004' as codigo,
                    COUNT(*) as cantidad_total,
                    SUM(cinta_aislante) as asignados,
                    0 as disponibles,
                    ROUND((SUM(cinta_aislante) / COUNT(*)) * 100) as frecuencia_uso
                FROM ferretero 
                WHERE cinta_aislante > 0 AND {condicion_fecha} AND {condicion_estado} AND {condicion_usuario}
                ORDER BY frecuencia_uso DESC
                LIMIT 10
            """)
            top_ferretero = cursor.fetchall()
            # Formatear los valores para JSON
            for item in top_ferretero:
                for k, v in item.items():
                    if v is None:
                        item[k] = 0
                    elif isinstance(v, Decimal):
                        item[k] = float(v)
            resultados['top_ferretero'] = top_ferretero
        
        return jsonify({
            'total_elementos': contadores['total_elementos'],
            'elementos_asignados': contadores['elementos_asignados'],
            'elementos_disponibles': contadores['elementos_disponibles'],
            'elementos_mantenimiento': contadores['elementos_mantenimiento'],
            'top_herramientas': resultados.get('top_herramientas', []),
            'top_dotaciones': resultados.get('top_dotaciones', []),
            'top_epps': resultados.get('top_epps', []),
            'top_ferretero': resultados.get('top_ferretero', []),
            'herramientas': categorias['herramientas'],
            'dotaciones': categorias['dotaciones'],
            'epps': categorias['epps'],
            'ferretero': categorias['ferretero'],
            'estadisticas': estadisticas,
            'tendencia': datos_tendencia,
            'mas_asignados': {
                'labels': labels_mas_asignados,
                'datos': datos_mas_asignados
            },
            'tendencia_asignacion': tendencia_asignacion,
            'tendencia_ferretero': tendencia_ferretero
        })
        
    except mysql.connector.Error as e:
        flash(f'Error al cargar datos: {str(e)}', 'danger')
        return redirect(url_for('dashboard'))
    
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/asistencia', methods=['GET'])
@login_required(role='administrativo')
def ver_asistencia():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('dashboard'))
            
        cursor = connection.cursor(dictionary=True)
        
        # Crear tablas si no existen
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS tipificacion_asistencia (
                id_tipificacion INT AUTO_INCREMENT PRIMARY KEY,
                codigo_tipificacion VARCHAR(50) NOT NULL,
                nombre_tipificacion VARCHAR(200),
                estado CHAR(1) DEFAULT '1',
                fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS asistencia (
                id_asistencia INT AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(20),
                tecnico VARCHAR(100),
                carpeta_dia VARCHAR(50),
                carpeta VARCHAR(50),
                super VARCHAR(100),
                fecha_asistencia TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                id_codigo_consumidor INT
            )
        """)
        connection.commit()
        
        # Insertar tipificaciones por defecto si no existen
        #tipificaciones_default = [
        #    ('VACACIONES', 'Vacaciones'),
        #    ('PERMISO', 'Permiso'),
        #    ('INCAPACIDAD', 'Incapacidad'),
        #    ('CAPACITACION', 'Capacitación'),
        #    ('AUSENCIA', 'Ausencia'),
        #    ('PRESENTE', 'Presente')
        #]
        
        #for codigo, descripcion in tipificaciones_default:
        #    cursor.execute("""
        #        INSERT IGNORE INTO tipificacion_asistencia 
        #        (codigo_tipificacion, nombre_tipificacion) 
        #        VALUES (%s, %s)
        #    """, (codigo, descripcion))
        #connection.commit()
        
        # Obtener lista de técnicos
        cursor.execute("""
           SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre, carpeta
            FROM capired.recurso_operativo
            WHERE estado = 'Activo'
            ORDER BY nombre
        """)
        tecnicos = cursor.fetchall()
        
        # Obtener lista de tipificaciones para carpeta_dia
        cursor.execute("""
            SELECT codigo_tipificacion, nombre_tipificacion
            FROM tipificacion_asistencia
            WHERE estado = '1'
            ORDER BY codigo_tipificacion
        """)
        carpetas_dia = cursor.fetchall()
        
        # Obtener lista de supervisores
        cursor.execute("""
            SELECT DISTINCT super
            FROM recurso_operativo 
            WHERE super IS NOT NULL AND super != ''
            ORDER BY super
        """)
        supervisores = cursor.fetchall()
        
        return render_template('modulos/administrativo/asistencia.html',
                           tecnicos=tecnicos,
                           carpetas_dia=carpetas_dia,
                           supervisores=supervisores)
                           
    except mysql.connector.Error as e:
        flash(f'Error al cargar datos: {str(e)}', 'danger')
        return redirect(url_for('dashboard'))
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/guardar', methods=['POST'])
@login_required(role='administrativo')
def guardar_asistencias():
    try:
        data = request.get_json()
        if not data or 'asistencias' not in data:
            return jsonify({'success': False, 'message': 'No se recibieron datos de asistencia'})
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})
            
        cursor = connection.cursor()
        
        # Primero, crear la tabla si no existe con AUTO_INCREMENT
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS asistencia (
                id_asistencia INT AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(20),
                tecnico VARCHAR(100),
                carpeta_dia VARCHAR(50),
                carpeta VARCHAR(50),
                super VARCHAR(100),
                fecha_asistencia TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                id_codigo_consumidor INT
            )
        """)
        connection.commit()
        
        # Insertar cada asistencia
        for asistencia in data['asistencias']:
            cursor.execute("""
                INSERT INTO asistencia (
                    cedula, tecnico, carpeta_dia, carpeta, super, 
                    id_codigo_consumidor
                ) VALUES (%s, %s, %s, %s, %s, %s)
            """, (
                asistencia['cedula'],
                asistencia['tecnico'],
                asistencia['carpeta_dia'],
                asistencia['carpeta'],
                asistencia['super'],
                asistencia['id_codigo_consumidor'],
                
            ))
        
        connection.commit()
        return jsonify({'success': True, 'message': 'Asistencias guardadas correctamente'})
        
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error al guardar asistencias: {str(e)}'})
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/operativo/asistencia/guardar', methods=['POST'])
@login_required(role='operativo')
def guardar_asistencias_operativo():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True, buffered=True)
        
        # Obtener el nombre del usuario actual (será usado como supervisor en los registros)
        nombre_usuario_actual = session.get('user_name', '')
        if not nombre_usuario_actual:
            return jsonify({'success': False, 'message': 'No se encontró información del usuario'}), 400
        
        # DEBUG: Información del usuario y supervisor
        usuario_actual = session.get('user_cedula', '')
        print(f"DEBUG - Usuario actual: {usuario_actual}")
        print(f"DEBUG - ID código consumidor: {session['id_codigo_consumidor']}")
        print(f"DEBUG - Nombre usuario actual (supervisor): {nombre_usuario_actual}")
        
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        cursor.execute(
            """
            SELECT id_codigo_consumidor, carpeta, carpeta_dia
            FROM asistencia 
            WHERE super = %s AND DATE(fecha_asistencia) = %s
            """,
            (nombre_usuario_actual, fecha_hoy)
        )
        existentes_hoy_rows = cursor.fetchall()
        existentes_hoy = {}
        for r in existentes_hoy_rows:
            existentes_hoy[r['id_codigo_consumidor']] = {
                'carpeta': r.get('carpeta'),
                'carpeta_dia': r.get('carpeta_dia')
            }
        
        data = request.get_json()
        asistencias = data.get('asistencias', [])
        
        # Validar que se haya seleccionado al menos un técnico
        if not asistencias:
            return jsonify({'success': False, 'message': 'Debe seleccionar al menos un técnico'}), 400
        
        # Insertar cada técnico
        print(f"DEBUG - Iniciando inserción de {len(asistencias)} técnicos")
        print(f"DEBUG - Datos recibidos: {asistencias}")
        
        registros_insertados = 0
        omitidos_existentes = 0
        omitidos_rrhh = 0
        for i, asistencia in enumerate(asistencias):
            print(f"DEBUG - Insertando técnico {i+1}: {asistencia}")
            try:
                idc = asistencia.get('id_codigo_consumidor', 0)
                ex = existentes_hoy.get(idc)
                if ex:
                    if str(ex.get('carpeta') or '').upper() == 'RRHH':
                        omitidos_rrhh += 1
                    else:
                        omitidos_existentes += 1
                    continue
                # VALIDACIÓN DUAL: Verificar AMBAS condiciones (carpeta Y cargo)
                # Solo si AMBAS validaciones pasan, aplicar valores de presupuesto
                cedula_tecnico = asistencia.get('cedula', '')
                valor_presupuesto = 0
                valor_eventos = 0
                presupuesto_encontrado = False
                carpeta_valida = False
                cargo_valido = False
                
                if cedula_tecnico:
                    try:
                        # 1. Obtener carpeta y cargo del técnico desde recurso_operativo
                        cursor.execute("""
                            SELECT carpeta, cargo 
                            FROM recurso_operativo 
                            WHERE recurso_operativo_cedula = %s 
                            LIMIT 1
                        """, (cedula_tecnico,))
                        tecnico_row = cursor.fetchone()
                        
                        if tecnico_row and tecnico_row['carpeta'] and tecnico_row['cargo']:
                            carpeta_tecnico = tecnico_row['carpeta']
                            cargo_tecnico = tecnico_row['cargo']
                            print(f"DEBUG - Técnico {cedula_tecnico}: carpeta='{carpeta_tecnico}', cargo='{cargo_tecnico}'")

                            # Normalización de carpetas para coincidencias de presupuesto
                            def normalizar_carpeta(nombre):
                                if not nombre:
                                    return ''
                                n = str(nombre).strip()
                                # Unificar mayúsculas/minúsculas sin perder formato de la BD
                                n_upper = n.upper()
                                # Remover sufijo BACK si existe
                                if n_upper.endswith(' BACK'):
                                    n_upper = n_upper.replace(' BACK', '')
                                # Sinónimos y correcciones comunes
                                mapa = {
                                    'BROWFIELD': 'BROWNFIELD',
                                }
                                # Carpetas válidas esperadas (canónicas)
                                validas = [
                                    'POSTVENTA', 'POSTVENTA FTTH',
                                    'FTTH INSTALACIONES', 'INSTALACIONES DOBLES',
                                    'MANTENIMIENTO FTTH', 'ARREGLOS HFC',
                                    'BROWNFIELD'
                                ]
                                # Aplicar corrección de sinónimos
                                n_upper = mapa.get(n_upper, n_upper)
                                # Si tras quitar BACK coincide con alguna válida, devolver esa forma
                                for v in validas:
                                    if n_upper == v:
                                        return v
                                # Si no coincide exactamente, intentar igualar por palabras claves
                                if 'POSTVENTA FTTH' in n_upper:
                                    return 'POSTVENTA FTTH'
                                if 'POSTVENTA' == n_upper or n_upper.startswith('POSTVENTA'):
                                    return 'POSTVENTA'
                                if 'FTTH INSTALACIONES' in n_upper:
                                    return 'FTTH INSTALACIONES'
                                if 'INSTALACIONES DOBLES' in n_upper:
                                    return 'INSTALACIONES DOBLES'
                                if 'MANTENIMIENTO FTTH' in n_upper:
                                    return 'MANTENIMIENTO FTTH'
                                if 'ARREGLOS HFC' in n_upper:
                                    return 'ARREGLOS HFC'
                                if 'BROWNFIELD' in n_upper or 'BROWFIELD' in n_upper:
                                    return 'BROWNFIELD'
                                # Por defecto devolver nombre original limpio (mayúsculas)
                                return n_upper

                            carpeta_normalizada = normalizar_carpeta(carpeta_tecnico)
                            if carpeta_normalizada != carpeta_tecnico:
                                print(f"DEBUG - Normalización de carpeta: '{carpeta_tecnico}' -> '{carpeta_normalizada}'")
                            
                            cd_val = asistencia.get('carpeta_dia', '')
                            carpeta_presupuesto = carpeta_normalizada
                            if cd_val:
                                try:
                                    cursor.execute("""
                                        SELECT nombre_tipificacion 
                                        FROM tipificacion_asistencia 
                                        WHERE codigo_tipificacion = %s 
                                        LIMIT 1
                                    """, (cd_val,))
                                    rtip = cursor.fetchone()
                                    if rtip and rtip.get('nombre_tipificacion'):
                                        carpeta_presupuesto = str(rtip.get('nombre_tipificacion')).strip().upper()
                                except Exception:
                                    pass
                            
                            # VALIDACIÓN DUAL: Verificar carpeta Y cargo en presupuesto_carpeta
                            cursor.execute("""
                                SELECT presupuesto_diario, presupuesto_eventos 
                                FROM presupuesto_carpeta 
                                WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s
                                LIMIT 1
                            """, (carpeta_presupuesto, cargo_tecnico))
                            presupuesto_row = cursor.fetchone()
                            
                            if presupuesto_row:
                                print(f"DEBUG - ✅ COMBINACIÓN VÁLIDA: carpeta='{carpeta_tecnico}' + cargo='{cargo_tecnico}' encontrada en presupuesto_carpeta")
                                
                                # Aplicar valores de presupuesto_carpeta
                                # presupuesto_diario -> valor
                                if 'presupuesto_diario' in presupuesto_row and presupuesto_row['presupuesto_diario'] is not None:
                                    try:
                                        valor_presupuesto = int(float(presupuesto_row['presupuesto_diario']))
                                        presupuesto_encontrado = True
                                    except Exception:
                                        valor_presupuesto = 0
                                
                                # presupuesto_eventos -> eventos
                                if 'presupuesto_eventos' in presupuesto_row and presupuesto_row['presupuesto_eventos'] is not None:
                                    try:
                                        valor_eventos = int(float(presupuesto_row['presupuesto_eventos']))
                                        presupuesto_encontrado = True
                                    except Exception:
                                        valor_eventos = 0
                                
                                print(f"DEBUG - Valores aplicados: valor={valor_presupuesto}, eventos={valor_eventos}")
                            else:
                                print(f"DEBUG - ❌ COMBINACIÓN INVÁLIDA: carpeta='{carpeta_tecnico}' + cargo='{cargo_tecnico}' NO encontrada en presupuesto_carpeta")
                                if carpeta_presupuesto == 'DX':
                                    try:
                                        cursor.execute("""
                                            SELECT presupuesto_diario, presupuesto_eventos 
                                            FROM presupuesto_carpeta 
                                            WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s
                                            LIMIT 1
                                        """, ('ARREGLOS HFC', cargo_tecnico))
                                        presupuesto_row_alt = cursor.fetchone()
                                        if not presupuesto_row_alt:
                                            cursor.execute("""
                                                SELECT presupuesto_diario, presupuesto_eventos 
                                                FROM presupuesto_carpeta 
                                                WHERE presupuesto_carpeta = %s AND presupuesto_cargo = %s
                                                LIMIT 1
                                            """, ('MANTENIMIENTO FTTH', cargo_tecnico))
                                            presupuesto_row_alt = cursor.fetchone()
                                        if presupuesto_row_alt:
                                            if 'presupuesto_diario' in presupuesto_row_alt and presupuesto_row_alt['presupuesto_diario'] is not None:
                                                try:
                                                    valor_presupuesto = int(float(presupuesto_row_alt['presupuesto_diario']))
                                                    presupuesto_encontrado = True
                                                except Exception:
                                                    valor_presupuesto = 0
                                            if 'presupuesto_eventos' in presupuesto_row_alt and presupuesto_row_alt['presupuesto_eventos'] is not None:
                                                try:
                                                    valor_eventos = int(float(presupuesto_row_alt['presupuesto_eventos']))
                                                    presupuesto_encontrado = True
                                                except Exception:
                                                    valor_eventos = 0
                                            print(f"DEBUG - Fallback DX aplicado: valor={valor_presupuesto}, eventos={valor_eventos}")
                                    except Exception:
                                        pass
                                if not presupuesto_encontrado:
                                    print(f"DEBUG - Aplicando valores en 0")
                                    valor_presupuesto = 0
                                    valor_eventos = 0
                                    presupuesto_encontrado = False
                        else:
                            print(f"DEBUG - No se encontró carpeta o cargo para técnico con cédula '{cedula_tecnico}' en recurso_operativo")
                    except Exception as e_presupuesto:
                        print(f"DEBUG - Error obteniendo presupuesto para técnico '{cedula_tecnico}': {str(e_presupuesto)}")
                else:
                    print(f"DEBUG - No se proporcionó cédula del técnico")
                
                # Log final del resultado
                if not presupuesto_encontrado:
                    print(f"DEBUG - No se encontró presupuesto válido para técnico '{cedula_tecnico}'. Usando valores por defecto: valor=0, eventos=0")

                cursor.execute("""
                    INSERT INTO asistencia (cedula, tecnico, carpeta_dia, carpeta, super, fecha_asistencia, id_codigo_consumidor, valor, eventos)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    asistencia.get('cedula', ''),
                    asistencia.get('tecnico', ''),
                    asistencia.get('carpeta_dia', ''),
                    carpeta_normalizada,
                    asistencia.get('super', nombre_usuario_actual),
                    asistencia.get('fecha_asistencia', datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
                    asistencia.get('id_codigo_consumidor', 0),
                    valor_presupuesto,
                    valor_eventos
                ))
                registros_insertados += 1
                existentes_hoy[idc] = {'carpeta': carpeta_normalizada, 'carpeta_dia': asistencia.get('carpeta_dia', '')}
                print(f"DEBUG - Técnico {i+1} insertado exitosamente")
            except Exception as e:
                print(f"DEBUG - Error insertando técnico {i+1}: {str(e)}")
        
        print(f"DEBUG - Total registros insertados: {registros_insertados}")
        print(f"DEBUG - Omitidos existentes: {omitidos_existentes}")
        print(f"DEBUG - Omitidos RRHH: {omitidos_rrhh}")
        connection.commit()
        print(f"DEBUG - Commit realizado exitosamente")
        return jsonify({'success': True, 'message': f'Se registraron {registros_insertados} asistencias. Omitidos existentes: {omitidos_existentes}. Omitidos RRHH: {omitidos_rrhh}.'})
        
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error al guardar asistencias: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Ruta para mostrar la página de detalle de preoperacionales por técnicos
@app.route('/operativo/detalle_preoperacionales_tecnicos')
@login_required(role='operativo')
def detalle_preoperacionales_tecnicos():
    try:
        # Verificar conexión a la base de datos
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información del usuario actual
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        
        # Verificar si tiene asistencia registrada para hoy (solo para información)
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE super = %s AND DATE(fecha_asistencia) = %s
        """, (nombre_usuario_actual, fecha_hoy))
        
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False
        
        cursor.close()
        connection.close()
        
        # Comentado: Validación de asistencia eliminada para permitir acceso sin registro de asistencia
        # if not tiene_asistencia:
        #     flash('Debe registrar asistencia antes de acceder a esta funcionalidad', 'warning')
        #     return redirect(url_for('dashboard_operativo'))
        
        return render_template('modulos/operativo/detalle_preoperacionales_tecnicos.html',
                             user_name=session.get('user_name', ''),
                             user_role=session.get('user_role', ''),
                             tiene_asistencia=tiene_asistencia)
        
    except Exception as e:
        print(f"Error en detalle_preoperacionales_tecnicos: {str(e)}")
        flash('Error al cargar la página', 'error')
        return redirect(url_for('dashboard_operativo'))

# NUEVO: Reportes Indicadores (Operativo)
@app.route('/operativo/indicadores')
@login_required(role='operativo')
def indicadores_operativo():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
        
        cursor = connection.cursor(dictionary=True)
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        
        # Verificar asistencia por cédula/ID de usuario para evitar dependencia del nombre
        id_codigo = session.get('id_codigo_consumidor', 0)
        cedula_usuario = session.get('user_cedula', '')
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE DATE(fecha_asistencia) = %s
              AND (id_codigo_consumidor = %s OR cedula = %s)
        """, (fecha_hoy, id_codigo, cedula_usuario))
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False

        # Fallback: comparación normalizada sin acentos y sin sensibilidad a mayúsculas
        if not tiene_asistencia:
            cursor.execute("""
                SELECT super
                FROM asistencia
                WHERE DATE(fecha_asistencia) = %s
            """, (fecha_hoy,))
            filas = cursor.fetchall()
            import unicodedata
            def _norm(s):
                return ''.join(c for c in unicodedata.normalize('NFD', s or '') if unicodedata.category(c) != 'Mn').lower().strip()
            tiene_asistencia = any(_norm(f['super']) == _norm(nombre_usuario_actual) for f in filas)
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/operativo/indicadores.html',
                               user_name=session.get('user_name', ''),
                               user_role=session.get('user_role', ''),
                               tiene_asistencia=tiene_asistencia)
    except Exception as e:
        print(f"Error en indicadores_operativo: {str(e)}")
        flash('Error al cargar la página de indicadores', 'error')
        return redirect(url_for('dashboard_operativo'))

# NUEVO: Submódulos de Indicadores (Próximamente)
@app.route('/operativo/indicadores/logistica')
@app.route('/operativo/indicadores/sst')
@app.route('/operativo/indicadores/calidad')
@login_required(role='operativo')
def indicadores_proximamente():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
        
        cursor = connection.cursor(dictionary=True)
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE super = %s AND DATE(fecha_asistencia) = %s
        """, (nombre_usuario_actual, fecha_hoy))
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False
        
        # Determinar submódulo desde la ruta
        modulo = request.path.split('/')[-1]
        if modulo not in ['logistica', 'sst', 'calidad']:
            modulo = 'logistica'
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/operativo/indicadores_proximamente.html',
                               modulo=modulo,
                               user_name=session.get('user_name', ''),
                               user_role=session.get('user_role', ''),
                               tiene_asistencia=tiene_asistencia)
    except Exception as e:
        print(f"Error en indicadores_proximamente: {str(e)}")
        flash('Error al cargar el submódulo de indicadores', 'error')
        return redirect(url_for('indicadores_operativo'))

# NUEVO: Indicadores de Operaciones (vista con opciones)
@app.route('/operativo/indicadores/operaciones')
@login_required(role='operativo')
def indicadores_operaciones():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
        cursor = connection.cursor(dictionary=True)
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        # Verificar asistencia por cédula/ID de usuario
        id_codigo = session.get('id_codigo_consumidor', 0)
        cedula_usuario = session.get('user_cedula', '')
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE DATE(fecha_asistencia) = %s
              AND (id_codigo_consumidor = %s OR cedula = %s)
        """, (fecha_hoy, id_codigo, cedula_usuario))
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False

        # Fallback: comparación normalizada sin acentos y sin sensibilidad a mayúsculas
        if not tiene_asistencia:
            cursor.execute("""
                SELECT super
                FROM asistencia
                WHERE DATE(fecha_asistencia) = %s
            """, (fecha_hoy,))
            filas = cursor.fetchall()
            import unicodedata
            def _norm(s):
                return ''.join(c for c in unicodedata.normalize('NFD', s or '') if unicodedata.category(c) != 'Mn').lower().strip()
            tiene_asistencia = any(_norm(f['super']) == _norm(nombre_usuario_actual) for f in filas)

        cursor.close()
        connection.close()
        return render_template('modulos/operativo/indicadores_operaciones.html',
                               user_name=session.get('user_name', ''),
                               user_role=session.get('user_role', ''),
                               tiene_asistencia=tiene_asistencia)
    except Exception as e:
        print(f"Error en indicadores_operaciones: {str(e)}")
        flash('Error al cargar Indicadores de Operaciones', 'error')
        return redirect(url_for('indicadores_operativo'))

# NUEVO: Indicador de Inicio de Operacion (activo)
@app.route('/operativo/indicadores/operaciones/inicio-operacion')
@login_required(role='operativo')
def indicadores_operaciones_inicio():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
        cursor = connection.cursor(dictionary=True)
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        # Verificar asistencia por cédula/ID de usuario
        id_codigo = session.get('id_codigo_consumidor', 0)
        cedula_usuario = session.get('user_cedula', '')
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE DATE(fecha_asistencia) = %s
              AND (id_codigo_consumidor = %s OR cedula = %s)
        """, (fecha_hoy, id_codigo, cedula_usuario))
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False

        # Fallback: comparación normalizada sin acentos y sin sensibilidad a mayúsculas
        if not tiene_asistencia:
            cursor.execute("""
                SELECT super
                FROM asistencia
                WHERE DATE(fecha_asistencia) = %s
            """, (fecha_hoy,))
            filas = cursor.fetchall()
            import unicodedata
            def _norm(s):
                return ''.join(c for c in unicodedata.normalize('NFD', s or '') if unicodedata.category(c) != 'Mn').lower().strip()
            tiene_asistencia = any(_norm(f['super']) == _norm(nombre_usuario_actual) for f in filas)

        cursor.close()
        connection.close()
        return render_template('modulos/operativo/indicadores_operaciones_inicio.html',
                               user_name=session.get('user_name', ''),
                               user_role=session.get('user_role', ''),
                               tiene_asistencia=tiene_asistencia)
    except Exception as e:
        print(f"Error en indicadores_operaciones_inicio: {str(e)}")
        flash('Error al cargar Indicador de Inicio de Operación', 'error')
        return redirect(url_for('indicadores_operaciones'))

# API para obtener información del usuario actual
@app.route('/api/current_user', methods=['GET'])
@login_required_api(role='operativo')
def api_current_user():
    try:
        return jsonify({
            'success': True,
            'username': session.get('user_name', ''),
            'nombre': session.get('user_name', ''),
            'role': session.get('user_role', ''),
            'id_codigo_consumidor': session.get('id_codigo_consumidor', 0),
            'cedula': session.get('user_cedula', '')
        })
    except Exception as e:
        print(f"Error en api_current_user: {str(e)}")
        return jsonify({'success': False, 'message': 'Error al obtener información del usuario'}), 500

# NUEVO: Submódulo Equipos Disponibles
@app.route('/operativo/equipos_disponibles')
@login_required(role='operativo')
def equipos_disponibles():
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'error')
            return redirect(url_for('dashboard_operativo'))
        
        cursor = connection.cursor(dictionary=True)
        nombre_usuario_actual = session.get('user_name', '')
        fecha_hoy = datetime.now().strftime('%Y-%m-%d')
        
        # Verificar asistencia por cédula/ID de usuario
        id_codigo = session.get('id_codigo_consumidor', 0)
        cedula_usuario = session.get('user_cedula', '')
        cursor.execute("""
            SELECT COUNT(*) as tiene_asistencia
            FROM asistencia 
            WHERE DATE(fecha_asistencia) = %s
              AND (id_codigo_consumidor = %s OR cedula = %s)
        """, (fecha_hoy, id_codigo, cedula_usuario))
        resultado = cursor.fetchone()
        tiene_asistencia = resultado['tiene_asistencia'] > 0 if resultado else False

        # Fallback: comparación normalizada sin acentos y sin sensibilidad a mayúsculas
        if not tiene_asistencia:
            cursor.execute("""
                SELECT super
                FROM asistencia
                WHERE DATE(fecha_asistencia) = %s
            """, (fecha_hoy,))
            filas = cursor.fetchall()
            import unicodedata
            def _norm(s):
                return ''.join(c for c in unicodedata.normalize('NFD', s or '') if unicodedata.category(c) != 'Mn').lower().strip()
            tiene_asistencia = any(_norm(f['super']) == _norm(nombre_usuario_actual) for f in filas)

        cursor.close()
        connection.close()
        
        return render_template('modulos/operativo/equipos_disponibles.html',
                               user_name=session.get('user_name', ''),
                               user_role=session.get('user_role', ''),
                               tiene_asistencia=tiene_asistencia,
                               api_equipos_url='/api/equipos_disponibles')
    except Exception as e:
        print(f"Error en equipos_disponibles: {str(e)}")
        flash('Error al cargar la página de equipos disponibles', 'error')
        return redirect(url_for('dashboard_operativo'))

# API para obtener equipos disponibles filtrados por supervisor
@app.route('/api/equipos_disponibles', methods=['GET'])
@login_required_api(role='operativo')
def api_equipos_disponibles():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        
        cursor = connection.cursor(dictionary=True)
        nombre_supervisor = session.get('user_name', '')
        
        # Intentar consulta con columnas completas; si faltan, hacer fallback
        try:
            cursor.execute("""
                SELECT 
                    cedula,
                    codigo_tercero,
                    elemento,
                    familia,
                    serial,
                    estado,
                    fecha_ultimo_movimiento,
                    dias_ultimo,
                    tecnico,
                    super,
                    cuenta,
                    ot,
                    observacion,
                    fecha_creacion
                FROM disponibilidad_equipos 
                WHERE super = %s 
                ORDER BY tecnico, familia, elemento
            """, (nombre_supervisor,))
        except mysql.connector.Error as err:
            # Fallback si las columnas no existen en el entorno actual
            if err.errno == 1054 or 'Unknown column' in str(err):
                cursor.execute("""
                    SELECT 
                        id_disponibilidad_equipos AS id,
                        cedula,
                        codigo_tercero,
                        elemento,
                        familia,
                        serial,
                        estado,
                        tecnico,
                        super,
                        cuenta,
                        ot,
                        observacion,
                        fecha_creacion,
                        DATEDIFF(NOW(), fecha_creacion) AS dias_ultimo
                    FROM disponibilidad_equipos 
                    WHERE super = %s 
                    ORDER BY tecnico, familia, elemento
                """, (nombre_supervisor,))
            else:
                raise
        
        equipos = cursor.fetchall()
        
        # Normalizar tipos para JSON (fechas y decimales)
        def normalize(value):
            if isinstance(value, datetime):
                return value.strftime('%Y-%m-%d %H:%M:%S')
            try:
                from decimal import Decimal as _Decimal
                if isinstance(value, _Decimal):
                    return float(value)
            except Exception:
                pass
            return value
        
        equipos_serializados = []
        for row in equipos:
            row_serializado = {}
            for k, v in row.items():
                row_serializado[k] = normalize(v)
            equipos_serializados.append(row_serializado)
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'equipos': equipos_serializados,
            'total': len(equipos_serializados)
        })
        
    except Exception as e:
        app.logger.exception("Error en api_equipos_disponibles")
        return jsonify({'success': False, 'message': str(e)}), 500

# API para actualizar cuenta, OT y observación de un equipo
@app.route('/api/actualizar_equipo', methods=['POST'])
@login_required(role='operativo')
def api_actualizar_equipo():
    try:
        data = request.get_json(force=True) or {}
        serial = (data.get('serial') or '').strip()
        cuenta_in = (data.get('cuenta') or '').strip()
        ot_in = (data.get('ot') or '').strip()
        observ_in = (data.get('observacion') or '').strip()

        if not serial:
            return jsonify({'success': False, 'message': 'Serial del equipo es requerido'}), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)
        nombre_supervisor = session.get('user_name', '')

        print(f"[actualizar_equipo] payload serial={serial} cuenta='{cuenta_in}' ot='{ot_in}' observacion='{observ_in}'")

        # Verificar pertenencia y obtener valores actuales
        cursor.execute(
            """
            SELECT cuenta, ot, observacion
            FROM disponibilidad_equipos
            WHERE serial = %s AND super = %s
            LIMIT 1
            """,
            (serial, nombre_supervisor)
        )
        current = cursor.fetchone()
        if not current:
            cursor.close()
            connection.close()
            return jsonify({'success': False, 'message': 'No tiene permisos para actualizar este equipo'}), 403

        # Determinar qué campos se pueden actualizar (cuenta/OT solo si están vacíos; observación siempre editable)
        def is_empty(v):
            return v is None or (isinstance(v, str) and v.strip() == '')

        update_fields = []
        values = []
        if cuenta_in and is_empty(current.get('cuenta')):
            update_fields.append('cuenta = %s')
            values.append(cuenta_in)
        if ot_in and is_empty(current.get('ot')):
            update_fields.append('ot = %s')
            values.append(ot_in)
        if observ_in:
            update_fields.append('observacion = %s')
            values.append(observ_in)

        if not update_fields:
            cursor.close()
            connection.close()
            return jsonify({'success': False, 'message': 'No hay campos disponibles para actualizar (ya bloqueados).'}), 409

        update_sql = f"UPDATE disponibilidad_equipos SET {', '.join(update_fields)}, fecha_ultimo_movimiento = NOW() WHERE serial = %s AND super = %s"
        values.extend([serial, nombre_supervisor])
        print(f"[actualizar_equipo] SQL: {update_sql} | values={values}")
        try:
            cursor.execute(update_sql, tuple(values))
            connection.commit()
        except mysql.connector.Error as err:
            # Fallback si columna fecha_ultimo_movimiento no existe
            if getattr(err, 'errno', None) == 1054 or 'Unknown column' in str(err):
                update_sql = f"UPDATE disponibilidad_equipos SET {', '.join(update_fields)} WHERE serial = %s AND super = %s"
                print(f"[actualizar_equipo] Fallback SQL: {update_sql} | values={values}")
                cursor.execute(update_sql, tuple(values))
                connection.commit()
            else:
                raise

        # Actualizar días desde último movimiento, si la columna existe
        try:
            cursor.execute(
                """
                UPDATE disponibilidad_equipos
                SET dias_ultimo = DATEDIFF(NOW(), fecha_ultimo_movimiento)
                WHERE serial = %s
                """,
                (serial,)
            )
            connection.commit()
        except mysql.connector.Error as err:
            # Ignorar si la columna no existe
            if not (getattr(err, 'errno', None) == 1054 or 'Unknown column' in str(err)):
                raise

        cursor.close()
        connection.close()

        return jsonify({'success': True, 'message': 'Datos actualizados exitosamente'})

    except Exception as e:
        print(f"Error en api_actualizar_equipo: {str(e)}")
        try:
            if 'connection' in locals() and connection:
                connection.rollback()
        except Exception:
            pass
        return jsonify({'success': False, 'message': 'Error al actualizar el equipo'}), 500

# API para obtener datos de preoperacionales por técnicos
@app.route('/api/operativo/preoperacionales_tecnicos', methods=['GET'])
@login_required(role='operativo')
def api_preoperacionales_tecnicos():
    try:
        # Obtener parámetro de fecha
        fecha = request.args.get('fecha')
        
        # Validar fecha
        if not fecha:
            return jsonify({'success': False, 'message': 'Debe proporcionar una fecha'}), 400
        
        try:
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({'success': False, 'message': 'Formato de fecha inválido. Use YYYY-MM-DD'}), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True, buffered=True)
        
        # Obtener información del usuario actual (supervisor)
        nombre_usuario_actual = session.get('user_name', '')
        id_codigo_consumidor = session.get('id_codigo_consumidor', 0)
        
        # Obtener lista de técnicos asignados al supervisor actual
        query_tecnicos = """
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula as documento
            FROM recurso_operativo
            WHERE super = %s AND estado = 'Activo'
        """
        
        cursor.execute(query_tecnicos, (nombre_usuario_actual,))
        tecnicos = cursor.fetchall()
        
        if not tecnicos:
            return jsonify({
                'success': True,
                'data': [],
                'message': f'No se encontraron técnicos asignados al supervisor {nombre_usuario_actual}'
            })
        
        # Para cada técnico, verificar asistencia y preoperacional en la fecha especificada
        result_tecnicos = []
        
        for tecnico in tecnicos:
            id_tecnico = tecnico['id_codigo_consumidor']
            
            # Verificar asistencia para la fecha
            cursor.execute("""
                SELECT a.id_asistencia, a.fecha_asistencia 
                FROM asistencia a
                JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
                WHERE a.id_codigo_consumidor = %s 
                AND DATE(a.fecha_asistencia) = %s 
                AND t.valor = '1'
            """, (id_tecnico, fecha_obj))
            
            asistencia = cursor.fetchone()
            tiene_asistencia = asistencia is not None
            
            # Verificar preoperacional para la fecha
            cursor.execute("""
                SELECT id_preoperacional, fecha
                FROM preoperacional
                WHERE id_codigo_consumidor = %s AND DATE(fecha) = %s
            """, (id_tecnico, fecha_obj))
            
            preoperacional = cursor.fetchone()
            tiene_preoperacional = preoperacional is not None
            
            # Determinar estado del diligenciamiento
            estado_diligenciamiento = 'No Aplica'
            if tiene_asistencia:
                if tiene_preoperacional:
                    estado_diligenciamiento = 'Completo'
                else:
                    estado_diligenciamiento = 'Falta Preoperacional'
            
            # Agregar todos los técnicos (con o sin asistencia/preoperacional)
            result_tecnicos.append({
                'tecnico': tecnico['nombre'],
                'asistencia': 'Registrada' if tiene_asistencia else 'No Registrada',
                'preoperacional': 'Registrado' if tiene_preoperacional else 'No Registrado',
                'estado': estado_diligenciamiento
            })
        
        return jsonify({
            'success': True,
            'data': result_tecnicos,
            'total': len(result_tecnicos)
        })
        
    except Exception as e:
        logging.error(f"Error en obtener_datos_grafica_operacion_recurso: {str(e)}")
        logging.error(f"Parámetros recibidos: fecha_inicio={request.args.get('fecha_inicio')}, fecha_fin={request.args.get('fecha_fin')}, supervisor={request.args.get('supervisor')}, agrupacion={request.args.get('agrupacion')}")
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
        except:
            pass
        try:
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except:
            pass

# NUEVO: API Operativo - Asistencia por fecha para Inicio de Operación
@app.route('/api/operativo/inicio-operacion/asistencia', methods=['GET'])
@login_required(role='operativo')
def api_operativo_inicio_asistencia():
    """Lista registros de asistencia del día filtrados por el supervisor logueado.
    Campos: Cédula, Técnico, Carpeta, Super, Carpeta_Día, Tipificacion, Valor, Estado, Novedad.
    """
    try:
        # Obtener fecha; por defecto hoy (zona Bogotá)
        fecha_param = request.args.get('fecha')
        if fecha_param:
            try:
                fecha_consulta = datetime.strptime(fecha_param, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({'success': False, 'message': 'Formato de fecha inválido. Use YYYY-MM-DD'}), 400
        else:
            fecha_consulta = get_bogota_datetime().date()

        # Supervisor actual desde sesión
        supervisor_actual = session.get('user_name', '')
        if not supervisor_actual:
            return jsonify({'success': False, 'message': 'No se encontró supervisor en sesión'}), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)

        # Consulta principal uniendo tipificación para obtener nombre del evento
        # CORREGIDA: Usando subconsulta para eliminar duplicados y tomar solo el registro más reciente por técnico
        consulta = """
            SELECT 
                a.cedula,
                a.tecnico,
                a.carpeta,
                a.super,
                a.carpeta_dia,
                COALESCE(t.nombre_tipificacion, a.carpeta_dia) AS carpeta_dia_nombre,
                a.eventos AS eventos,
                COALESCE(pc.presupuesto_diario, 0) AS presupuesto_diario,
                a.valor,
                a.estado,
                a.novedad
            FROM asistencia a
            LEFT JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN presupuesto_carpeta pc ON t.nombre_tipificacion = pc.presupuesto_carpeta
            WHERE a.super = %s AND DATE(a.fecha_asistencia) = %s
            AND a.id_asistencia = (
                SELECT MAX(a2.id_asistencia)
                FROM asistencia a2
                WHERE a2.cedula = a.cedula 
                AND a2.super = %s 
                AND DATE(a2.fecha_asistencia) = %s
            )
            ORDER BY a.tecnico
        """
        cursor.execute(consulta, (supervisor_actual, fecha_consulta, supervisor_actual, fecha_consulta))
        registros = cursor.fetchall()
        def _norm(s):
            import unicodedata
            return ''.join(c for c in unicodedata.normalize('NFD', str(s or '')) if unicodedata.category(c) != 'Mn').lower().strip()
        if not registros:
            consulta_fb = """
                SELECT 
                    a.cedula,
                    a.tecnico,
                    a.carpeta,
                    a.super,
                    a.carpeta_dia,
                    COALESCE(t.nombre_tipificacion, a.carpeta_dia) AS carpeta_dia_nombre,
                    a.eventos AS eventos,
                    COALESCE(pc.presupuesto_diario, 0) AS presupuesto_diario,
                    a.valor,
                    a.estado,
                    a.novedad
                FROM asistencia a
                LEFT JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
                LEFT JOIN presupuesto_carpeta pc ON t.nombre_tipificacion = pc.presupuesto_carpeta
                WHERE DATE(a.fecha_asistencia) = %s
                AND a.id_asistencia = (
                    SELECT MAX(a2.id_asistencia)
                    FROM asistencia a2
                    WHERE a2.cedula = a.cedula 
                    AND a2.super = %s 
                    AND DATE(a2.fecha_asistencia) = %s
                )
                ORDER BY a.tecnico
            """
            cursor.execute(consulta_fb, (fecha_consulta, supervisor_actual, fecha_consulta))
            rows_fb = cursor.fetchall()
            registros = [r for r in rows_fb if _norm(r.get('super')) == _norm(supervisor_actual)]

        # Estadísticas para tarjetas
        # 1) Total técnicos: calcular basándose en los técnicos únicos que realmente aparecen en asistencia
        # Esto es más preciso que usar recurso_operativo ya que puede haber transferencias temporales
        cursor.execute("""
            SELECT COUNT(DISTINCT cedula) AS total
            FROM asistencia
            WHERE super = %s AND DATE(fecha_asistencia) = %s
        """, (supervisor_actual, fecha_consulta))
        result = cursor.fetchone()
        total_tecnicos = result['total'] if result else 0
        if total_tecnicos == 0 and registros:
            total_tecnicos = len({r.get('cedula') for r in registros if r.get('cedula')})

        # 2) Sin asistencia: contar solo las siguientes tipificaciones del día
        categorias_sin = [
            'AUSENCIA INJUSTIFICADA',
            'AUSENCIA INJUS AUXILIAR',
            'INCAPACIDAD ARL',
            'DOMINICAL O FESTIVO',
            'DOMINCAL O FESTIVO',
            'LICENCIA MATERNIDAD O PATERNIDAD',
            'LICENCIA LUTO',
            'SUSPENSION',
            'PERMISO',
            'VACACIONES',
            'DIA FAMILIA',
            'Restriccion medica',
            'RESTRICCION MEDICA',
            'RENUNCIA',
            'INCAPACIDAD MEDICA'
        ]
        placeholders = ','.join(['%s'] * len(categorias_sin))
        query_detalle = f"""
            SELECT t.nombre_tipificacion AS tipo, COUNT(DISTINCT a.cedula) AS cantidad
            FROM asistencia a
            LEFT JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE a.super = %s AND DATE(a.fecha_asistencia) = %s
              AND t.nombre_tipificacion IN ({placeholders})
              AND a.id_asistencia = (
                  SELECT MAX(a2.id_asistencia)
                  FROM asistencia a2
                  WHERE a2.cedula = a.cedula 
                  AND a2.super = a.super 
                  AND DATE(a2.fecha_asistencia) = DATE(a.fecha_asistencia)
              )
            GROUP BY t.nombre_tipificacion
        """
        params_detalle = [supervisor_actual, fecha_consulta] + categorias_sin
        cursor.execute(query_detalle, tuple(params_detalle))
        detalle_rows = cursor.fetchall() or []
        detalle_map = {row['tipo']: row['cantidad'] for row in detalle_rows}
        detalle_list = [{'nombre': k, 'cantidad': v} for k, v in detalle_map.items()]
        sin_asistencia = sum(detalle_map.values())
        if not detalle_map and registros:
            m = {}
            for r in registros:
                tipo = (r.get('carpeta_dia_nombre') or r.get('carpeta_dia') or '').strip()
                if tipo in categorias_sin:
                    m[tipo] = m.get(tipo, 0) + 1
            detalle_map = m
            detalle_list = [{'nombre': k, 'cantidad': v} for k, v in detalle_map.items()]
            sin_asistencia = sum(detalle_map.values())

        # 3) Con asistencia = total técnicos - sin asistencia (no negativo)
        con_asistencia = max(total_tecnicos - sin_asistencia, 0)

        # 4) Ok's Día y Presupuesto Día: calcular solo sobre registros únicos (sin duplicados)
        # Deduplicar registros por cédula para que coincida con lo que se muestra en la tabla
        registros_unicos = {}
        for r in registros:
            cedula = r.get('cedula')
            if cedula not in registros_unicos:
                registros_unicos[cedula] = r
        
        # Calcular totales solo sobre registros únicos
        oks_dia = 0
        presupuesto_dia = 0.0
        cumple_count = 0
        no_cumple_count = 0
        
        for r in registros_unicos.values():
            try:
                oks_dia += int(r.get('eventos') or r.get('tipificacion') or 0)
            except Exception:
                pass
            try:
                presupuesto_dia += float(r.get('valor') or 0)
            except Exception:
                pass
            
            # Contar estados de cumplimiento
            estado = (r.get('estado') or '').lower().strip()
            if estado in ['cumple', 'novedad']:
                cumple_count += 1
            elif estado in ['nocumple', 'no cumple', 'no aplica']:
                no_cumple_count += 1
        
        # Calcular presupuesto mensual basado en el primer día del mes con datos
        # Obtener el primer día del mes
        primer_dia_mes = fecha_consulta.replace(day=1)
        
        # Buscar el presupuesto del primer día del mes que tenga datos
        consulta_presupuesto_mes = """
            SELECT SUM(a.valor) as presupuesto_primer_dia
            FROM asistencia a
            WHERE a.super = %s 
            AND DATE(a.fecha_asistencia) = (
                SELECT MIN(DATE(a2.fecha_asistencia))
                FROM asistencia a2
                WHERE a2.super = %s 
                AND DATE(a2.fecha_asistencia) >= %s
                AND a2.valor > 0
            )
            AND a.valor > 0
        """
        cursor.execute(consulta_presupuesto_mes, (supervisor_actual, supervisor_actual, primer_dia_mes))
        resultado_presupuesto = cursor.fetchone()
        
        if resultado_presupuesto and resultado_presupuesto['presupuesto_primer_dia']:
            # Usar el presupuesto del primer día del mes con datos y multiplicar por 26
            presupuesto_mes = float(resultado_presupuesto['presupuesto_primer_dia']) * 26
        else:
            # Fallback: usar presupuesto del día actual multiplicado por 26
            presupuesto_mes = presupuesto_dia * 26

        # Calcular cumplimiento (porcentaje y fracción)
        total_cumplimiento = cumple_count + no_cumple_count
        cumplimiento_porcentaje = 0
        cumplimiento_fraccion = f"0/{total_cumplimiento}"
        
        if total_cumplimiento > 0:
            cumplimiento_porcentaje = round((cumple_count / total_cumplimiento) * 100, 1)
            cumplimiento_fraccion = f"{cumple_count}/{total_cumplimiento}"

        # Calcular cumplimiento mensual (acumulado del mes)
        # Obtener el primer y último día del mes
        primer_dia_mes = fecha_consulta.replace(day=1)
        if fecha_consulta.month == 12:
            ultimo_dia_mes = fecha_consulta.replace(year=fecha_consulta.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            ultimo_dia_mes = fecha_consulta.replace(month=fecha_consulta.month + 1, day=1) - timedelta(days=1)

        # Consulta para obtener todos los registros del mes
        consulta_mes = """
            SELECT 
                a.cedula,
                a.estado,
                DATE(a.fecha_asistencia) as fecha_dia
            FROM asistencia a
            WHERE a.super = %s 
            AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
            AND a.id_asistencia = (
                SELECT MAX(a2.id_asistencia)
                FROM asistencia a2
                WHERE a2.cedula = a.cedula 
                AND a2.super = %s 
                AND DATE(a2.fecha_asistencia) = DATE(a.fecha_asistencia)
            )
            ORDER BY a.fecha_asistencia, a.tecnico
        """
        cursor.execute(consulta_mes, (supervisor_actual, primer_dia_mes, ultimo_dia_mes, supervisor_actual))
        registros_mes = cursor.fetchall()

        # Contar cumplimiento mensual
        cumple_mes_count = 0
        no_cumple_mes_count = 0
        
        for r in registros_mes:
            estado = (r.get('estado') or '').lower().strip()
            if estado in ['cumple', 'novedad']:
                cumple_mes_count += 1
            elif estado in ['nocumple', 'no cumple', 'no aplica']:
                no_cumple_mes_count += 1

        # Calcular cumplimiento mensual (porcentaje y fracción)
        total_cumplimiento_mes = cumple_mes_count + no_cumple_mes_count
        cumplimiento_mes_porcentaje = 0
        cumplimiento_mes_fraccion = f"0/{total_cumplimiento_mes}"
        
        if total_cumplimiento_mes > 0:
            cumplimiento_mes_porcentaje = round((cumple_mes_count / total_cumplimiento_mes) * 100, 1)
            cumplimiento_mes_fraccion = f"{cumple_mes_count}/{total_cumplimiento_mes}"

        stats = {
            'total_tecnicos': total_tecnicos,
            'sin_asistencia': sin_asistencia,
            'con_asistencia': con_asistencia,
            'detalle': detalle_map,
            'sin_asistencia_detalle': detalle_list,
            'oks_dia': oks_dia,
            'presupuesto_dia': presupuesto_dia,
            'presupuesto_mes': presupuesto_mes,
            'cumple': cumple_count,
            'no_cumple': no_cumple_count,
            'cumplimiento_porcentaje': cumplimiento_porcentaje,
            'cumplimiento_fraccion': cumplimiento_fraccion,
            'cumplimiento_total': total_cumplimiento,
            'cumple_mes': cumple_mes_count,
            'no_cumple_mes': no_cumple_mes_count,
            'cumplimiento_mes_porcentaje': cumplimiento_mes_porcentaje,
            'cumplimiento_mes_fraccion': cumplimiento_mes_fraccion,
            'cumplimiento_mes_total': total_cumplimiento_mes
        }

        # Devolver solo los registros únicos para que coincida con los cálculos
        registros_finales = list(registros_unicos.values())

        # Agregar estado de última revisión vehicular por operativo
        try:
            bm_fields = [
                'estado_fisico_espejos_laterales','estado_fisico_pito','estado_fisico_freno_servicio','estado_fisico_manillares','estado_fisico_guayas','estado_fisico_tanque_combustible','estado_fisico_encendido','estado_fisico_pedales','estado_fisico_guardabarros','estado_fisico_sillin_tapiceria','estado_fisico_tablero','estado_fisico_mofle_silenciador','estado_fisico_kit_arrastre','estado_fisico_reposa_pies','estado_fisico_pata_lateral_central','estado_fisico_tijera_amortiguador','estado_fisico_bateria','luces_altas_bajas','luces_direccionales_delanteros','luces_direccionales_traseros','luces_luz_placa','luces_stop','prevension_casco','prevension_guantes','prevension_rodilleras','prevension_coderas','llantas_labrado_llantas','llantas_rines','llantas_presion_aire','otros_aceite','otros_suspension_direccion','otros_caja_cambios','otros_conexiones_electricas'
            ]
            bm_synonyms = {
                'prevension_casco': ['prevencion_casco'],
                'prevension_guantes': ['prevencion_guantes'],
                'prevension_rodilleras': ['prevencion_rodilleras'],
                'prevension_coderas': ['prevencion_coderas']
            }
            for r in registros_finales:
                inspeccion_info = {
                    'fecha_ultima': None,
                    'items_malos': 0,
                    'dias_restantes_subsanar': None,
                    'placa': None
                }
                try:
                    cursor.execute(
                        """
                        SELECT *
                        FROM mpa_inspeccion_vehiculo
                        WHERE recurso_operativo_cedula = %s
                        ORDER BY fecha_inspeccion DESC
                        LIMIT 1
                        """,
                        (r.get('cedula'),)
                    )
                    ultima = cursor.fetchone()
                    if not ultima:
                        cursor.execute(
                            """
                            SELECT id_codigo_consumidor
                            FROM recurso_operativo
                            WHERE recurso_operativo_cedula = %s
                            LIMIT 1
                            """,
                            (r.get('cedula'),)
                        )
                        ro = cursor.fetchone()
                        if ro and ro.get('id_codigo_consumidor'):
                            cursor.execute(
                                """
                                SELECT *
                                FROM mpa_inspeccion_vehiculo
                                WHERE id_codigo_consumidor = %s
                                ORDER BY fecha_inspeccion DESC
                                LIMIT 1
                                """,
                                (ro['id_codigo_consumidor'],)
                            )
                            ultima = cursor.fetchone()
                    if not ultima:
                        if ro and ro.get('id_codigo_consumidor'):
                            cursor.execute(
                                """
                                SELECT placa 
                                FROM mpa_vehiculos 
                                WHERE tecnico_asignado = %s AND estado = 'Activo'
                                ORDER BY id_mpa_vehiculos DESC
                                LIMIT 1
                                """,
                                (ro['id_codigo_consumidor'],)
                            )
                            v_id = cursor.fetchone()
                            if v_id and v_id.get('placa'):
                                cursor.execute(
                                    """
                                    SELECT *
                                    FROM mpa_inspeccion_vehiculo
                                    WHERE placa = %s
                                    ORDER BY fecha_inspeccion DESC
                                    LIMIT 1
                                    """,
                                    (v_id['placa'],)
                                )
                                ultima = cursor.fetchone()
                        if not ultima and r.get('cedula'):
                            cursor.execute(
                                """
                                SELECT placa 
                                FROM mpa_vehiculos 
                                WHERE tecnico_asignado = %s AND estado = 'Activo'
                                ORDER BY id_mpa_vehiculos DESC
                                LIMIT 1
                                """,
                                (r.get('cedula'),)
                            )
                            v_ced = cursor.fetchone()
                            if v_ced and v_ced.get('placa'):
                                cursor.execute(
                                    """
                                    SELECT *
                                    FROM mpa_inspeccion_vehiculo
                                    WHERE placa = %s
                                    ORDER BY fecha_inspeccion DESC
                                    LIMIT 1
                                    """,
                                    (v_ced['placa'],)
                                )
                                ultima = cursor.fetchone()
                    if ultima:
                        fi = ultima.get('fecha_inspeccion')
                        fecha_str = None
                        fi_date = None
                        if fi:
                            try:
                                fi_date = fi.date() if hasattr(fi, 'date') else datetime.strptime(str(fi)[:19], '%Y-%m-%d %H:%M:%S').date()
                            except Exception:
                                try:
                                    fi_date = datetime.strptime(str(fi)[:10], '%Y-%m-%d').date()
                                except Exception:
                                    fi_date = None
                            if fi_date:
                                try:
                                    fecha_str = fi_date.strftime('%Y-%m-%d')
                                except Exception:
                                    fecha_str = str(fi)[:10]
                        malos = 0
                        for k in bm_fields:
                            v = ultima.get(k)
                            if v is None and k in bm_synonyms:
                                for alt in bm_synonyms[k]:
                                    if ultima.get(alt) is not None:
                                        v = ultima.get(alt)
                                        break
                            s = str(v or '').strip().upper()
                            if s in ('M','MALO'):
                                malos += 1
                        dias_restantes = None
                        if fi_date:
                            try:
                                hoy = get_bogota_datetime().date()
                                transcurridos = (hoy - fi_date).days
                                dias_restantes = 5 - transcurridos
                                if dias_restantes < 0:
                                    dias_restantes = 0
                            except Exception:
                                dias_restantes = None
                        inspeccion_info = {
                            'fecha_ultima': fecha_str,
                            'items_malos': malos,
                            'dias_restantes_subsanar': dias_restantes,
                            'placa': ultima.get('placa')
                        }
                except Exception:
                    pass
                r['revision_vehicular'] = inspeccion_info
                r['mostrar_alerta_revision'] = bool(inspeccion_info['items_malos'])
        except Exception:
            pass
        
        return jsonify({
            'success': True,
            'registros': registros_finales,
            'total': len(registros_finales),
            'fecha': fecha_consulta.strftime('%Y-%m-%d'),
            'supervisor': supervisor_actual,
            'stats': stats
        })
    except Exception as e:
        logging.error(f"Error en api_operativo_inicio_asistencia: {str(e)}")
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
        except:
            pass
        try:
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except:
            pass

# API para consultar registros de asistencia por supervisor y fecha (para edición)
@app.route('/api/asistencia/consultar', methods=['GET'])
@login_required(role='administrativo')
def consultar_asistencia():
    """Consultar registros de asistencia por supervisor y fecha, incluyendo técnicos sin registro"""
    try:
        supervisor = request.args.get('supervisor')
        fecha = request.args.get('fecha')
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        if not supervisor:
            return jsonify({'success': False, 'message': 'Supervisor es requerido'}), 400
            
        # Validar que se proporcione fecha única o rango de fechas
        if not fecha and (not fecha_inicio or not fecha_fin):
            return jsonify({'success': False, 'message': 'Debe proporcionar fecha única o rango de fechas (fecha_inicio y fecha_fin)'}), 400
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True, buffered=True)
        
        # Para consulta de fecha única, incluir todos los técnicos del supervisor
        if fecha:
            # Validar formato de fecha única
            try:
                fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({'success': False, 'message': 'Formato de fecha inválido. Use YYYY-MM-DD'}), 400
            
            # Obtener solo los técnicos que tienen directamente al supervisor especificado
            cursor.execute("""
                SELECT 
                    id_codigo_consumidor,
                    recurso_operativo_cedula as cedula,
                    nombre as tecnico,
                    carpeta,
                    super
                FROM recurso_operativo 
                WHERE super = %s AND estado = 'Activo'
                ORDER BY nombre
            """, (supervisor,))
            
            tecnicos = cursor.fetchall()
            
            # Para cada técnico, buscar si tiene registro de asistencia para la fecha
            registros = []
            for tecnico in tecnicos:
                cursor.execute("""
                    SELECT 
                        id_asistencia,
                        cedula,
                        tecnico,
                        carpeta_dia,
                        carpeta,
                        super,
                        fecha_asistencia,
                        id_codigo_consumidor,
                        hora_inicio,
                        estado,
                        novedad
                    FROM asistencia 
                    WHERE id_codigo_consumidor = %s AND DATE(fecha_asistencia) = %s
                """, (tecnico['id_codigo_consumidor'], fecha_obj))
                
                registro_asistencia = cursor.fetchone()
                
                if registro_asistencia:
                    # Técnico tiene registro de asistencia
                    registros.append(registro_asistencia)
                else:
                    # Técnico no tiene registro, crear entrada vacía
                    registros.append({
                        'id_asistencia': None,
                        'cedula': tecnico['cedula'],
                        'tecnico': tecnico['tecnico'],
                        'carpeta_dia': None,
                        'carpeta': tecnico['carpeta'],
                        'super': supervisor,  # Usar el supervisor consultado, no el del técnico
                        'fecha_asistencia': fecha_obj.strftime('%Y-%m-%d'),
                        'id_codigo_consumidor': tecnico['id_codigo_consumidor'],
                        'hora_inicio': None,
                        'estado': None,
                        'novedad': None
                    })
        else:
            # Para rango de fechas, mantener comportamiento original (solo registros existentes)
            # Validar formato de rango de fechas
            try:
                fecha_inicio_obj = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
                fecha_fin_obj = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({'success': False, 'message': 'Formato de fechas inválido. Use YYYY-MM-DD'}), 400
                
            if fecha_inicio_obj > fecha_fin_obj:
                return jsonify({'success': False, 'message': 'La fecha de inicio no puede ser mayor que la fecha de fin'}), 400
                
            # Consultar solo registros de técnicos que tienen directamente al supervisor especificado
            cursor.execute("""
                SELECT 
                    id_asistencia,
                    cedula,
                    tecnico,
                    carpeta_dia,
                    carpeta,
                    super,
                    fecha_asistencia,
                    id_codigo_consumidor,
                    hora_inicio,
                    estado,
                    novedad
                FROM asistencia 
                WHERE super = %s AND DATE(fecha_asistencia) BETWEEN %s AND %s
                ORDER BY tecnico, fecha_asistencia
            """, (supervisor, fecha_inicio_obj, fecha_fin_obj))
            
            registros = cursor.fetchall()
        
        # Procesar los registros para formatear hora_inicio correctamente
        for registro in registros:
            if registro['hora_inicio']:
                # El campo time se devuelve como timedelta desde MySQL
                if hasattr(registro['hora_inicio'], 'total_seconds'):
                    # Es un timedelta
                    total_seconds = int(registro['hora_inicio'].total_seconds())
                    hours = total_seconds // 3600
                    minutes = (total_seconds % 3600) // 60
                    registro['hora_inicio'] = f"{hours:02d}:{minutes:02d}"
                else:
                    # Es un string o datetime.time
                    registro['hora_inicio'] = str(registro['hora_inicio'])[:5]  # HH:MM
        
        return jsonify({
            'success': True,
            'registros': registros,
            'total': len(registros)
        })
        
    except Exception as e:
        logging.error(f"Error en obtener_datos_grafica_carpeta_dia: {str(e)}")
        logging.error(f"Parámetros recibidos: fecha_inicio={request.args.get('fecha_inicio')}, fecha_fin={request.args.get('fecha_fin')}, supervisor={request.args.get('supervisor')}, agrupacion={request.args.get('agrupacion')}")
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            try:
                cursor.close()
            except:
                pass
        if 'connection' in locals() and connection and connection.is_connected():
            try:
                connection.close()
            except:
                pass

# API para exportar registros de asistencia a Excel
@app.route('/api/asistencia/exportar_excel', methods=['GET'])
@login_required(role='administrativo')
def exportar_asistencia_excel():
    """Exportar registros de asistencia a Excel con filtros de supervisor y fecha/rango"""
    try:
        supervisor = request.args.get('supervisor')
        fecha = request.args.get('fecha')
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        
        if not supervisor:
            return jsonify({'success': False, 'message': 'Supervisor es requerido'}), 400
            
        # Validar que se proporcione fecha única o rango de fechas
        if not fecha and (not fecha_inicio or not fecha_fin):
            return jsonify({'success': False, 'message': 'Debe proporcionar fecha única o rango de fechas'}), 400
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir consulta según el tipo de filtro de fecha
        if fecha:
            # Validar formato de fecha única
            try:
                fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
                fecha_inicio_obj = fecha_obj
                fecha_fin_obj = fecha_obj
            except ValueError:
                return jsonify({'success': False, 'message': 'Formato de fecha inválido. Use YYYY-MM-DD'}), 400
                
            # Consultar registros para fecha específica
            if supervisor == 'TODOS':
                cursor.execute("""
                    SELECT 
                        cedula,
                        tecnico,
                        carpeta_dia,
                        carpeta,
                        super,
                        DATE(fecha_asistencia) as fecha,
                        TIME(fecha_asistencia) as hora,
                        hora_inicio,
                        estado,
                        novedad,
                        valor,
                        eventos
                    FROM asistencia 
                    WHERE DATE(fecha_asistencia) = %s
                    ORDER BY super, tecnico, fecha_asistencia
                """, (fecha_obj,))
            else:
                cursor.execute("""
                    SELECT 
                        cedula,
                        tecnico,
                        carpeta_dia,
                        carpeta,
                        super,
                        DATE(fecha_asistencia) as fecha,
                        TIME(fecha_asistencia) as hora,
                        hora_inicio,
                        estado,
                        novedad,
                        valor,
                        eventos
                    FROM asistencia 
                    WHERE super = %s AND DATE(fecha_asistencia) = %s
                    ORDER BY tecnico, fecha_asistencia
                """, (supervisor, fecha_obj))
        else:
            # Validar formato de rango de fechas
            try:
                fecha_inicio_obj = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
                fecha_fin_obj = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({'success': False, 'message': 'Formato de fechas inválido. Use YYYY-MM-DD'}), 400
                
            if fecha_inicio_obj > fecha_fin_obj:
                return jsonify({'success': False, 'message': 'La fecha de inicio no puede ser mayor que la fecha de fin'}), 400
                
            # Consultar registros para rango de fechas
            if supervisor == 'TODOS':
                cursor.execute("""
                    SELECT 
                        cedula,
                        tecnico,
                        carpeta_dia,
                        carpeta,
                        super,
                        DATE(fecha_asistencia) as fecha,
                        TIME(fecha_asistencia) as hora,
                        hora_inicio,
                        estado,
                        novedad,
                        valor,
                        eventos
                    FROM asistencia 
                    WHERE DATE(fecha_asistencia) BETWEEN %s AND %s
                    ORDER BY super, tecnico, fecha_asistencia
                """, (fecha_inicio_obj, fecha_fin_obj))
            else:
                cursor.execute("""
                    SELECT 
                        cedula,
                        tecnico,
                        carpeta_dia,
                        carpeta,
                        super,
                        DATE(fecha_asistencia) as fecha,
                        TIME(fecha_asistencia) as hora,
                        hora_inicio,
                        estado,
                        novedad,
                        valor,
                        eventos
                    FROM asistencia 
                    WHERE super = %s AND DATE(fecha_asistencia) BETWEEN %s AND %s
                    ORDER BY tecnico, fecha_asistencia
                """, (supervisor, fecha_inicio_obj, fecha_fin_obj))
        
        registros = cursor.fetchall()

        # Formatear hora_inicio para legibilidad en Excel (HH:MM)
        for r in registros:
            if 'hora_inicio' in r and r['hora_inicio']:
                try:
                    hi = r['hora_inicio']
                    if hasattr(hi, 'total_seconds'):
                        total_seconds = int(hi.total_seconds())
                        hours = total_seconds // 3600
                        minutes = (total_seconds % 3600) // 60
                        r['hora_inicio'] = f"{hours:02d}:{minutes:02d}"
                    else:
                        r['hora_inicio'] = str(hi)[:5]
                except Exception:
                    r['hora_inicio'] = str(r['hora_inicio'])
        
        if not registros:
            return jsonify({'success': False, 'message': 'No se encontraron registros para exportar'}), 404
        
        # Crear DataFrame con los registros
        df_registros = pd.DataFrame(registros)
        
        # Obtener lista de técnicos únicos para la tabla de novedades
        tecnicos_unicos = df_registros['tecnico'].unique()
        
        # Obtener todas las tipificaciones disponibles
        cursor.execute("SELECT codigo_tipificacion as codigo, nombre_tipificacion as descripcion FROM tipificacion_asistencia ORDER BY codigo_tipificacion")
        tipificaciones = cursor.fetchall()
        
        # Crear tabla de técnicos con novedades del período
        tecnicos_novedades = []
        for tecnico in sorted(tecnicos_unicos):
            # Obtener registros del técnico en el período
            registros_tecnico = df_registros[df_registros['tecnico'] == tecnico]
            
            # Contar novedades por tipo
            novedades_count = registros_tecnico['carpeta_dia'].value_counts().to_dict()
            
            # Crear fila para el técnico
            fila_tecnico = {
                'Técnico': tecnico,
                'Total Registros': len(registros_tecnico)
            }
            
            # Agregar columnas para cada tipificación
            for tip in tipificaciones:
                codigo = tip['codigo']
                descripcion = tip['descripcion']
                count = novedades_count.get(codigo, 0)
                fila_tecnico[f'{codigo} - {descripcion}'] = count
            
            tecnicos_novedades.append(fila_tecnico)
        
        df_novedades = pd.DataFrame(tecnicos_novedades)
        
        # Crear archivo Excel en memoria
        output = io.BytesIO()
        
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # Hoja 1: Registros de asistencia
            df_registros.to_excel(writer, sheet_name='Registros Asistencia', index=False)
            
            # Hoja 2: Tabla de técnicos con novedades
            df_novedades.to_excel(writer, sheet_name='Resumen Técnicos', index=False)
            
            # Obtener workbook para formatear
            workbook = writer.book
            
            # Formatear hoja de registros
            worksheet_registros = writer.sheets['Registros Asistencia']
            for column in worksheet_registros.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                worksheet_registros.column_dimensions[column_letter].width = adjusted_width
            
            # Formatear hoja de resumen
            worksheet_resumen = writer.sheets['Resumen Técnicos']
            for column in worksheet_resumen.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 30)
                worksheet_resumen.column_dimensions[column_letter].width = adjusted_width
        
        output.seek(0)
        
        # Generar nombre del archivo
        fecha_str = fecha if fecha else f"{fecha_inicio}_{fecha_fin}"
        filename = f"asistencia_{supervisor}_{fecha_str}.xlsx"
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name=filename
        )
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error al exportar: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para actualizar un registro de asistencia
@app.route('/api/asistencia/actualizar', methods=['PUT'])
@login_required(role='administrativo')
def actualizar_asistencia():
    """Actualizar un registro de asistencia específico"""
    try:
        data = request.get_json()
        
        # Validar campos requeridos
        if not data.get('id_asistencia'):
            return jsonify({'success': False, 'message': 'ID de asistencia es requerido'}), 400
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor()
        
        # Obtener la fecha del registro de asistencia
        cursor.execute("""
            SELECT DATE(fecha_asistencia) as fecha_registro
            FROM asistencia 
            WHERE id_asistencia = %s
        """, (data.get('id_asistencia'),))
        
        resultado = cursor.fetchone()
        if not resultado:
            return jsonify({
                'success': False,
                'message': 'No se encontró el registro de asistencia'
            }), 404
            
        fecha_registro = resultado[0]
        
        # Obtener fecha actual en zona horaria de Bogotá
        bogota_tz = pytz.timezone('America/Bogota')
        fecha_actual = datetime.now(bogota_tz).date()
        
        # Calcular la diferencia en días
        diferencia_dias = (fecha_actual - fecha_registro).days
        
        # Validar que la fecha esté dentro del rango permitido (4 días hacia atrás)
        if diferencia_dias > 4:
            return jsonify({
                'success': False,
                'message': f'No se puede editar asistencia de más de 4 días atrás. La asistencia es del {fecha_registro.strftime("%d/%m/%Y")} y han pasado {diferencia_dias} días.'
            }), 400
        
        if diferencia_dias < 0:
            return jsonify({
                'success': False,
                'message': 'No se puede editar asistencia de fechas futuras.'
            }), 400
        
        # Actualizar el registro
        cursor.execute("""
            UPDATE asistencia 
            SET 
                cedula = %s,
                tecnico = %s,
                carpeta_dia = %s,
                carpeta = %s,
                super = %s,
                id_codigo_consumidor = %s
            WHERE id_asistencia = %s
        """, (
            data.get('cedula', ''),
            data.get('tecnico', ''),
            data.get('carpeta_dia', ''),
            data.get('carpeta', ''),
            data.get('super', ''),
            data.get('id_codigo_consumidor', 0),
            data.get('id_asistencia')
        ))
        
        if cursor.rowcount > 0:
            connection.commit()
            return jsonify({
                'success': True,
                'message': 'Registro actualizado correctamente'
            })
        else:
            return jsonify({
                'success': False,
                'message': 'No se encontró el registro para actualizar'
            }), 404
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para eliminar un registro de asistencia
@app.route('/api/asistencia/eliminar', methods=['DELETE'])
@login_required(role='administrativo')
def eliminar_asistencia():
    """Eliminar un registro de asistencia específico"""
    try:
        data = request.get_json()
        
        # Validar campos requeridos
        if not data.get('id_asistencia'):
            return jsonify({'success': False, 'message': 'ID de asistencia es requerido'}), 400
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor()
        
        # Eliminar el registro
        cursor.execute("""
            DELETE FROM asistencia 
            WHERE id_asistencia = %s
        """, (data.get('id_asistencia'),))
        
        if cursor.rowcount > 0:
            connection.commit()
            return jsonify({
                'success': True,
                'message': 'Registro eliminado correctamente'
            })
        else:
            return jsonify({
                'success': False,
                'message': 'No se encontró el registro para eliminar'
            }), 404
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para obtener valores únicos de tipificacion_asistencia
@app.route('/api/asistencia/tipificacion', methods=['GET'])
@login_required(role='administrativo')
def obtener_tipificacion_asistencia():
    try:
        zona = (request.args.get('zona') or '').strip()
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        if zona:
            cursor.execute(
                """
                SELECT codigo_tipificacion, nombre_tipificacion as descripcion
                FROM tipificacion_asistencia
                WHERE codigo_tipificacion IS NOT NULL AND codigo_tipificacion != '' AND zona = %s
                ORDER BY codigo_tipificacion
                """,
                (zona,)
            )
        else:
            cursor.execute(
                """
                SELECT codigo_tipificacion, nombre_tipificacion as descripcion
                FROM tipificacion_asistencia
                WHERE codigo_tipificacion IS NOT NULL AND codigo_tipificacion != ''
                ORDER BY codigo_tipificacion
                """
            )
        tipificaciones = cursor.fetchall()
        return jsonify({
            'success': True,
            'tipificaciones': [{'codigo': t['codigo_tipificacion'], 'descripcion': t['descripcion']} for t in tipificaciones]
        })
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para obtener lista de supervisores
@app.route('/api/asistencia/supervisores', methods=['GET'])
@login_required(role='administrativo')
def obtener_supervisores_asistencia():
    """Obtener lista de supervisores únicos de la tabla recurso_operativo"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener supervisores únicos de recurso_operativo donde carpeta='SUPERVISORES'
        cursor.execute("""
            SELECT DISTINCT nombre as supervisor
            FROM recurso_operativo 
            WHERE carpeta = 'SUPERVISORES' AND nombre IS NOT NULL AND nombre != ''
            ORDER BY nombre
        """)
        
        supervisores_rows = cursor.fetchall()
        lista = [s['supervisor'] for s in supervisores_rows]
        base = "CORTES CUERVO SANDRA CECILIA"
        if base not in lista:
            lista = [base] + lista
        
        return jsonify({
            'success': True,
            'supervisores': lista
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para obtener técnicos por supervisor
@app.route('/api/asistencia/tecnicos', methods=['GET'])
@login_required(role='administrativo')
def obtener_tecnicos_asistencia():
    try:
        supervisor = request.args.get('supervisor')
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        if supervisor:
            if supervisor.strip().upper() == "CORTES CUERVO SANDRA CECILIA":
                cursor.execute(
                    """
                    SELECT DISTINCT id_codigo_consumidor, recurso_operativo_cedula, nombre, carpeta, super
                    FROM recurso_operativo
                    WHERE estado = 'Activo' AND (
                        UPPER(TRIM(super)) = %s OR UPPER(TRIM(carpeta)) IN ('SUPERVISOR','CONDUCTOR')
                    )
                    ORDER BY nombre
                    """,
                    (supervisor,)
                )
            else:
                cursor.execute(
                    """
                    SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre, carpeta, super
                    FROM recurso_operativo
                    WHERE super = %s AND estado = 'Activo' AND (carpeta IS NULL OR carpeta != 'SUPERVISORES')
                    ORDER BY nombre
                    """,
                    (supervisor,)
                )
        else:
            cursor.execute(
                """
                SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre, carpeta, super
                FROM recurso_operativo
                WHERE estado = 'Activo' AND (carpeta IS NULL OR carpeta != 'SUPERVISORES')
                ORDER BY nombre
                """
            )
        tecnicos = cursor.fetchall()
        return jsonify({'success': True, 'tecnicos': tecnicos})
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para crear novedades RRHH y programar asistencia
@app.route('/api/asistencia/novedades/crear', methods=['POST'])
@login_required(role='administrativo')
def api_crear_novedad_rrhh():
    try:
        data = request.get_json(force=True) or {}
        supervisor = (data.get('supervisor') or '').strip()
        cedula = (data.get('cedula') or '').strip()
        id_codigo_consumidor = data.get('id_codigo_consumidor')
        fecha_inicio = (data.get('fecha_inicio') or '').strip()
        fecha_fin = (data.get('fecha_fin') or '').strip()
        codigo_tipificacion = (data.get('codigo_tipificacion') or '').strip()
        if not cedula and id_codigo_consumidor:
            conn = get_db_connection()
            if conn is None:
                return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            cur = conn.cursor(dictionary=True)
            cur.execute("SELECT recurso_operativo_cedula FROM recurso_operativo WHERE id_codigo_consumidor = %s", (id_codigo_consumidor,))
            row = cur.fetchone()
            cedula = row['recurso_operativo_cedula'] if row else ''
            cur.close(); conn.close()
        if not (cedula and fecha_inicio and fecha_fin and codigo_tipificacion):
            return jsonify({'success': False, 'message': 'Datos incompletos'}), 400
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor(dictionary=True)
        cur.execute("SELECT codigo_tipificacion, nombre_tipificacion, zona FROM tipificacion_asistencia WHERE codigo_tipificacion = %s", (codigo_tipificacion,))
        tip = cur.fetchone()
        if not tip or (tip.get('zona') or '').upper() != 'RRHH':
            cur.close(); conn.close()
            return jsonify({'success': False, 'message': 'Tipificación no válida para RRHH'}), 400
        cur.execute("SELECT id_codigo_consumidor, nombre, super FROM recurso_operativo WHERE recurso_operativo_cedula = %s AND estado = 'Activo'", (cedula,))
        ro = cur.fetchone()
        if not ro:
            cur.close(); conn.close()
            return jsonify({'success': False, 'message': 'Técnico no encontrado'}), 404
        tecnico_nombre = ro['nombre']
        tecnico_id = ro['id_codigo_consumidor']
        supervisor_real = supervisor or ro.get('super') or ''
        from datetime import datetime, timedelta
        fi = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
        ff = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        if fi > ff:
            cur.close(); conn.close()
            return jsonify({'success': False, 'message': 'Rango de fechas inválido'}), 400
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS rrhh_novedades (
                id INT AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(64) NOT NULL,
                id_codigo_consumidor INT NULL,
                tecnico VARCHAR(256) NOT NULL,
                supervisor VARCHAR(256) NULL,
                fecha_inicio DATE NOT NULL,
                fecha_fin DATE NOT NULL,
                codigo_tipificacion VARCHAR(64) NOT NULL,
                nombre_tipificacion VARCHAR(256) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_cedula (cedula),
                INDEX idx_fecha (fecha_inicio),
                INDEX idx_tip (codigo_tipificacion)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        dias = 0
        actualizados = 0
        d = fi
        while d <= ff:
            fecha_str = d.strftime('%Y-%m-%d')
            cur.execute("SELECT id_asistencia FROM asistencia WHERE cedula = %s AND DATE(fecha_asistencia) = %s", (cedula, fecha_str))
            ex = cur.fetchone()
            if ex:
                cur.execute("UPDATE asistencia SET carpeta_dia = %s, carpeta = %s WHERE id_asistencia = %s", (codigo_tipificacion, 'RRHH', ex['id_asistencia']))
                actualizados += 1
            else:
                cur.execute(
                    """
                    INSERT INTO asistencia (cedula, tecnico, carpeta_dia, carpeta, super, fecha_asistencia, id_codigo_consumidor)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """,
                    (cedula, tecnico_nombre, codigo_tipificacion, 'RRHH', supervisor_real, fecha_str, tecnico_id)
                )
                actualizados += 1
            dias += 1
            d += timedelta(days=1)
        cur.execute(
            """
            INSERT INTO rrhh_novedades (cedula, id_codigo_consumidor, tecnico, supervisor, fecha_inicio, fecha_fin, codigo_tipificacion, nombre_tipificacion)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """,
            (cedula, tecnico_id, tecnico_nombre, supervisor_real, fi.strftime('%Y-%m-%d'), ff.strftime('%Y-%m-%d'), tip['codigo_tipificacion'], tip['nombre_tipificacion'])
        )
        conn.commit()
        cur.close(); conn.close()
        return jsonify({'success': True, 'message': f'Novedad programada: {dias} día(s), registros afectadas: {actualizados}'})
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500

# API para obtener resumen agrupado de asistencia por tipificación
@app.route('/api/asistencia/resumen_agrupado', methods=['GET'])
@login_required(role='administrativo')
def obtener_resumen_agrupado_asistencia():
    """Obtener resumen de asistencia agrupado por grupos de tipificación y operación por recurso operativo"""
    try:
        # Obtener parámetros de filtro
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor_filtro = request.args.get('supervisor')
        
        # Si no se proporcionan fechas, usar la fecha actual
        if not fecha_inicio or not fecha_fin:
            fecha_actual = get_bogota_datetime().date()
            fecha_inicio = fecha_fin = fecha_actual
        else:
            try:
                fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
                fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
                
                # Validaciones adicionales de rango de fechas
                if fecha_inicio > fecha_fin:
                    return jsonify({
                        'success': False,
                        'message': 'La fecha de inicio no puede ser mayor que la fecha de fin'
                    }), 400
                
                # Validar que las fechas no sean futuras
                fecha_actual = get_bogota_datetime().date()
                if fecha_inicio > fecha_actual or fecha_fin > fecha_actual:
                    return jsonify({
                        'success': False,
                        'message': 'No se pueden consultar fechas futuras'
                    }), 400
                
                # Validar rango máximo (1 año)
                diferencia_dias = (fecha_fin - fecha_inicio).days
                if diferencia_dias > 365:
                    return jsonify({
                        'success': False,
                        'message': 'El rango de fechas no puede ser mayor a 1 año'
                    }), 400
                    
            except ValueError:
                return jsonify({
                    'success': False,
                    'message': 'Formato de fecha inválido. Use YYYY-MM-DD'
                }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # ===== NUEVA FUNCIONALIDAD: OPERACIÓN X RECURSO OPERATIVO =====
        # Consulta para obtener datos agrupados por grupo y carpeta (excluyendo ausencias)
        # Se normaliza la carpeta para agrupar variantes como BACK y la falta de ortografía BROWFIELD
        query_operacion = """
            SELECT 
                CASE 
                    WHEN UPPER(a.carpeta) LIKE 'ARREGLOS HFC%'
                         OR UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%'
                         OR UPPER(a.carpeta) = 'DX' THEN 'ARREGLOS'
                    WHEN UPPER(a.carpeta) LIKE 'BROWNFIELD%'
                         OR UPPER(a.carpeta) LIKE 'BROWFIELD%'
                         OR UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%'
                         OR UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%' THEN 'INSTALACIONES'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA%'
                         OR UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%' THEN 'POSTVENTA'
                    ELSE 'OTROS'
                END as grupo,
                CASE 
                    WHEN UPPER(a.carpeta) LIKE 'ARREGLOS HFC%' THEN 'ARREGLOS HFC'
                    WHEN UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%' THEN 'MANTENIMIENTO FTTH'
                    WHEN UPPER(a.carpeta) = 'DX' THEN 'DX'
                    WHEN UPPER(a.carpeta) LIKE 'BROWNFIELD%' OR UPPER(a.carpeta) LIKE 'BROWFIELD%' THEN 'BROWNFIELD'
                    WHEN UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%' THEN 'FTTH INSTALACIONES'
                    WHEN UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%' THEN 'INSTALACIONES DOBLES'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%' THEN 'POSTVENTA FTTH'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA%' THEN 'POSTVENTA'
                    ELSE a.carpeta
                END as carpeta,
                COUNT(DISTINCT a.id_codigo_consumidor) as total_tecnicos
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo NOT IN ('AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA')
                AND t.grupo IN ('ARREGLOS', 'INSTALACIONES', 'POSTVENTA')
                AND a.carpeta IS NOT NULL
                AND a.carpeta != ''
                AND (
                    UPPER(a.carpeta) LIKE 'ARREGLOS HFC%'
                    OR UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%'
                    OR UPPER(a.carpeta) = 'DX'
                    OR UPPER(a.carpeta) LIKE 'BROWNFIELD%'
                    OR UPPER(a.carpeta) LIKE 'BROWFIELD%'
                    OR UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%'
                    OR UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%'
                    OR UPPER(a.carpeta) LIKE 'POSTVENTA%'
                    OR UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%'
                )
        """
        
        params_operacion = [fecha_inicio, fecha_fin]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor_filtro:
            query_operacion += " AND a.super = %s"
            params_operacion.append(supervisor_filtro)
        
        query_operacion += """
            GROUP BY 
                CASE 
                    WHEN UPPER(a.carpeta) LIKE 'ARREGLOS HFC%'
                         OR UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%'
                         OR UPPER(a.carpeta) = 'DX' THEN 'ARREGLOS'
                    WHEN UPPER(a.carpeta) LIKE 'BROWNFIELD%'
                         OR UPPER(a.carpeta) LIKE 'BROWFIELD%'
                         OR UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%'
                         OR UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%' THEN 'INSTALACIONES'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA%'
                         OR UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%' THEN 'POSTVENTA'
                    ELSE 'OTROS'
                END,
                CASE 
                    WHEN UPPER(a.carpeta) LIKE 'ARREGLOS HFC%' THEN 'ARREGLOS HFC'
                    WHEN UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%' THEN 'MANTENIMIENTO FTTH'
                    WHEN UPPER(a.carpeta) = 'DX' THEN 'DX'
                    WHEN UPPER(a.carpeta) LIKE 'BROWNFIELD%' OR UPPER(a.carpeta) LIKE 'BROWFIELD%' THEN 'BROWNFIELD'
                    WHEN UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%' THEN 'FTTH INSTALACIONES'
                    WHEN UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%' THEN 'INSTALACIONES DOBLES'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%' THEN 'POSTVENTA FTTH'
                    WHEN UPPER(a.carpeta) LIKE 'POSTVENTA%' THEN 'POSTVENTA'
                    ELSE a.carpeta
                END
            ORDER BY grupo, carpeta
        """
        
        # Ejecutar consulta para operación por recurso operativo
        cursor.execute(query_operacion, tuple(params_operacion))
        resultados_operacion = cursor.fetchall()
        
        # Calcular total operativo (excluyendo ausencias)
        query_total_operativo = """
            SELECT COUNT(DISTINCT a.id_codigo_consumidor) as total_operativo
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo NOT IN ('AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA')
                AND t.grupo IN ('ARREGLOS', 'INSTALACIONES', 'POSTVENTA')
                AND a.carpeta IS NOT NULL
                AND a.carpeta != ''
                AND (
                    UPPER(a.carpeta) LIKE 'ARREGLOS HFC%'
                    OR UPPER(a.carpeta) LIKE 'MANTENIMIENTO FTTH%'
                    OR UPPER(a.carpeta) = 'DX'
                    OR UPPER(a.carpeta) LIKE 'BROWNFIELD%'
                    OR UPPER(a.carpeta) LIKE 'BROWFIELD%'
                    OR UPPER(a.carpeta) LIKE 'FTTH INSTALACIONES%'
                    OR UPPER(a.carpeta) LIKE 'INSTALACIONES DOBLES%'
                    OR UPPER(a.carpeta) LIKE 'POSTVENTA%'
                    OR UPPER(a.carpeta) LIKE 'POSTVENTA FTTH%'
                )
        """
        
        params_total_operativo = [fecha_inicio, fecha_fin]
        if supervisor_filtro:
            query_total_operativo += " AND a.super = %s"
            params_total_operativo.append(supervisor_filtro)
        
        cursor.execute(query_total_operativo, tuple(params_total_operativo))
        total_operativo = cursor.fetchone()['total_operativo'] or 0
        
        # Procesar resultados de operación por recurso operativo
        operacion_recurso = []
        for resultado in resultados_operacion:
            grupo = resultado['grupo']
            carpeta = resultado['carpeta']
            total_tecnicos = resultado['total_tecnicos']
            
            # Calcular porcentaje respecto al total operativo (sin ausencias)
            porcentaje = round((total_tecnicos * 100) / total_operativo, 2) if total_operativo > 0 else 0
            
            operacion_recurso.append({
                'grupo': grupo,
                'carpeta': carpeta,
                'total_tecnicos': total_tecnicos,
                'porcentaje': porcentaje
            })
        
        # ===== FUNCIONALIDAD EXISTENTE: RESUMEN POR GRUPOS =====
        # Consulta base para obtener datos agrupados (solo registros con grupo válido)
        query_base = """
            SELECT 
                t.grupo,
                t.nombre_tipificacion as carpeta,
                COUNT(DISTINCT a.id_codigo_consumidor) as total_tecnicos
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo IN ('ARREGLOS', 'AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA', 'INSTALACIONES', 'POSTVENTA')
        """
        
        params = [fecha_inicio, fecha_fin]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor_filtro:
            query_base += " AND a.super = %s"
            params.append(supervisor_filtro)
        
        query_base += """
            GROUP BY t.grupo, t.nombre_tipificacion
            ORDER BY t.grupo, t.nombre_tipificacion
        """
        
        # Ejecutar consulta principal
        cursor.execute(query_base, tuple(params))
        resultados = cursor.fetchall()
        
        # Calcular total de técnicos para porcentajes (solo registros con grupo válido)
        query_total = """
            SELECT COUNT(DISTINCT a.id_codigo_consumidor) as total_general
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo IN ('ARREGLOS', 'AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA', 'INSTALACIONES', 'POSTVENTA')
        """
        
        params_total = [fecha_inicio, fecha_fin]
        if supervisor_filtro:
            query_total += " AND a.super = %s"
            params_total.append(supervisor_filtro)
        
        cursor.execute(query_total, tuple(params_total))
        total_general = cursor.fetchone()['total_general'] or 0
        
        # Calcular total operativo para la tabla tradicional (excluyendo ausencias)
        query_total_general_operativo = """
            SELECT COUNT(DISTINCT a.id_codigo_consumidor) as total_general_operativo
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo NOT IN ('AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA')
                AND t.grupo IN ('ARREGLOS', 'INSTALACIONES', 'POSTVENTA')
        """
        
        params_total_general_operativo = [fecha_inicio, fecha_fin]
        if supervisor_filtro:
            query_total_general_operativo += " AND a.super = %s"
            params_total_general_operativo.append(supervisor_filtro)
        
        cursor.execute(query_total_general_operativo, tuple(params_total_general_operativo))
        total_general_operativo = cursor.fetchone()['total_general_operativo'] or 0
        
        # Procesar resultados y calcular porcentajes
        resumen_agrupado = []
        grupos_totales = {}
        
        # Primero, calcular totales por grupo
        for resultado in resultados:
            grupo = resultado['grupo']
            if grupo not in grupos_totales:
                grupos_totales[grupo] = 0
            grupos_totales[grupo] += resultado['total_tecnicos']
        
        # Luego, crear el resumen con porcentajes
        for resultado in resultados:
            grupo = resultado['grupo']
            carpeta = resultado['carpeta']
            total_tecnicos = resultado['total_tecnicos']
            
            # Calcular porcentaje respecto al total operativo (sin ausencias)
            porcentaje = round((total_tecnicos * 100) / total_general_operativo, 2) if total_general_operativo > 0 else 0
            
            resumen_agrupado.append({
                'grupo': grupo,
                'carpeta': carpeta,
                'total_tecnicos': total_tecnicos,
                'porcentaje': porcentaje
            })
        
        # Calcular resumen por grupos
        resumen_grupos = []
        for grupo, total_grupo in grupos_totales.items():
            porcentaje_grupo = round((total_grupo * 100) / total_general_operativo, 2) if total_general_operativo > 0 else 0
            resumen_grupos.append({
                'grupo': grupo,
                'total_tecnicos': total_grupo,
                'porcentaje': porcentaje_grupo
            })
        
        # ===== NUEVA FUNCIONALIDAD: OBTENER AUSENCIAS =====
        # Consulta para obtener ausencias para la tabla de operación
        query_ausencias_operacion = """
            SELECT 
                CASE 
                    WHEN t.grupo = 'AUSENCIA INJUSTIFICADA' THEN 'AUSENCIA INJUSTIFICADA'
                    WHEN t.grupo = 'AUSENCIA JUSTIFICADA' THEN 'AUSENCIA JUSTIFICADA'
                    ELSE t.grupo
                END as grupo,
                t.nombre_tipificacion as carpeta,
                COUNT(DISTINCT a.id_codigo_consumidor) as total_tecnicos
            FROM asistencia a
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND t.grupo IS NOT NULL 
                AND t.grupo != ''
                AND t.grupo IN ('AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA')
        """
        
        params_ausencias_operacion = [fecha_inicio, fecha_fin]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor_filtro:
            query_ausencias_operacion += " AND a.super = %s"
            params_ausencias_operacion.append(supervisor_filtro)
        
        query_ausencias_operacion += """
            GROUP BY CASE 
                WHEN t.grupo = 'AUSENCIA INJUSTIFICADA' THEN 'AUSENCIA INJUSTIFICADA'
                WHEN t.grupo = 'AUSENCIA JUSTIFICADA' THEN 'AUSENCIA JUSTIFICADA'
                ELSE t.grupo
            END, t.nombre_tipificacion
            ORDER BY grupo, t.nombre_tipificacion
        """
        
        # Ejecutar consulta para ausencias de operación
        cursor.execute(query_ausencias_operacion, tuple(params_ausencias_operacion))
        resultados_ausencias_operacion = cursor.fetchall()
        
        # Procesar ausencias para la tabla de operación
        ausencias_operacion = []
        total_ausencias = 0
        for resultado in resultados_ausencias_operacion:
            grupo = resultado['grupo']
            carpeta = resultado['carpeta']
            total_tecnicos = resultado['total_tecnicos']
            total_ausencias += total_tecnicos
            
            # Calcular porcentaje respecto al total operativo (sin ausencias)
            porcentaje = round((total_tecnicos * 100) / total_operativo, 2) if total_operativo > 0 else 0
            
            ausencias_operacion.append({
                'grupo': grupo,
                'carpeta': carpeta,
                'total_tecnicos': total_tecnicos,
                'porcentaje': porcentaje,
                'es_ausencia': True
            })
        
        # Los porcentajes de operación ya están calculados correctamente usando solo total_operativo
        
        # Ordenar resumen_agrupado para que las ausencias aparezcan al final
        resumen_agrupado_ordenado = []
        ausencias_detalladas = []
        
        for item in resumen_agrupado:
            if item['grupo'] in ['AUSENCIA INJUSTIFICADA', 'AUSENCIA JUSTIFICADA']:
                item['es_ausencia'] = True
                ausencias_detalladas.append(item)
            else:
                resumen_agrupado_ordenado.append(item)
        
        # Agregar ausencias al final
        resumen_agrupado_ordenado.extend(ausencias_detalladas)
        
        return jsonify({
            'success': True,
            'data': {
                # Nueva funcionalidad: Operación por Recurso Operativo
                'operacion_recurso': operacion_recurso,
                'ausencias_operacion': ausencias_operacion,
                'total_operativo': total_operativo,
                'total_ausencias': total_ausencias,
                # Funcionalidad existente
                'detallado': resumen_agrupado_ordenado,
                'resumen_grupos': resumen_grupos,
                'total_general': total_general,
                'total_general_operativo': total_general_operativo,
                'fecha_inicio': fecha_inicio.strftime('%Y-%m-%d'),
                'fecha_fin': fecha_fin.strftime('%Y-%m-%d'),
                'supervisor_filtro': supervisor_filtro
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/indicadores/cumplimiento')
@login_required(role='administrativo')
@cache.cached(query_string=True, timeout=60)
def obtener_indicadores_cumplimiento():
    try:
        ensure_indicator_indexes()
        # Obtener los parámetros de fecha
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor_filtro = request.args.get('supervisor')
        
        # Para compatibilidad con versiones anteriores
        fecha = request.args.get('fecha')
        
        # Mostrar información de debug sobre parámetros recibidos
        print(f"Parámetros recibidos en API:")
        print(f"- fecha_inicio: {fecha_inicio}")
        print(f"- fecha_fin: {fecha_fin}")
        print(f"- supervisor: {supervisor_filtro}")
        print(f"- fecha (compatibilidad): {fecha}")
        
        # Validar fechas
        if fecha:
            # Modo compatibilidad - una sola fecha
            try:
                fecha_inicio = fecha_fin = datetime.strptime(fecha, '%Y-%m-%d').date()
                print(f"Usando modo compatibilidad con fecha: {fecha_inicio}")
            except ValueError:
                print(f"Error: Formato de fecha inválido: {fecha}")
                return jsonify({
                    'success': False,
                    'error': 'Formato de fecha inválido. Use YYYY-MM-DD'
                }), 400
        elif fecha_inicio and fecha_fin:
            # Nuevo modo - rango de fechas
            try:
                fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
                fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
                print(f"Usando rango de fechas: {fecha_inicio} a {fecha_fin}")
            except ValueError:
                print(f"Error: Formato de fecha inválido en rango: {fecha_inicio} - {fecha_fin}")
                return jsonify({
                    'success': False,
                    'error': 'Formato de fecha inválido. Use YYYY-MM-DD'
                }), 400
        else:
            # Si no se proporcionan fechas, usar la fecha actual
            fecha_actual = get_bogota_datetime().date()
            fecha_inicio = fecha_fin = fecha_actual
            print(f"Usando fecha actual: {fecha_actual}")
        
        connection = get_db_connection()
        if connection is None:
            print("Error: No se pudo establecer conexión a la base de datos")
            return jsonify({
                'success': False,
                'error': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar datos para el rango de fechas
        cursor.execute("SELECT COUNT(*) as total FROM asistencia WHERE fecha_asistencia >= %s AND fecha_asistencia < DATE_ADD(%s, INTERVAL 1 DAY)", 
                      (fecha_inicio, fecha_fin))
        total_asistencia = cursor.fetchone()['total']
        
        cursor.execute("SELECT COUNT(*) as total FROM preoperacional WHERE fecha >= %s AND fecha < DATE_ADD(%s, INTERVAL 1 DAY)", 
                      (fecha_inicio, fecha_fin))
        total_preop = cursor.fetchone()['total']
        
        print(f"Datos encontrados en el rango {fecha_inicio} a {fecha_fin}:")
        print(f"- Total asistencia: {total_asistencia}")
        print(f"- Total preoperacional: {total_preop}")
        
        if total_asistencia == 0 and total_preop == 0:
            print("No hay datos para el rango de fechas")
            return jsonify({
                'success': True,
                'indicadores': [],
                'mensaje': f'No hay datos para el período {fecha_inicio} - {fecha_fin}'
            })
        
        # Obtener asistencia válida por supervisor excluyendo técnicos con excepción activa
        query_asistencia = """
            SELECT a.super as supervisor, COUNT(*) as total_asistencia 
            FROM asistencia a 
            JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN recurso_operativo ro ON ro.recurso_operativo_cedula = a.cedula
            LEFT JOIN preoperacional_excepciones e ON e.activo = 1 
                AND DATE(a.fecha_asistencia) BETWEEN COALESCE(e.fecha_inicio, e.fecha) AND COALESCE(e.fecha_fin, e.fecha)
                AND (e.cedula = a.cedula OR e.id_codigo_consumidor = ro.id_codigo_consumidor)
            WHERE a.fecha_asistencia >= %s AND a.fecha_asistencia < DATE_ADD(%s, INTERVAL 1 DAY)
              AND t.valor = '1'
              AND e.id IS NULL
              AND IFNULL(ro.excluido_preoperacional, 0) = 0
            GROUP BY a.super
        """
        params_asistencia = [fecha_inicio, fecha_fin]
        
        # Obtener preoperacionales por supervisor excluyendo técnicos con excepción activa
        query_preoperacional = """
            SELECT p.supervisor, COUNT(*) as total_preoperacional
            FROM preoperacional p
            INNER JOIN asistencia a ON p.id_codigo_consumidor = a.id_codigo_consumidor 
                AND DATE(p.fecha) = DATE(a.fecha_asistencia)
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN preoperacional_excepciones e ON e.activo = 1 
                AND DATE(p.fecha) BETWEEN COALESCE(e.fecha_inicio, e.fecha) AND COALESCE(e.fecha_fin, e.fecha)
                AND (e.id_codigo_consumidor = p.id_codigo_consumidor)
            LEFT JOIN recurso_operativo ro ON ro.id_codigo_consumidor = p.id_codigo_consumidor
            WHERE p.fecha >= %s AND p.fecha < DATE_ADD(%s, INTERVAL 1 DAY)
                AND t.valor = '1'
                AND e.id IS NULL
                AND IFNULL(ro.excluido_preoperacional, 0) = 0
            GROUP BY p.supervisor
        """
        params_preoperacional = [fecha_inicio, fecha_fin]
        
        # Aplicar filtro por supervisor si existe
        if supervisor_filtro:
            print(f"Aplicando filtro por supervisor: {supervisor_filtro}")
            query_asistencia += " HAVING a.super = %s"
            params_asistencia.append(supervisor_filtro)
            
            query_preoperacional += " HAVING supervisor = %s"
            params_preoperacional.append(supervisor_filtro)
        
        print(f"Ejecutando consulta de asistencia: {query_asistencia}")
        print(f"Parámetros: {params_asistencia}")
        
        # Ejecutar consultas
        cursor.execute(query_asistencia, tuple(params_asistencia))
        asistencia_raw = cursor.fetchall()
        
        print(f"Ejecutando consulta de preoperacional: {query_preoperacional}")
        print(f"Parámetros: {params_preoperacional}")
        
        cursor.execute(query_preoperacional, tuple(params_preoperacional))
        preop_raw = cursor.fetchall()
        
        # Debugging detallado de supervisores
        print(f"🔍 SUPERVISORES RAW DE ASISTENCIA:")
        for row in asistencia_raw:
            supervisor = row['supervisor']
            print(f"  - '{supervisor}' (len: {len(supervisor) if supervisor else 0}, repr: {repr(supervisor)})")
        
        print(f"🔍 SUPERVISORES RAW DE PREOPERACIONAL:")
        for row in preop_raw:
            supervisor = row['supervisor']
            print(f"  - '{supervisor}' (len: {len(supervisor) if supervisor else 0}, repr: {repr(supervisor)})")
        
        # Normalizar nombres de supervisores (trim espacios y convertir a mayúsculas)
        def normalizar_supervisor(nombre):
            if not nombre:
                return None
            return nombre.strip().upper()
        
        # Procesar asistencia con normalización
        asistencia_por_supervisor = {}
        for row in asistencia_raw:
            supervisor_original = row['supervisor']
            supervisor_normalizado = normalizar_supervisor(supervisor_original)
            if supervisor_normalizado:
                if supervisor_normalizado in asistencia_por_supervisor:
                    asistencia_por_supervisor[supervisor_normalizado] += row['total_asistencia']
                    print(f"⚠️  DUPLICADO EN ASISTENCIA: '{supervisor_original}' -> '{supervisor_normalizado}' (sumando {row['total_asistencia']})")
                else:
                    asistencia_por_supervisor[supervisor_normalizado] = row['total_asistencia']
        
        # Procesar preoperacional con normalización
        preop_por_supervisor = {}
        for row in preop_raw:
            supervisor_original = row['supervisor']
            supervisor_normalizado = normalizar_supervisor(supervisor_original)
            if supervisor_normalizado:
                if supervisor_normalizado in preop_por_supervisor:
                    preop_por_supervisor[supervisor_normalizado] += row['total_preoperacional']
                    print(f"⚠️  DUPLICADO EN PREOPERACIONAL: '{supervisor_original}' -> '{supervisor_normalizado}' (sumando {row['total_preoperacional']})")
                else:
                    preop_por_supervisor[supervisor_normalizado] = row['total_preoperacional']
        
        print(f"✅ ASISTENCIA NORMALIZADA: {asistencia_por_supervisor}")
        print(f"✅ PREOPERACIONAL NORMALIZADA: {preop_por_supervisor}")
        
        # Calcular indicadores con supervisores únicos
        indicadores = []
        supervisores = set(list(asistencia_por_supervisor.keys()) + list(preop_por_supervisor.keys()))
        
        for supervisor in supervisores:
            if supervisor:  # Ignorar supervisores nulos
                total_asistencia = asistencia_por_supervisor.get(supervisor, 0)
                total_preoperacional = preop_por_supervisor.get(supervisor, 0)
                porcentaje = (total_preoperacional * 100) / total_asistencia if total_asistencia > 0 else 0
                
                indicador = {
                    'supervisor': supervisor,
                    'total_asistencia': total_asistencia,
                    'total_preoperacional': total_preoperacional,
                    'porcentaje_cumplimiento': porcentaje
                }
                indicadores.append(indicador)
        
        # Ordenar por porcentaje de cumplimiento descendente
        indicadores.sort(key=lambda x: x['porcentaje_cumplimiento'], reverse=True)
        
        print(f"Se calcularon {len(indicadores)} indicadores")
        
        cursor.close()
        connection.close()
        
        # Incluir información del período consultado en la respuesta
        return jsonify({
            'success': True,
            'indicadores': indicadores,
            'periodo': {
                'fecha_inicio': fecha_inicio.strftime('%Y-%m-%d'),
                'fecha_fin': fecha_fin.strftime('%Y-%m-%d')
            }
        })
        
    except Exception as e:
        import traceback
        print(f"Error en indicadores de cumplimiento: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/indicadores/detalle_tecnicos')
@login_required(role='administrativo')
@cache.cached(query_string=True, timeout=60)
def obtener_detalle_tecnicos():
    """Obtener detalle de técnicos por supervisor con estado de asistencia y preoperacional"""
    print(f"🔍 [DETALLE_TECNICOS] ===== ENDPOINT LLAMADO =====")
    print(f"🔍 [DETALLE_TECNICOS] Usuario actual: {session.get('user_id', 'No autenticado')}")
    print(f"🔍 [DETALLE_TECNICOS] Rol usuario: {session.get('role', 'Sin rol')}")
    print(f"🔍 [DETALLE_TECNICOS] Request method: {request.method}")
    print(f"🔍 [DETALLE_TECNICOS] Request URL: {request.url}")
    print(f"🔍 [DETALLE_TECNICOS] Request args: {dict(request.args)}")
    print(f"🔍 [DETALLE_TECNICOS] Iniciando endpoint...")
    try:
        ensure_indicator_indexes()
        # Obtener parámetros
        fecha = request.args.get('fecha')
        supervisor = request.args.get('supervisor')
        
        print(f"🔍 [DETALLE_TECNICOS] Parámetros recibidos:")
        print(f"  - fecha: '{fecha}'")
        print(f"  - supervisor: '{supervisor}'")
        
        # Validar parámetros
        if not fecha or not supervisor:
            return jsonify({
                'success': False,
                'error': 'Se requieren los parámetros fecha y supervisor'
            }), 400
        
        # Validar formato de fecha
        try:
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'error': 'Formato de fecha inválido. Use YYYY-MM-DD'
            }), 400
        
        print(f"🔍 [DETALLE_TECNICOS] Intentando conectar a la base de datos...")
        connection = get_db_connection()
        if connection is None:
            print(f"❌ [DETALLE_TECNICOS] Error: No se pudo conectar a la base de datos")
            return jsonify({
                'success': False,
                'error': 'Error de conexión a la base de datos'
            }), 500
        
        print(f"✅ [DETALLE_TECNICOS] Conexión a BD exitosa")
        cursor = connection.cursor(dictionary=True)
        try:
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS preoperacional_excepciones (
                    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                    cedula VARCHAR(32),
                    id_codigo_consumidor INT NULL,
                    fecha DATE NOT NULL,
                    fecha_inicio DATE NULL,
                    fecha_fin DATE NULL,
                    supervisor VARCHAR(255) NULL,
                    motivo VARCHAR(255) NULL,
                    activo TINYINT(1) NOT NULL DEFAULT 1,
                    creado_por VARCHAR(64) NULL,
                    creado_en TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_fecha_cedula (fecha, cedula),
                    INDEX idx_fecha_id (fecha, id_codigo_consumidor)
                )
                """
            )
            connection.commit()
        except Exception:
            pass
        
        
        query_tecnicos = """
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula as documento
            FROM recurso_operativo 
            WHERE super = %s AND estado = 'Activo' AND id_codigo_consumidor IS NOT NULL
            ORDER BY nombre
        """
        
        print(f"🔍 [DETALLE_TECNICOS] Ejecutando consulta: {query_tecnicos}")
        print(f"🔍 [DETALLE_TECNICOS] Con parámetro supervisor: '{supervisor}'")
        
        cursor.execute(query_tecnicos, (supervisor,))
        tecnicos_supervisor = cursor.fetchall()
        
        print(f"✅ [DETALLE_TECNICOS] Técnicos encontrados en BD: {len(tecnicos_supervisor)}")
        for tecnico in tecnicos_supervisor:
            print(f"  - {tecnico['nombre']} (ID: {tecnico['id_codigo_consumidor']}, Doc: {tecnico['documento']})")
        
        if not tecnicos_supervisor:
            print(f"❌ No se encontraron técnicos activos para el supervisor: '{supervisor}'")
            cursor.close()
            connection.close()
            return jsonify({
                'success': True,
                'tecnicos': [],
                'mensaje': f'No se encontraron técnicos activos para el supervisor {supervisor}'
            })
        
        
        excluidos_map = {}
        try:
            ids = [t['id_codigo_consumidor'] for t in tecnicos_supervisor if t.get('id_codigo_consumidor')]
            cedulas = [t['documento'] for t in tecnicos_supervisor if t.get('documento')]
            params = [fecha_obj, fecha_obj]
            where_parts = ["COALESCE(fecha_inicio, fecha) <= %s", "COALESCE(fecha_fin, fecha) >= %s", "activo = 1"]
            conds = []
            if ids:
                conds.append(f"id_codigo_consumidor IN ({', '.join(['%s'] * len(ids))})")
                params.extend(ids)
            if cedulas:
                conds.append(f"cedula IN ({', '.join(['%s'] * len(cedulas))})")
                params.extend(cedulas)
            if conds:
                where_sql = " AND ".join(where_parts + [f"({ ' OR '.join(conds) })"]) 
                cursor.execute(f"SELECT id_codigo_consumidor, cedula FROM preoperacional_excepciones WHERE {where_sql}", tuple(params))
                rows_exc = cursor.fetchall() or []
                for r in rows_exc:
                    if r.get('id_codigo_consumidor'):
                        excluidos_map[r['id_codigo_consumidor']] = True
                    if r.get('cedula'):
                        # Marcar por cédula también
                        excluidos_map[r['cedula']] = True
            # Excluidos permanentes desde recurso_operativo
            if ids:
                placeholders = ','.join(['%s'] * len(ids))
                cursor.execute(f"SELECT id_codigo_consumidor FROM recurso_operativo WHERE id_codigo_consumidor IN ({placeholders}) AND IFNULL(excluido_preoperacional,0) = 1", tuple(ids))
                rows_perm = cursor.fetchall() or []
                for r in rows_perm:
                    val = r.get('id_codigo_consumidor') if isinstance(r, dict) else r[0]
                    if val is not None:
                        excluidos_map[val] = True
        except Exception:
            pass

        
        tecnicos_detalle = []
        
        ids_all = [t['id_codigo_consumidor'] for t in tecnicos_supervisor if t.get('id_codigo_consumidor')]
        asistencias_map = {}
        preop_map = {}
        
        if ids_all:
            placeholders = ', '.join(['%s'] * len(ids_all))
            sql_as = f"""
                SELECT a.id_codigo_consumidor, a.fecha_asistencia
                FROM asistencia a
                JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
                WHERE a.id_codigo_consumidor IN ({placeholders})
                  AND a.fecha_asistencia >= %s AND a.fecha_asistencia < DATE_ADD(%s, INTERVAL 1 DAY)
                  AND t.valor = '1'
            """
            params_as = tuple(ids_all) + (fecha_obj, fecha_obj)
            cursor.execute(sql_as, params_as)
            rows_as = cursor.fetchall() or []
            for r in rows_as:
                cid = r.get('id_codigo_consumidor')
                fa = r.get('fecha_asistencia')
                if cid is not None:
                    prev = asistencias_map.get(cid)
                    if prev is None or (fa and prev and fa < prev):
                        asistencias_map[cid] = fa
            
            sql_po = f"""
                SELECT p.id_codigo_consumidor, p.fecha
                FROM preoperacional p
                WHERE p.id_codigo_consumidor IN ({placeholders})
                  AND p.fecha >= %s AND p.fecha < DATE_ADD(%s, INTERVAL 1 DAY)
            """
            params_po = tuple(ids_all) + (fecha_obj, fecha_obj)
            cursor.execute(sql_po, params_po)
            rows_po = cursor.fetchall() or []
            for r in rows_po:
                cid = r.get('id_codigo_consumidor')
                fp = r.get('fecha')
                if cid is not None:
                    prev = preop_map.get(cid)
                    if prev is None or (fp and prev and fp < prev):
                        preop_map[cid] = fp
        
        for tecnico in tecnicos_supervisor:
            id_tecnico = tecnico['id_codigo_consumidor']
            nombre_tecnico = tecnico['nombre']
            
            fecha_asistencia_utc = asistencias_map.get(id_tecnico)
            tiene_asistencia = fecha_asistencia_utc is not None
            hora_asistencia = None
            if tiene_asistencia:
                fecha_bogota = convert_to_bogota_time(fecha_asistencia_utc)
                hora_asistencia = fecha_bogota.strftime('%H:%M')
            
            fecha_preop_utc = preop_map.get(id_tecnico)
            tiene_preoperacional = fecha_preop_utc is not None
            hora_preoperacional = None
            if tiene_preoperacional:
                fecha_bogota = convert_to_bogota_time(fecha_preop_utc)
                hora_preoperacional = fecha_bogota.strftime('%H:%M')
            
            excluido = bool(excluidos_map.get(id_tecnico) or excluidos_map.get(tecnico.get('documento')))
            
            if excluido and tiene_asistencia:
                estado = "Excluido"
            elif tiene_asistencia and tiene_preoperacional:
                estado = "Completo"
            elif tiene_asistencia and not tiene_preoperacional:
                estado = "Falta Preoperacional"
            elif not tiene_asistencia and tiene_preoperacional:
                estado = "Falta Asistencia"
            else:
                estado = "Sin Registros"
            
            tecnicos_detalle.append({
                'id_codigo_consumidor': id_tecnico,
                'nombre': nombre_tecnico,
                'asistencia': tiene_asistencia,
                'preoperacional': tiene_preoperacional,
                'excluido': excluido,
                'estado': estado,
                'hora_asistencia': hora_asistencia or 'N/A',
                'hora_preoperacional': hora_preoperacional or 'N/A',
                'hora_registro': hora_asistencia or hora_preoperacional or 'N/A'
            })
        
        cursor.close()
        connection.close()
        
        print(f"Se encontraron {len(tecnicos_detalle)} técnicos para el supervisor {supervisor}")
        
        return jsonify({
            'success': True,
            'tecnicos': tecnicos_detalle,
            'supervisor': supervisor,
            'fecha': fecha
        })
        
    except Exception as e:
        import traceback
        error_msg = str(e)
        traceback_str = traceback.format_exc()
        
        print(f"❌ [DETALLE_TECNICOS] ERROR CRÍTICO:")
        print(f"  - Tipo de error: {type(e).__name__}")
        print(f"  - Mensaje: {error_msg}")
        print(f"  - Traceback completo:")
        print(traceback_str)
        print(f"❌ [DETALLE_TECNICOS] FIN DEL ERROR")
        
        # Cerrar conexiones si existen
        try:
            if 'cursor' in locals():
                cursor.close()
            if 'connection' in locals():
                connection.close()
        except:
            pass
        
        return jsonify({
            'success': False,
            'error': f"Error interno del servidor: {error_msg}",
            'error_type': type(e).__name__
        }), 500

@app.route('/indicadores/api')
@login_required(role='administrativo')
def indicadores_api():
    # Obtener la lista de supervisores para el selector del formulario
    try:
        connection = get_db_connection()
        cursor = connection.cursor(dictionary=True)
        
        # Consulta para obtener supervisores únicos de recurso_operativo
        cursor.execute("SELECT DISTINCT super as supervisor FROM recurso_operativo WHERE super IS NOT NULL AND super != ''")
        supervisores_db = cursor.fetchall()
        
        supervisores = [sup['supervisor'] for sup in supervisores_db]
        
        cursor.close()
        connection.close()
    except Exception as e:
        logging.error(f"Error al obtener supervisores: {str(e)}")
        supervisores = []
    
    return render_template('modulos/administrativo/api_indicadores_cumplimiento.html', 
                          supervisores=supervisores)

@app.route('/admin/cumpleanos', methods=['GET'])
@login_required(role='administrativo')
def admin_cumpleanos():
    return render_template('modulos/administrativo/cumpleanos.html')

@app.route('/api/admin/cumpleanos', methods=['GET'])
@login_required_api(role='administrativo')
def api_admin_cumpleanos():
    try:
        mes = request.args.get('mes', type=int)
        if not mes or mes < 1 or mes > 12:
            mes = get_bogota_datetime().month
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT nombre, fecha_cumpleanos
            FROM recurso_operativo
            WHERE fecha_cumpleanos IS NOT NULL
              AND MONTH(fecha_cumpleanos) = %s
              AND (estado IS NULL OR estado = 'Activo')
            ORDER BY DAY(fecha_cumpleanos) ASC, nombre ASC
            """,
            (mes,)
        )
        rows = cursor.fetchall()
        data = []
        for r in rows:
            f = r.get('fecha_cumpleanos')
            fecha_iso = None
            fecha_mostrar = None
            try:
                s = str(f)
                fecha_iso = s[:10]
                partes = fecha_iso.split('-')
                if len(partes) == 3:
                    fecha_mostrar = f"{partes[2]}/{partes[1]}"
            except Exception:
                fecha_iso = None
                fecha_mostrar = None
            data.append({'nombre': r.get('nombre'), 'fecha': fecha_iso, 'fecha_mostrar': fecha_mostrar})
        return jsonify({'success': True, 'mes': mes, 'cumpleanos': data})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500
    finally:
        try:
            cursor.close()
            if connection and connection.is_connected():
                connection.close()
        except Exception:
            pass




@app.route('/api/cargos', methods=['GET'])
@login_required(role='administrativo')
def get_cargos():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener cargos distintos de la tabla recurso_operativo
        cursor.execute("SELECT DISTINCT cargo FROM recurso_operativo WHERE cargo IS NOT NULL AND cargo != '' ORDER BY cargo")
        cargos = [row['cargo'] for row in cursor.fetchall()]
        
        return jsonify({'success': True, 'cargos': cargos})
        
    except Error as e:
        return jsonify({'success': False, 'message': f'Error al obtener cargos: {str(e)}'}), 500
        
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/analistas', methods=['GET'])
@login_required(role='administrativo')
def get_analistas():
    """Obtener lista de usuarios con cargo ANALISTA para el dropdown de analistas"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener usuarios con cargo ANALISTA que estén activos
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula 
            FROM recurso_operativo 
            WHERE cargo = 'ANALISTA' AND estado = 'Activo' 
            ORDER BY nombre
        """)
        analistas = cursor.fetchall()
        
        return jsonify({'success': True, 'analistas': analistas})
        
    except Error as e:
        return jsonify({'success': False, 'message': f'Error al obtener analistas: {str(e)}'}), 500
        
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# ============================================================================
# REST API ENDPOINTS FOR VEHICLE MANAGEMENT
# ============================================================================

@app.route('/api/vehiculos', methods=['GET'])
@login_required()
@role_required('logistica')
def api_obtener_vehiculos():
    """Obtener lista de vehículos con filtros opcionales"""
    try:
        print("Intentando obtener conexión a la base de datos...")
        connection = get_db_connection()
        if connection is None:
            print("La conexión es None")
            return jsonify({
                'success': False,
                'message': 'MySQL Connection not available'
            }), 500
        print("Conexión obtenida exitosamente")
            
        cursor = connection.cursor(dictionary=True)
        
        # Parámetros de filtro
        estado = request.args.get('estado')
        tipo_vehiculo = request.args.get('tipo_vehiculo')
        tecnico_id = request.args.get('tecnico_id')
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))
        
        # Construir consulta base
        query = """
            SELECT pa.*, r.nombre as tecnico_nombre, r.recurso_operativo_cedula, r.cargo,
                   CASE 
                       WHEN pa.soat_vencimiento <= CURDATE() THEN 'vencido'
                       WHEN pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'por_vencer'
                       ELSE 'vigente'
                   END as estado_soat,
                   CASE 
                       WHEN pa.tecnomecanica_vencimiento <= CURDATE() THEN 'vencido'
                       WHEN pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'por_vencer'
                       ELSE 'vigente'
                   END as estado_tecnomecanica
            FROM parque_automotor pa 
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
        """
        
        conditions = []
        params = []
        
        if estado:
            conditions.append("pa.estado = %s")
            params.append(estado)
            
        if tipo_vehiculo:
            conditions.append("pa.tipo_vehiculo = %s")
            params.append(tipo_vehiculo)
            
        if tecnico_id:
            conditions.append("pa.id_codigo_consumidor = %s")
            params.append(tecnico_id)
            
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
            
        query += " ORDER BY pa.fecha_asignacion DESC"
        
        # Contar total de registros
        count_query = query.replace(
            "SELECT pa.*, r.nombre, r.recurso_operativo_cedula, r.cargo, CASE WHEN pa.soat_vencimiento <= CURDATE() THEN 'vencido' WHEN pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'por_vencer' ELSE 'vigente' END as estado_soat, CASE WHEN pa.tecnomecanica_vencimiento <= CURDATE() THEN 'vencido' WHEN pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'por_vencer' ELSE 'vigente' END as estado_tecnomecanica",
            "SELECT COUNT(*)"
        )
        
        cursor.execute(count_query, params)
        total = cursor.fetchone()['COUNT(*)']
        
        # Aplicar paginación
        offset = (page - 1) * per_page
        query += f" LIMIT {per_page} OFFSET {offset}"
        
        cursor.execute(query, params)
        vehiculos = cursor.fetchall()
        
        # Convertir fechas para serialización JSON
        for vehiculo in vehiculos:
            if vehiculo['fecha_asignacion']:
                vehiculo['fecha_asignacion'] = vehiculo['fecha_asignacion'].isoformat()
            if vehiculo['soat_vencimiento']:
                vehiculo['soat_vencimiento'] = vehiculo['soat_vencimiento'].isoformat()
            if vehiculo['tecnomecanica_vencimiento']:
                vehiculo['tecnomecanica_vencimiento'] = vehiculo['tecnomecanica_vencimiento'].isoformat()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': vehiculos,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': (total + per_page - 1) // per_page
            }
        })
        
    except Exception as e:
        print(f"Error en API obtener vehículos: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener vehículos: {str(e)}'
        }), 500

@app.route('/api/vehiculos/<int:vehiculo_id>', methods=['GET'])
@login_required()
@role_required('logistica')
def api_obtener_vehiculo(vehiculo_id):
    """Obtener un vehículo específico por ID"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT pa.*, r.nombre as tecnico_nombre, r.recurso_operativo_cedula, r.cargo
            FROM parque_automotor pa 
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE pa.id_parque_automotor = %s
        """, (vehiculo_id,))
        
        vehiculo = cursor.fetchone()
        
        if not vehiculo:
            return jsonify({
                'success': False,
                'message': 'Vehículo no encontrado'
            }), 404
            
        # Convertir fechas para serialización JSON
        if vehiculo['fecha_asignacion']:
            vehiculo['fecha_asignacion'] = vehiculo['fecha_asignacion'].isoformat()
        if vehiculo['soat_vencimiento']:
            vehiculo['soat_vencimiento'] = vehiculo['soat_vencimiento'].isoformat()
        if vehiculo['tecnomecanica_vencimiento']:
            vehiculo['tecnomecanica_vencimiento'] = vehiculo['tecnomecanica_vencimiento'].isoformat()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': vehiculo
        })
        
    except Exception as e:
        print(f"Error en API obtener vehículo: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener vehículo: {str(e)}'
        }), 500

@app.route('/api/vehiculos', methods=['POST'])
@login_required()
@role_required('logistica')
def api_crear_vehiculo():
    """Crear un nuevo vehículo"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False,
                'message': 'No se recibieron datos JSON'
            }), 400
            
        # Validar campos requeridos
        required_fields = ['placa', 'tipo_vehiculo', 'marca', 'modelo', 'color', 'fecha_asignacion']
        for field in required_fields:
            if not data.get(field):
                return jsonify({
                    'success': False,
                    'message': f'El campo {field} es requerido'
                }), 400
                
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar si la placa ya existe
        cursor.execute('SELECT placa FROM parque_automotor WHERE placa = %s', (data['placa'],))
        if cursor.fetchone():
            return jsonify({
                'success': False,
                'message': 'Ya existe un vehículo registrado con esta placa'
            }), 400
            
        # Insertar el nuevo vehículo
        cursor.execute("""
            INSERT INTO parque_automotor (
                placa, tipo_vehiculo, marca, modelo, color, 
                id_codigo_consumidor, fecha_asignacion, estado,
                soat_vencimiento, tecnomecanica_vencimiento, observaciones,
                kilometraje_actual, proximo_mantenimiento_km
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            data['placa'], data['tipo_vehiculo'], data['marca'], data['modelo'], data['color'],
            data.get('id_codigo_consumidor'), data['fecha_asignacion'], data.get('estado', 'Activo'),
            data.get('soat_vencimiento'), data.get('tecnomecanica_vencimiento'), data.get('observaciones'),
            data.get('kilometraje_actual', 0), data.get('proximo_mantenimiento_km')
        ))
        
        vehiculo_id = cursor.lastrowid
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Vehículo creado exitosamente',
            'data': {'id': vehiculo_id}
        }), 201
        
    except Exception as e:
        print(f"Error en API crear vehículo: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al crear vehículo: {str(e)}'
        }), 500

@app.route('/api/vehiculos/<int:vehiculo_id>', methods=['PUT'])
@login_required()
@role_required('logistica')
def api_actualizar_vehiculo(vehiculo_id):
    """Actualizar un vehículo existente"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False,
                'message': 'No se recibieron datos JSON'
            }), 400
            
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar si el vehículo existe
        cursor.execute('SELECT id_parque_automotor FROM parque_automotor WHERE id_parque_automotor = %s', (vehiculo_id,))
        if not cursor.fetchone():
            return jsonify({
                'success': False,
                'message': 'El vehículo no existe'
            }), 404
            
        # Verificar si la placa ya existe para otro vehículo
        if 'placa' in data:
            cursor.execute('SELECT id_parque_automotor FROM parque_automotor WHERE placa = %s AND id_parque_automotor != %s', 
                         (data['placa'], vehiculo_id))
            if cursor.fetchone():
                return jsonify({
                    'success': False,
                    'message': 'Ya existe otro vehículo registrado con esta placa'
                }), 400
                
        # Construir consulta de actualización dinámicamente
        update_fields = []
        params = []
        
        allowed_fields = [
            'placa', 'tipo_vehiculo', 'marca', 'modelo', 'color',
            'id_codigo_consumidor', 'fecha_asignacion', 'estado',
            'soat_vencimiento', 'tecnomecanica_vencimiento', 'observaciones',
            'kilometraje_actual', 'proximo_mantenimiento_km',
            # Campos adicionales del vehículo
            'vin', 'parque_automotorcol', 'licencia',
            # Información del propietario
            'cedula_propietario', 'nombre_propietario',
            # Campos de mantenimiento
            'proximo_mantenimiento', 'fecha_ultimo_mantenimiento', 'ultimo_mantenimiento',
            'fecha_actualizacion', 'numero_vin', 'propietario_cedula', 'propietario_nombre',
            # Inspección física
            'estado_carroceria', 'estado_llantas', 'estado_frenos', 'estado_motor',
            'estado_luces', 'estado_espejos', 'estado_vidrios', 'estado_asientos',
            # Elementos de seguridad
            'cinturon_seguridad', 'extintor', 'botiquin', 'triangulos_seguridad',
            'llanta_repuesto', 'herramientas', 'gato', 'cruceta',
            # Información operativa
            'centro_de_trabajo', 'ciudad', 'supervisor', 'fecha', 'kilometraje'
        ]
        
        for field in allowed_fields:
            if field in data:
                update_fields.append(f"{field} = %s")
                params.append(data[field])
                
        if not update_fields:
            return jsonify({
                'success': False,
                'message': 'No se proporcionaron campos para actualizar'
            }), 400
            
        params.append(vehiculo_id)
        
        query = f"UPDATE parque_automotor SET {', '.join(update_fields)} WHERE id_parque_automotor = %s"
        cursor.execute(query, params)
        
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Vehículo actualizado exitosamente'
        })
        
    except Exception as e:
        print(f"Error en API actualizar vehículo: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al actualizar vehículo: {str(e)}'
        }), 500

@app.route('/api/vehiculos/<int:vehiculo_id>', methods=['DELETE'])
@login_required()
@role_required('logistica')
def api_eliminar_vehiculo(vehiculo_id):
    """Eliminar un vehículo (cambiar estado a Inactivo)"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Verificar si el vehículo existe
        cursor.execute('SELECT id_parque_automotor FROM parque_automotor WHERE id_parque_automotor = %s', (vehiculo_id,))
        if not cursor.fetchone():
            return jsonify({
                'success': False,
                'message': 'El vehículo no existe'
            }), 404
            
        # Cambiar estado a Inactivo en lugar de eliminar físicamente
        cursor.execute('UPDATE parque_automotor SET estado = %s WHERE id_parque_automotor = %s', 
                      ('Inactivo', vehiculo_id))
        
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Vehículo eliminado exitosamente'
        })
        
    except Exception as e:
        print(f"Error en API eliminar vehículo: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al eliminar vehículo: {str(e)}'
        }), 500

@app.route('/api/vehiculos/dashboard', methods=['GET'])
@login_required()
@role_required('logistica')
def api_dashboard_vehiculos():
    """Obtener estadísticas del dashboard de vehículos"""
    try:
        print("Dashboard: Intentando obtener conexión a la base de datos...")
        connection = get_db_connection()
        if connection is None:
            print("Dashboard: La conexión es None")
            return jsonify({
                'success': False,
                'message': 'MySQL Connection not available'
            }), 500
        print("Dashboard: Conexión obtenida exitosamente")
            
        cursor = connection.cursor(dictionary=True)
        
        # Estadísticas generales
        cursor.execute("""
            SELECT 
                COUNT(*) as total_vehiculos,
                SUM(CASE WHEN estado = 'Activo' THEN 1 ELSE 0 END) as vehiculos_activos,
                SUM(CASE WHEN estado = 'Mantenimiento' THEN 1 ELSE 0 END) as vehiculos_mantenimiento,
                SUM(CASE WHEN estado = 'Inactivo' THEN 1 ELSE 0 END) as vehiculos_inactivos
            FROM parque_automotor
        """)
        estadisticas = cursor.fetchone()
        
        # Alertas de vencimiento
        cursor.execute("""
            SELECT 
                SUM(CASE WHEN soat_vencimiento <= CURDATE() THEN 1 ELSE 0 END) as soat_vencidos,
                SUM(CASE WHEN soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) AND soat_vencimiento > CURDATE() THEN 1 ELSE 0 END) as soat_por_vencer,
                SUM(CASE WHEN tecnomecanica_vencimiento <= CURDATE() THEN 1 ELSE 0 END) as tecnomecanica_vencidos,
                SUM(CASE WHEN tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) AND tecnomecanica_vencimiento > CURDATE() THEN 1 ELSE 0 END) as tecnomecanica_por_vencer
            FROM parque_automotor
            WHERE estado = 'Activo'
        """)
        alertas = cursor.fetchone()
        
        # Distribución por tipo de vehículo
        cursor.execute("""
            SELECT tipo_vehiculo, COUNT(*) as cantidad
            FROM parque_automotor
            WHERE estado = 'Activo'
            GROUP BY tipo_vehiculo
            ORDER BY cantidad DESC
        """)
        tipos_vehiculo = cursor.fetchall()
        
        # Obtener alertas recientes para mostrar en el dashboard
        cursor.execute("""
            SELECT 
                placa,
                'SOAT' as tipo_documento,
                soat_vencimiento as fecha_vencimiento,
                CASE 
                    WHEN soat_vencimiento <= CURDATE() THEN 'vencido'
                    ELSE 'por_vencer'
                END as tipo_alerta
            FROM parque_automotor 
            WHERE estado = 'Activo' 
                AND soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY)
            UNION ALL
            SELECT 
                placa,
                'Tecnomecánica' as tipo_documento,
                tecnomecanica_vencimiento as fecha_vencimiento,
                CASE 
                    WHEN tecnomecanica_vencimiento <= CURDATE() THEN 'vencido'
                    ELSE 'por_vencer'
                END as tipo_alerta
            FROM parque_automotor 
            WHERE estado = 'Activo' 
                AND tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY)
            ORDER BY fecha_vencimiento ASC
            LIMIT 10
        """)
        alertas_recientes = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        # Calcular totales de vencimientos
        documentos_vencidos = (alertas['soat_vencidos'] or 0) + (alertas['tecnomecanica_vencidos'] or 0)
        vencimientos_proximos = (alertas['soat_por_vencer'] or 0) + (alertas['tecnomecanica_por_vencer'] or 0)
        
        return jsonify({
            'total_vehiculos': estadisticas['total_vehiculos'] or 0,
            'vehiculos_activos': estadisticas['vehiculos_activos'] or 0,
            'vencimientos_proximos': vencimientos_proximos,
            'documentos_vencidos': documentos_vencidos,
            'alertas_recientes': alertas_recientes,
            'tipos_vehiculo': tipos_vehiculo
        })
        
    except Exception as e:
        print(f"Error en API dashboard vehículos: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'message': f'Error al obtener estadísticas: {str(e)}'
        }), 500

@app.route('/api/vehiculos/graficos', methods=['GET'])
def api_vehiculos_graficos():
    # Verificar autenticación
    if 'user_id' not in session:
        return jsonify({
            'success': False,
            'message': 'Autenticación requerida'
        }), 401
    
    # Verificar rol
    user_role = session.get('user_role')
    if user_role not in ['logistica', 'administrativo']:
        return jsonify({
            'success': False,
            'message': 'Permisos insuficientes'
        }), 403
    """Obtener datos para gráficos del módulo de vehículos"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'MySQL Connection not available'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Datos para gráfico de tipos de vehículo
        cursor.execute("""
            SELECT tipo_vehiculo, COUNT(*) as cantidad
            FROM parque_automotor
            WHERE estado = 'Activo'
            GROUP BY tipo_vehiculo
            ORDER BY cantidad DESC
        """)
        tipo_vehiculo = cursor.fetchall()
        
        # Datos para gráfico de estado de documentos
        cursor.execute("""
            SELECT 
                'SOAT Vigente' as estado,
                COUNT(*) as cantidad
            FROM parque_automotor 
            WHERE estado = 'Activo' AND soat_vencimiento > CURDATE()
            UNION ALL
            SELECT 
                'SOAT Vencido' as estado,
                COUNT(*) as cantidad
            FROM parque_automotor 
            WHERE estado = 'Activo' AND soat_vencimiento <= CURDATE()
            UNION ALL
            SELECT 
                'Tecnomecánica Vigente' as estado,
                COUNT(*) as cantidad
            FROM parque_automotor 
            WHERE estado = 'Activo' AND tecnomecanica_vencimiento > CURDATE()
            UNION ALL
            SELECT 
                'Tecnomecánica Vencida' as estado,
                COUNT(*) as cantidad
            FROM parque_automotor 
            WHERE estado = 'Activo' AND tecnomecanica_vencimiento <= CURDATE()
        """)
        estado_documentos = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'tipo_vehiculo': tipo_vehiculo,
            'estado_documentos': estado_documentos
        })
        
    except Exception as e:
        print(f"Error en API gráficos vehículos: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener datos de gráficos: {str(e)}'
        }), 500

@app.route('/api/vehiculos/plantilla', methods=['GET'])
@login_required()
@role_required('logistica')
def api_descargar_plantilla_vehiculos():
    """Generar y descargar plantilla Excel para importar vehículos"""
    try:
        import pandas as pd
        import io
        from flask import send_file
        
        # Definir las columnas de la plantilla
        columns = [
            'placa',
            'tipo_vehiculo', 
            'marca',
            'modelo',
            'color',
            'soat_vencimiento',
            'tecnomecanica_vencimiento',
            'observaciones',
            'kilometraje_actual',
            'proximo_mantenimiento_km'
        ]
        
        # Crear DataFrame con ejemplos
        data = {
            'placa': ['ABC123', 'XYZ789'],
            'tipo_vehiculo': ['Moto', 'Carro'],
            'marca': ['Honda', 'Toyota'],
            'modelo': ['CB150', 'Corolla'],
            'color': ['Rojo', 'Blanco'],
            'soat_vencimiento': ['2024-12-31', '2024-11-30'],
            'tecnomecanica_vencimiento': ['2024-10-15', '2024-09-20'],
            'observaciones': ['Ejemplo de observación', ''],
            'kilometraje_actual': [15000, 25000],
            'proximo_mantenimiento_km': [20000, 30000]
        }
        
        df = pd.DataFrame(data)
        
        # Crear archivo Excel en memoria
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # Escribir datos de ejemplo
            df.to_excel(writer, sheet_name='Vehículos', index=False)
            
            # Crear hoja de instrucciones
            instrucciones = pd.DataFrame({
                'INSTRUCCIONES PARA IMPORTAR VEHÍCULOS': [
                    '1. Complete todas las columnas obligatorias marcadas con *',
                    '2. Las fechas deben estar en formato YYYY-MM-DD (ej: 2024-12-31)',
                    '3. Los tipos de vehículo válidos son: Moto, Carro, Camioneta, Camión',
                    '4. La placa debe ser única en el sistema',
                    '5. Elimine las filas de ejemplo antes de importar',
                    '6. Guarde el archivo en formato Excel (.xlsx)',
                    '',
                    'COLUMNAS OBLIGATORIAS:',
                    '- placa *',
                    '- tipo_vehiculo *', 
                    '- marca *',
                    '- modelo *',
                    '- color *',
                    '',
                    'COLUMNAS OPCIONALES:',
                    '- soat_vencimiento (formato: YYYY-MM-DD)',
                    '- tecnomecanica_vencimiento (formato: YYYY-MM-DD)',
                    '- observaciones',
                    '- kilometraje_actual (número)',
                    '- proximo_mantenimiento_km (número)'
                ]
            })
            instrucciones.to_excel(writer, sheet_name='Instrucciones', index=False)
        
        output.seek(0)
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name='plantilla_vehiculos.xlsx'
        )
        
    except ImportError:
        return jsonify({
            'success': False,
            'message': 'La librería pandas no está instalada. Contacte al administrador.'
        }), 500
        
    except Exception as e:
        print(f"Error al generar plantilla: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al generar plantilla: {str(e)}'
        }), 500

@app.route('/api/vehiculos/importar', methods=['POST'])
@login_required()
@role_required('logistica')
def api_importar_vehiculos():
    """Importar vehículos desde archivo Excel"""
    try:
        if 'archivo' not in request.files:
            return jsonify({
                'success': False,
                'message': 'No se encontró el archivo'
            }), 400
            
        archivo = request.files['archivo']
        
        if archivo.filename == '':
            return jsonify({
                'success': False,
                'message': 'No se seleccionó ningún archivo'
            }), 400
            
        if not archivo.filename.endswith(('.xlsx', '.xls')):
            return jsonify({
                'success': False,
                'message': 'El archivo debe ser de formato Excel (.xlsx o .xls)'
            }), 400
            
        try:
            import pandas as pd
            import io
            
            # Leer el archivo Excel
            df = pd.read_excel(io.BytesIO(archivo.read()))
            
            # Validar columnas requeridas
            required_columns = ['placa', 'tipo_vehiculo', 'marca', 'modelo', 'color']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                return jsonify({
                    'success': False,
                    'message': f'Faltan las siguientes columnas: {", ".join(missing_columns)}'
                }), 400
                
            connection = get_db_connection()
            if connection is None:
                return jsonify({
                    'success': False,
                    'message': 'Error de conexión a la base de datos'
                }), 500
                
            cursor = connection.cursor(dictionary=True)
            
            vehiculos_insertados = 0
            vehiculos_error = []
            
            for index, row in df.iterrows():
                try:
                    # Verificar si la placa ya existe
                    cursor.execute('SELECT placa FROM parque_automotor WHERE placa = %s', (row['placa'],))
                    if cursor.fetchone():
                        vehiculos_error.append({
                            'fila': index + 2,  # +2 porque Excel empieza en 1 y hay header
                            'placa': row['placa'],
                            'error': 'La placa ya existe'
                        })
                        continue
                        
                    # Insertar vehículo
                    cursor.execute("""
                        INSERT INTO parque_automotor (
                            placa, tipo_vehiculo, marca, modelo, color, 
                            id_codigo_consumidor, fecha_asignacion, estado,
                            soat_vencimiento, tecnomecanica_vencimiento, observaciones,
                            kilometraje_actual, proximo_mantenimiento_km
                        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    """, (
                        row['placa'],
                        row['tipo_vehiculo'],
                        row['marca'],
                        row['modelo'],
                        row['color'],
                        row.get('id_codigo_consumidor'),
                        row.get('fecha_asignacion'),
                        row.get('estado', 'Activo'),
                        row.get('soat_vencimiento'),
                        row.get('tecnomecanica_vencimiento'),
                        row.get('observaciones'),
                        row.get('kilometraje_actual', 0),
                        row.get('proximo_mantenimiento_km')
                    ))
                    
                    vehiculos_insertados += 1
                    
                except Exception as e:
                    vehiculos_error.append({
                        'fila': index + 2,
                        'placa': row.get('placa', 'N/A'),
                        'error': str(e)
                    })
                    
            connection.commit()
            cursor.close()
            connection.close()
            
            return jsonify({
                'success': True,
                'message': f'Importación completada. {vehiculos_insertados} vehículos insertados.',
                'data': {
                    'vehiculos_insertados': vehiculos_insertados,
                    'vehiculos_error': vehiculos_error
                }
            })
            
        except ImportError:
            return jsonify({
                'success': False,
                'message': 'La librería pandas no está instalada. Contacte al administrador.'
            }), 500
            
        except Exception as e:
            return jsonify({
                'success': False,
                'message': f'Error al procesar el archivo: {str(e)}'
            }), 500
            
    except Exception as e:
        print(f"Error en API importar vehículos: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al importar vehículos: {str(e)}'
        }), 500

@app.route('/api/vehiculos/alertas', methods=['GET'])
@login_required()
@role_required('logistica')
def api_alertas_vencimiento():
    """Obtener alertas de vencimiento de documentos"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Parámetros de filtro
        tipo_alerta = request.args.get('tipo')  # 'soat', 'tecnomecanica', 'all'
        estado_alerta = request.args.get('estado')  # 'vencido', 'por_vencer', 'all'
        dias_anticipacion = int(request.args.get('dias', 30))
        
        # Construir consulta base
        query = """
            SELECT 
                pa.id_parque_automotor,
                pa.placa,
                pa.tipo_vehiculo,
                pa.marca,
                pa.modelo,
                r.nombre as tecnico_nombre,
                pa.soat_vencimiento,
                pa.tecnomecanica_vencimiento,
                CASE 
                    WHEN pa.soat_vencimiento <= CURDATE() THEN 'vencido'
                    WHEN pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY) THEN 'por_vencer'
                    ELSE 'vigente'
                END as estado_soat,
                CASE 
                    WHEN pa.tecnomecanica_vencimiento <= CURDATE() THEN 'vencido'
                    WHEN pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY) THEN 'por_vencer'
                    ELSE 'vigente'
                END as estado_tecnomecanica,
                DATEDIFF(pa.soat_vencimiento, CURDATE()) as dias_soat,
                DATEDIFF(pa.tecnomecanica_vencimiento, CURDATE()) as dias_tecnomecanica
            FROM parque_automotor pa
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE pa.estado = 'Activo'
        """
        
        params = [dias_anticipacion, dias_anticipacion]
        
        # Filtros adicionales
        conditions = []
        
        if tipo_alerta == 'soat':
            conditions.append("(pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY))")
            params.append(dias_anticipacion)
        elif tipo_alerta == 'tecnomecanica':
            conditions.append("(pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY))")
            params.append(dias_anticipacion)
        else:  # 'all' o no especificado
            conditions.append("(pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY) OR pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY))")
            params.extend([dias_anticipacion, dias_anticipacion])
            
        if estado_alerta == 'vencido':
            conditions.append("(pa.soat_vencimiento <= CURDATE() OR pa.tecnomecanica_vencimiento <= CURDATE())")
        elif estado_alerta == 'por_vencer':
            conditions.append("(pa.soat_vencimiento > CURDATE() AND pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)) OR (pa.tecnomecanica_vencimiento > CURDATE() AND pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY))")
            params.extend([dias_anticipacion, dias_anticipacion])
            
        if conditions:
            query += " AND (" + " AND ".join(conditions) + ")"
            
        query += " ORDER BY pa.soat_vencimiento ASC, pa.tecnomecanica_vencimiento ASC"
        
        cursor.execute(query, params)
        alertas = cursor.fetchall()
        
        # Convertir fechas para serialización JSON y estructurar alertas
        alertas_estructuradas = []
        
        for vehiculo in alertas:
            # Convertir fechas
            if vehiculo['soat_vencimiento']:
                vehiculo['soat_vencimiento'] = vehiculo['soat_vencimiento'].isoformat()
            if vehiculo['tecnomecanica_vencimiento']:
                vehiculo['tecnomecanica_vencimiento'] = vehiculo['tecnomecanica_vencimiento'].isoformat()
                
            # Crear alertas individuales para SOAT y Tecnomecánica
            if (tipo_alerta in ['soat', 'all'] and 
                vehiculo['estado_soat'] in ['vencido', 'por_vencer']):
                alertas_estructuradas.append({
                    'id_vehiculo': vehiculo['id_parque_automotor'],
                    'placa': vehiculo['placa'],
                    'tipo_vehiculo': vehiculo['tipo_vehiculo'],
                    'marca': vehiculo['marca'],
                    'modelo': vehiculo['modelo'],
                    'tecnico_nombre': vehiculo['tecnico_nombre'],
                    'tipo_documento': 'SOAT',
                    'fecha_vencimiento': vehiculo['soat_vencimiento'],
                    'estado': vehiculo['estado_soat'],
                    'dias_restantes': vehiculo['dias_soat']
                })
                
            if (tipo_alerta in ['tecnomecanica', 'all'] and 
                vehiculo['estado_tecnomecanica'] in ['vencido', 'por_vencer']):
                alertas_estructuradas.append({
                    'id_vehiculo': vehiculo['id_parque_automotor'],
                    'placa': vehiculo['placa'],
                    'tipo_vehiculo': vehiculo['tipo_vehiculo'],
                    'marca': vehiculo['marca'],
                    'modelo': vehiculo['modelo'],
                    'tecnico_nombre': vehiculo['tecnico_nombre'],
                    'tipo_documento': 'Tecnomecánica',
                    'fecha_vencimiento': vehiculo['tecnomecanica_vencimiento'],
                    'estado': vehiculo['estado_tecnomecanica'],
                    'dias_restantes': vehiculo['dias_tecnomecanica']
                })
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': alertas_estructuradas,
            'total': len(alertas_estructuradas)
        })
        
    except Exception as e:
        print(f"Error en API alertas vencimiento: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener alertas: {str(e)}'
        }), 500

@app.route('/api/vehiculos/vencimientos', methods=['GET'])
@login_required()
@role_required('logistica')
def api_vencimientos_vehiculos():
    """Obtener datos de vencimientos para la tabla de vencimientos"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Parámetros de filtro
        dias_anticipacion = int(request.args.get('dias', 30))
        tipo_documento = request.args.get('tipo')  # 'soat', 'tecnomecanica', 'all'
        
        # Consulta para obtener vencimientos
        query = """
            SELECT 
                pa.id_parque_automotor,
                pa.placa,
                pa.tipo_vehiculo,
                pa.marca,
                pa.modelo,
                r.nombre as tecnico_nombre,
                pa.soat_vencimiento,
                pa.tecnomecanica_vencimiento,
                DATEDIFF(pa.soat_vencimiento, CURDATE()) as dias_soat,
                DATEDIFF(pa.tecnomecanica_vencimiento, CURDATE()) as dias_tecnomecanica
            FROM parque_automotor pa
            LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE pa.estado = 'Activo'
            AND (
                pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)
                OR pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)
            )
            ORDER BY 
                LEAST(
                    COALESCE(pa.soat_vencimiento, '9999-12-31'),
                    COALESCE(pa.tecnomecanica_vencimiento, '9999-12-31')
                ) ASC
        """
        
        cursor.execute(query, [dias_anticipacion, dias_anticipacion])
        vehiculos = cursor.fetchall()
        
        # Estructurar datos para la tabla de vencimientos
        vencimientos_data = []
        
        for vehiculo in vehiculos:
            # Procesar SOAT
            if (vehiculo['soat_vencimiento'] and 
                vehiculo['dias_soat'] <= dias_anticipacion):
                
                # Determinar estado del documento
                if vehiculo['dias_soat'] < 0:
                    estado = 'vencido'
                elif vehiculo['dias_soat'] <= 7:
                    estado = 'critico'
                elif vehiculo['dias_soat'] <= 30:
                    estado = 'proximo'
                else:
                    estado = 'vigente'
                
                vencimientos_data.append({
                    'placa': vehiculo['placa'],
                    'tipo_vehiculo': vehiculo['tipo_vehiculo'],
                    'tipo_documento': 'SOAT',
                    'fecha_vencimiento': vehiculo['soat_vencimiento'].isoformat() if vehiculo['soat_vencimiento'] else None,
                    'fecha_vencimiento_nueva': vehiculo['soat_vencimiento'].strftime('%Y-%m-%d') if vehiculo['soat_vencimiento'] else None,
                    'dias_restantes': vehiculo['dias_soat'],
                    'estado_documento': estado,
                    'tecnico_nombre': vehiculo['tecnico_nombre'],
                    'fecha_renovacion': None  # Se puede obtener del historial si existe
                })
            
            # Procesar Tecnomecánica
            if (vehiculo['tecnomecanica_vencimiento'] and 
                vehiculo['dias_tecnomecanica'] <= dias_anticipacion):
                
                # Determinar estado del documento
                if vehiculo['dias_tecnomecanica'] < 0:
                    estado = 'vencido'
                elif vehiculo['dias_tecnomecanica'] <= 7:
                    estado = 'critico'
                elif vehiculo['dias_tecnomecanica'] <= 30:
                    estado = 'proximo'
                else:
                    estado = 'vigente'
                
                vencimientos_data.append({
                    'placa': vehiculo['placa'],
                    'tipo_vehiculo': vehiculo['tipo_vehiculo'],
                    'tipo_documento': 'Tecnomecánica',
                    'fecha_vencimiento': vehiculo['tecnomecanica_vencimiento'].isoformat() if vehiculo['tecnomecanica_vencimiento'] else None,
                    'fecha_vencimiento_nueva': vehiculo['tecnomecanica_vencimiento'].strftime('%Y-%m-%d') if vehiculo['tecnomecanica_vencimiento'] else None,
                    'dias_restantes': vehiculo['dias_tecnomecanica'],
                    'estado_documento': estado,
                    'tecnico_nombre': vehiculo['tecnico_nombre'],
                    'fecha_renovacion': None  # Se puede obtener del historial si existe
                })
        
        # Filtrar por tipo de documento si se especifica
        if tipo_documento and tipo_documento != 'all':
            if tipo_documento == 'soat':
                vencimientos_data = [v for v in vencimientos_data if v['tipo_documento'] == 'SOAT']
            elif tipo_documento == 'tecnomecanica':
                vencimientos_data = [v for v in vencimientos_data if v['tipo_documento'] == 'Tecnomecánica']
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': vencimientos_data,
            'total': len(vencimientos_data)
        })
        
    except Exception as e:
        print(f"Error en API vencimientos: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener vencimientos: {str(e)}'
        }), 500

@app.route('/api/vehiculos/reportes', methods=['GET'])
@login_required()
@role_required('logistica')
def api_reportes_vehiculos():
    """Generar reportes de vehículos con filtros"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Parámetros de filtro
        tipo_reporte = request.args.get('tipo', 'general')  # 'general', 'vencimientos', 'mantenimiento'
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        estado = request.args.get('estado')
        tipo_vehiculo = request.args.get('tipo_vehiculo')
        
        if tipo_reporte == 'general':
            # Reporte general de vehículos
            query = """
                SELECT 
                    pa.*,
                    r.nombre as tecnico_nombre,
                    r.recurso_operativo_cedula,
                    CASE 
                        WHEN pa.soat_vencimiento <= CURDATE() THEN 'Vencido'
                        WHEN pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'Por vencer'
                        ELSE 'Vigente'
                    END as estado_soat,
                    CASE 
                        WHEN pa.tecnomecanica_vencimiento <= CURDATE() THEN 'Vencido'
                        WHEN pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'Por vencer'
                        ELSE 'Vigente'
                    END as estado_tecnomecanica
                FROM parque_automotor pa
                LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
                WHERE 1=1
            """
            
        elif tipo_reporte == 'vencimientos':
            # Reporte de vencimientos
            query = """
                SELECT 
                    pa.placa,
                    pa.tipo_vehiculo,
                    pa.marca,
                    pa.modelo,
                    r.nombre as tecnico_nombre,
                    pa.soat_vencimiento,
                    pa.tecnomecanica_vencimiento,
                    DATEDIFF(pa.soat_vencimiento, CURDATE()) as dias_soat,
                    DATEDIFF(pa.tecnomecanica_vencimiento, CURDATE()) as dias_tecnomecanica,
                    CASE 
                        WHEN pa.soat_vencimiento <= CURDATE() THEN 'Vencido'
                        WHEN pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'Por vencer'
                        ELSE 'Vigente'
                    END as estado_soat,
                    CASE 
                        WHEN pa.tecnomecanica_vencimiento <= CURDATE() THEN 'Vencido'
                        WHEN pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 30 DAY) THEN 'Por vencer'
                        ELSE 'Vigente'
                    END as estado_tecnomecanica
                FROM parque_automotor pa
                LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
                WHERE pa.estado = 'Activo'
                AND (pa.soat_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 60 DAY) 
                     OR pa.tecnomecanica_vencimiento <= DATE_ADD(CURDATE(), INTERVAL 60 DAY))
            """
            
        else:  # mantenimiento
            # Reporte de mantenimiento
            query = """
                SELECT 
                    pa.placa,
                    pa.tipo_vehiculo,
                    pa.marca,
                    pa.modelo,
                    pa.kilometraje_actual,
                    pa.proximo_mantenimiento_km,
                    r.nombre as tecnico_nombre,
                    CASE 
                        WHEN pa.proximo_mantenimiento_km IS NOT NULL AND pa.kilometraje_actual >= pa.proximo_mantenimiento_km THEN 'Mantenimiento requerido'
                        WHEN pa.proximo_mantenimiento_km IS NOT NULL AND (pa.proximo_mantenimiento_km - pa.kilometraje_actual) <= 1000 THEN 'Próximo mantenimiento'
                        ELSE 'Al día'
                    END as estado_mantenimiento
                FROM parque_automotor pa
                LEFT JOIN recurso_operativo r ON pa.id_codigo_consumidor = r.id_codigo_consumidor
                WHERE pa.estado = 'Activo'
            """
            
        # Aplicar filtros adicionales
        conditions = []
        params = []
        
        if fecha_inicio and fecha_fin:
            conditions.append("pa.fecha_asignacion BETWEEN %s AND %s")
            params.extend([fecha_inicio, fecha_fin])
            
        if estado:
            conditions.append("pa.estado = %s")
            params.append(estado)
            
        if tipo_vehiculo:
            conditions.append("pa.tipo_vehiculo = %s")
            params.append(tipo_vehiculo)
            
        if conditions:
            query += " AND " + " AND ".join(conditions)
            
        query += " ORDER BY pa.placa"
        
        cursor.execute(query, params)
        datos = cursor.fetchall()
        
        # Convertir fechas para serialización JSON
        for item in datos:
            for key, value in item.items():
                if isinstance(value, date):
                    item[key] = value.isoformat()
                    
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': datos,
            'tipo_reporte': tipo_reporte,
            'total_registros': len(datos)
        })
        
    except Exception as e:
        print(f"Error en API reportes vehículos: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al generar reporte: {str(e)}'
        }), 500

@app.route('/api/indicadores/tipos_vehiculos')
@login_required(role='administrativo')
@cache.cached(query_string=True, timeout=60)
def obtener_tipos_vehiculos():
    try:
        dias_param = request.args.get('dias', '30')
        try:
            dias = int(dias_param)
            if dias < 1:
                dias = 30
        except Exception:
            dias = 30

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)

        fecha_hasta = get_bogota_datetime().date()
        fecha_desde = fecha_hasta - timedelta(days=dias - 1)

        cursor.execute(
            """
            SELECT 
                COALESCE(pa.tipo_vehiculo, 'No especificado') AS tipo,
                COUNT(DISTINCT p.placa_vehiculo) AS cantidad
            FROM preoperacional p
            LEFT JOIN parque_automotor pa
              ON UPPER(REPLACE(REPLACE(TRIM(pa.placa), '-', ''), ' ', '')) = UPPER(REPLACE(REPLACE(TRIM(p.placa_vehiculo), '-', ''), ' ', ''))
            WHERE DATE(p.fecha) >= %s AND DATE(p.fecha) <= %s
            GROUP BY tipo
            ORDER BY cantidad DESC
            """,
            (fecha_desde, fecha_hasta)
        )
        tipos = cursor.fetchall() or []

        if not tipos:
            cursor.execute(
                """
                SELECT 
                    COALESCE(tipo_vehiculo, 'No especificado') AS tipo,
                    COUNT(*) AS cantidad
                FROM parque_automotor
                WHERE estado = 'Activo'
                GROUP BY tipo_vehiculo
                ORDER BY cantidad DESC
                """
            )
            tipos = cursor.fetchall() or []

        cursor.close()
        connection.close()

        tipos_vehiculos = [
            {'tipo': row.get('tipo') or 'No especificado', 'cantidad': int(row.get('cantidad') or 0)}
            for row in tipos
        ]

        return jsonify({
            'success': True,
            'tipos_vehiculos': tipos_vehiculos,
            'periodo': {
                'dias': dias,
                'desde': fecha_desde.strftime('%Y-%m-%d'),
                'hasta': fecha_hasta.strftime('%Y-%m-%d')
            }
        })

    except Exception as e:
        import traceback
        print(f"Error en tipos de vehículos: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/indicadores/estado_vehiculos')
@login_required(role='administrativo')
def obtener_estado_vehiculos():
    """Obtener estado de vehículos por supervisor basado en datos reales de la tabla preoperacional"""
    try:
        connection = get_db_connection()
        if connection is None:
            print("Error: No se pudo establecer conexión a la base de datos")
            return jsonify({
                'success': False,
                'error': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener parámetro de mes desde la URL (formato YYYY-MM)
        mes_param = request.args.get('mes')
        
        if mes_param:
            try:
                # Validar formato YYYY-MM
                año, mes = mes_param.split('-')
                año = int(año)
                mes = int(mes)
                
                if mes < 1 or mes > 12:
                    raise ValueError("Mes inválido")
                    
                primer_dia_mes = datetime(año, mes, 1).date()
                
                # Calcular último día del mes
                if mes == 12:
                    ultimo_dia_mes = datetime(año + 1, 1, 1).date() - timedelta(days=1)
                else:
                    ultimo_dia_mes = datetime(año, mes + 1, 1).date() - timedelta(days=1)
                    
            except (ValueError, IndexError):
                return jsonify({
                    'success': False,
                    'error': 'Formato de mes inválido. Use YYYY-MM'
                }), 400
        else:
            # Si no se especifica mes, usar el mes actual
            fecha_actual = get_bogota_datetime().date()
            primer_dia_mes = fecha_actual.replace(day=1)
            # Calcular último día del mes actual
            if fecha_actual.month == 12:
                ultimo_dia_mes = datetime(fecha_actual.year + 1, 1, 1).date() - timedelta(days=1)
            else:
                ultimo_dia_mes = datetime(fecha_actual.year, fecha_actual.month + 1, 1).date() - timedelta(days=1)
        
        print(f"Consultando estado de vehículos desde: {primer_dia_mes} hasta: {ultimo_dia_mes}")
        
        # Consultar preoperacionales del mes seleccionado con supervisores
        query = """
            SELECT 
                supervisor,
                estado_espejos,
                bocina_pito,
                frenos,
                encendido,
                estado_bateria,
                estado_amortiguadores,
                estado_llantas,
                luces_altas_bajas,
                direccionales_delanteras_traseras,
                estado_fisico_vehiculo_espejos,
                estado_fisico_vehiculo_bocina_pito,
                estado_fisico_vehiculo_frenos,
                estado_fisico_vehiculo_encendido,
                estado_fisico_vehiculo_bateria,
                estado_fisico_vehiculo_amortiguadores,
                estado_fisico_vehiculo_llantas,
                estado_fisico_vehiculo_luces_altas,
                estado_fisico_vehiculo_luces_bajas,
                estado_fisico_vehiculo_direccionales_delanteras,
                estado_fisico_vehiculo_direccionales_traseras
            FROM preoperacional 
            WHERE DATE(fecha) >= %s AND DATE(fecha) <= %s
                AND supervisor IS NOT NULL 
                AND supervisor != ''
        """
        
        cursor.execute(query, (primer_dia_mes, ultimo_dia_mes))
        preoperacionales = cursor.fetchall()
        
        print(f"Se encontraron {len(preoperacionales)} registros preoperacionales")
        
        # Agrupar por supervisor y clasificar vehículos
        supervisores_stats = {}
        
        for preop in preoperacionales:
            supervisor = preop['supervisor']
            
            if supervisor not in supervisores_stats:
                supervisores_stats[supervisor] = {
                    'bueno': 0,
                    'regular': 0,
                    'malo': 0,
                    'total': 0
                }
            
            # Campos a evaluar para determinar el estado del vehículo
            campos_estado = [
                'estado_espejos', 'bocina_pito', 'frenos', 'encendido', 'estado_bateria',
                'estado_amortiguadores', 'estado_llantas', 'luces_altas_bajas', 'direccionales_delanteras_traseras',
                'estado_fisico_vehiculo_espejos', 'estado_fisico_vehiculo_bocina_pito', 'estado_fisico_vehiculo_frenos',
                'estado_fisico_vehiculo_encendido', 'estado_fisico_vehiculo_bateria', 'estado_fisico_vehiculo_amortiguadores',
                'estado_fisico_vehiculo_llantas', 'estado_fisico_vehiculo_luces_altas', 'estado_fisico_vehiculo_luces_bajas',
                'estado_fisico_vehiculo_direccionales_delanteras', 'estado_fisico_vehiculo_direccionales_traseras'
            ]
            
            # Contar estados buenos, regulares y malos
            buenos = 0
            regulares = 0
            malos = 0
            total_campos = 0
            
            for campo in campos_estado:
                valor = preop.get(campo)
                if valor is not None and valor != '':
                    total_campos += 1
                    valor_lower = str(valor).lower().strip()
                    
                    if valor_lower in ['bueno', 'good', 'si', 'sí', 'yes', '1', 'ok']:
                        buenos += 1
                    elif valor_lower in ['regular', 'medio', 'parcial', 'partial']:
                        regulares += 1
                    elif valor_lower in ['malo', 'bad', 'no', '0', 'dañado', 'defectuoso']:
                        malos += 1
            
            # Clasificar el vehículo basado en el porcentaje de componentes en buen estado
            if total_campos > 0:
                porcentaje_bueno = (buenos / total_campos) * 100
                porcentaje_malo = (malos / total_campos) * 100
                
                if porcentaje_bueno >= 80:  # 80% o más componentes buenos
                    supervisores_stats[supervisor]['bueno'] += 1
                elif porcentaje_malo >= 30:  # 30% o más componentes malos
                    supervisores_stats[supervisor]['malo'] += 1
                else:  # Estado intermedio
                    supervisores_stats[supervisor]['regular'] += 1
            else:
                # Si no hay datos, clasificar como regular
                supervisores_stats[supervisor]['regular'] += 1
            
            supervisores_stats[supervisor]['total'] += 1
        
        # Convertir a formato de respuesta
        estadisticas = []
        for supervisor, stats in supervisores_stats.items():
            estadisticas.append({
                'supervisor': supervisor,
                'bueno': stats['bueno'],
                'regular': stats['regular'],
                'malo': stats['malo'],
                'total': stats['total']
            })
        
        # Ordenar por total descendente
        estadisticas.sort(key=lambda x: x['total'], reverse=True)
        
        print(f"Se calcularon estadísticas para {len(estadisticas)} supervisores")
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'estadisticas': estadisticas,
            'periodo': {
                'mes': primer_dia_mes.strftime('%Y-%m'),
                'desde': primer_dia_mes.strftime('%Y-%m-%d'),
                'hasta': ultimo_dia_mes.strftime('%Y-%m-%d')
            }
        })
        
    except Exception as e:
        import traceback
        print(f"Error en estado de vehículos: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/indicadores/cumplimiento_trimestral_anual')
@login_required(role='administrativo')
@cache.cached(query_string=True, timeout=60)
def obtener_indicadores_trimestral_anual():
    try:
        ensure_indicator_indexes()
        anio_param = request.args.get('anio')
        try:
            if anio_param and len(anio_param) == 4 and anio_param.isdigit():
                anio = int(anio_param)
            else:
                anio = get_bogota_datetime().year
        except Exception:
            anio = get_bogota_datetime().year
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        query_asistencia = (
            """
            SELECT QUARTER(a.fecha_asistencia) AS trimestre, COUNT(*) AS total_asistencia
            FROM asistencia a
            JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN recurso_operativo ro ON ro.recurso_operativo_cedula = a.cedula
            LEFT JOIN preoperacional_excepciones e ON e.activo = 1
                AND DATE(a.fecha_asistencia) BETWEEN COALESCE(e.fecha_inicio, e.fecha) AND COALESCE(e.fecha_fin, e.fecha)
                AND (e.cedula = a.cedula OR e.id_codigo_consumidor = ro.id_codigo_consumidor)
            WHERE YEAR(a.fecha_asistencia) = %s
              AND t.valor = '1'
              AND e.id IS NULL
              AND IFNULL(ro.excluido_preoperacional, 0) = 0
            GROUP BY trimestre
            ORDER BY trimestre
            """
        )
        cursor.execute(query_asistencia, (anio,))
        filas_asistencia = cursor.fetchall() or []
        query_preop = (
            """
            SELECT QUARTER(p.fecha) AS trimestre, COUNT(*) AS total_preoperacional
            FROM preoperacional p
            INNER JOIN asistencia a ON p.id_codigo_consumidor = a.id_codigo_consumidor AND DATE(p.fecha) = DATE(a.fecha_asistencia)
            INNER JOIN tipificacion_asistencia t ON a.carpeta_dia = t.codigo_tipificacion
            LEFT JOIN preoperacional_excepciones e ON e.activo = 1
                AND DATE(p.fecha) BETWEEN COALESCE(e.fecha_inicio, e.fecha) AND COALESCE(e.fecha_fin, e.fecha)
                AND (e.id_codigo_consumidor = p.id_codigo_consumidor)
            LEFT JOIN recurso_operativo ro ON ro.id_codigo_consumidor = p.id_codigo_consumidor
            WHERE YEAR(p.fecha) = %s
              AND t.valor = '1'
              AND e.id IS NULL
              AND IFNULL(ro.excluido_preoperacional, 0) = 0
            GROUP BY trimestre
            ORDER BY trimestre
            """
        )
        cursor.execute(query_preop, (anio,))
        filas_preop = cursor.fetchall() or []
        mapa_asistencia = {int(r['trimestre']): int(r['total_asistencia']) for r in filas_asistencia if r.get('trimestre') is not None}
        mapa_preop = {int(r['trimestre']): int(r['total_preoperacional']) for r in filas_preop if r.get('trimestre') is not None}
        trimestral = []
        total_asistencia = 0
        total_preop = 0
        for t in [1, 2, 3, 4]:
            ta = mapa_asistencia.get(t, 0)
            tp = mapa_preop.get(t, 0)
            total_asistencia += ta
            total_preop += tp
            porcentaje = (tp * 100.0 / ta) if ta > 0 else 0.0
            trimestral.append({
                'trimestre': t,
                'asistencia': ta,
                'preoperacional': tp,
                'porcentaje': porcentaje
            })
        anual = {
            'total_asistencia': total_asistencia,
            'total_preoperacional': total_preop,
            'porcentaje': (total_preop * 100.0 / total_asistencia) if total_asistencia > 0 else 0.0
        }
        cursor.close()
        connection.close()
        return jsonify({'success': True, 'anio': anio, 'trimestral': trimestral, 'anual': anual})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
# APIs para Presupuesto
@app.route('/api/lider/presupuesto', methods=['GET'])
@login_required_lider_api()
def api_lider_presupuesto():
    """
    API para obtener datos de presupuesto mensual por supervisor.
    Devuelve estructura compatible con el frontend:
    {
        success: true,
        presupuestos: [{supervisor, mes, ano, presupuesto_mensual, registros}],
        resumen: {total, promedio, supervisores, mayor},
        total_registros: N
    }
    """
    connection = None
    cursor = None
    try:
        # Obtener parámetros de filtro opcionales
        mes = request.args.get('mes')
        # Aceptar 'ano' y también 'año' por compatibilidad
        ano = request.args.get('ano') or request.args.get('año')
        supervisor = request.args.get('supervisor')

        # Convertir tipos cuando sea posible
        try:
            mes = int(mes) if mes is not None and mes != '' else None
        except Exception:
            mes = None
        try:
            ano = int(ano) if ano is not None and ano != '' else None
        except Exception:
            ano = None

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)

        # Construir consulta SQL base
        sql = """
            SELECT 
                super AS supervisor,
                MONTH(fecha_asistencia) AS mes,
                YEAR(fecha_asistencia) AS ano,
                SUM(valor) AS presupuesto_mensual,
                COUNT(*) AS registros
            FROM asistencia 
            WHERE super IS NOT NULL AND super != ''
        """

        params = []

        # Agregar filtros opcionales
        if mes is not None:
            sql += " AND MONTH(fecha_asistencia) = %s"
            params.append(mes)

        if ano is not None:
            sql += " AND YEAR(fecha_asistencia) = %s"
            params.append(ano)

        if supervisor:
            sql += " AND super = %s"
            params.append(supervisor)

        # Agrupar por supervisor, mes y año
        sql += """
            GROUP BY super, MONTH(fecha_asistencia), YEAR(fecha_asistencia)
            ORDER BY super, ano DESC, mes DESC
        """

        cursor.execute(sql, params)
        resultados = cursor.fetchall()

        # Formatear resultados y calcular resumen
        presupuestos = []
        total = 0.0
        mayor = 0.0
        supervisores_set = set()

        for row in resultados:
            presupuesto_mensual = float(row['presupuesto_mensual']) if row.get('presupuesto_mensual') is not None else 0.0
            presupuestos.append({
                'supervisor': row.get('supervisor') or '',
                'mes': row.get('mes') or 0,
                'ano': row.get('ano') or 0,
                'presupuesto_mensual': presupuesto_mensual,
                'registros': int(row.get('registros') or 0)
            })
            total += presupuesto_mensual
            mayor = max(mayor, presupuesto_mensual)
            if row.get('supervisor'):
                supervisores_set.add(row['supervisor'])

        total_supervisores = len(supervisores_set)
        promedio = total / total_supervisores if total_supervisores > 0 else 0.0

        return jsonify({
            'success': True,
            'presupuestos': presupuestos,
            'resumen': {
                'total': total,
                'promedio': promedio,
                'supervisores': total_supervisores,
                'mayor': mayor
            },
            'total_registros': len(presupuestos)
        })

    except mysql.connector.Error as e:
        print(f"ERROR DB - API Presupuesto: {str(e)}")
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - API Presupuesto: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/lider/presupuesto/supervisores', methods=['GET'])
@login_required_lider_api()
def api_lider_presupuesto_supervisores():
    """
    API para obtener lista de supervisores únicos de la tabla asistencia
    """
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener supervisores únicos
        cursor.execute("""
            SELECT DISTINCT super as supervisor
            FROM asistencia 
            WHERE super IS NOT NULL AND super != ''
            ORDER BY super
        """)
        
        resultados = cursor.fetchall()
        
        # Extraer solo los nombres de supervisores
        supervisores = [row['supervisor'] for row in resultados]
        
        return jsonify({
            'success': True,
            'supervisores': supervisores,
            'total': len(supervisores)
        })
        
    except mysql.connector.Error as e:
        print(f"ERROR DB - API Supervisores Presupuesto: {str(e)}")
        return jsonify({'error': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        print(f"ERROR - API Supervisores Presupuesto: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': f'Error interno: {str(e)}'}), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Rutas para el módulo de historial de seriales
@app.route('/logistica/historial_seriales')
@login_required()
@role_required('logistica')
def historial_seriales():
    """Página principal del módulo de historial de seriales"""
    return render_template('modulos/logistica/historial_seriales.html')

# Submódulo: Seriales Inversa
def ensure_seriales_inversa_table():
    try:
        conn = get_db_connection()
        if not conn:
            return
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS seriales_inversa (
                id INT AUTO_INCREMENT PRIMARY KEY,
                lapso VARCHAR(32),
                recurso_operativo_cedula VARCHAR(32),
                cuenta VARCHAR(64),
                dia INT,
                mes INT,
                descripcion TEXT,
                observacion_diana TEXT,
                serial_rr VARCHAR(128),
                tecnico VARCHAR(128),
                super VARCHAR(128),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_serial_rr (serial_rr),
                INDEX idx_cuenta (cuenta),
                INDEX idx_cedula (recurso_operativo_cedula)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        conn.commit()
        cur.close(); conn.close()
    except Exception:
        pass

ensure_seriales_inversa_table()

def ensure_seriales_inversa_unlocks_table():
    try:
        conn = get_db_connection()
        if not conn:
            return
        cur = conn.cursor()
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS seriales_inversa_unlocks (
                id INT AUTO_INCREMENT PRIMARY KEY,
                cedula VARCHAR(32) NOT NULL,
                expires_at TIMESTAMP NOT NULL,
                extension_days INT NOT NULL DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_cedula (cedula),
                INDEX idx_expires (expires_at)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        conn.commit()
        try:
            cur_cols = conn.cursor()
            cur_cols.execute("SHOW COLUMNS FROM seriales_inversa_unlocks")
            existing = {str(r[0]).strip().lower() for r in cur_cols.fetchall()}
            cur_cols.close()
            if 'granted_by_id' not in existing:
                cur.execute("ALTER TABLE seriales_inversa_unlocks ADD COLUMN granted_by_id VARCHAR(32) NULL")
            if 'granted_by_name' not in existing:
                cur.execute("ALTER TABLE seriales_inversa_unlocks ADD COLUMN granted_by_name VARCHAR(128) NULL")
            if 'granted_by_role' not in existing:
                cur.execute("ALTER TABLE seriales_inversa_unlocks ADD COLUMN granted_by_role VARCHAR(64) NULL")
            conn.commit()
        except Exception:
            pass
        cur.close(); conn.close()
    except Exception:
        pass

ensure_seriales_inversa_unlocks_table()

@app.route('/logistica/seriales_inversa')
@login_required()
@role_required('logistica')
def logistica_seriales_inversa():
    return render_template('modulos/logistica/seriales_inversa.html')

@app.route('/logistica/seriales_inversa/upload', methods=['POST'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_upload():
    connection = None
    cursor = None
    try:
        if 'archivo' not in request.files:
            return jsonify({'success': False, 'message': 'No se ha seleccionado ningún archivo'})
        archivo = request.files['archivo']
        if archivo.filename == '':
            return jsonify({'success': False, 'message': 'No se ha seleccionado ningún archivo'})
        extension = archivo.filename.lower().split('.')[-1]
        if extension not in ['csv', 'xlsx', 'xls']:
            return jsonify({'success': False, 'message': 'Formato no soportado. Use CSV o Excel'})
        datos = []
        try:
            if extension == 'csv':
                contenido_bytes = archivo.read()
                contenido = None
                for enc in ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']:
                    try:
                        contenido = contenido_bytes.decode(enc)
                        break
                    except Exception:
                        continue
                if contenido is None:
                    return jsonify({'success': False, 'message': 'No se pudo decodificar el archivo CSV'})
                reader = csv.DictReader(io.StringIO(contenido))
                datos = list(reader)
            else:
                df = pd.read_excel(archivo)
                datos = df.to_dict('records')
        except Exception as e:
            return jsonify({'success': False, 'message': f'Error al leer el archivo: {str(e)}'})
        if not datos:
            return jsonify({'success': False, 'message': 'El archivo está vacío o no contiene datos válidos'})
        columnas_requeridas = ['lapso','recurso_operativo_cedula','cuenta','dia','mes','descripcion','observacion_diana','serial_rr','tecnico','super']
        columnas_archivo = list(datos[0].keys())
        faltantes = [c for c in columnas_requeridas if c not in columnas_archivo]
        if faltantes:
            return jsonify({'success': False, 'message': 'Faltan columnas: ' + ', '.join(faltantes)})
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})
        cursor = connection.cursor()
        procesados = 0
        insertados = 0
        actualizados = 0
        omitidos_iguales = 0
        pk_col_name = None
        try:
            curp = connection.cursor(dictionary=True)
            curp.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'id'")
            if curp.fetchone():
                pk_col_name = 'id'
            else:
                curp.execute("SHOW KEYS FROM seriales_inversa WHERE Key_name='PRIMARY'")
                pk = curp.fetchone()
                if pk and pk.get('Column_name'):
                    pk_col_name = pk['Column_name']
                else:
                    for alt in ('id_inversa','id_seriales_inversa','idseriales_inversa'):
                        curp.execute(f"SHOW COLUMNS FROM seriales_inversa LIKE '{alt}'")
                        if curp.fetchone():
                            pk_col_name = alt
                            break
            curp.close()
        except Exception:
            pk_col_name = None
        for i, fila in enumerate(datos, 1):
            try:
                lapso = str(fila.get('lapso', '')).strip()
                cedula = str(fila.get('recurso_operativo_cedula', '')).strip()
                cuenta = str(fila.get('cuenta', '')).strip()
                dia = fila.get('dia')
                mes = fila.get('mes')
                descripcion = str(fila.get('descripcion', '')).strip()
                observacion_diana = str(fila.get('observacion_diana', '')).strip()
                serial_rr = str(fila.get('serial_rr', '')).strip()
                tecnico = str(fila.get('tecnico', '')).strip()
                superv = str(fila.get('super', '')).strip()
                if not serial_rr:
                    procesados += 1
                    continue
                cur_check = connection.cursor(dictionary=True)
                order_col = pk_col_name or 'created_at'
                try:
                    cur_check.execute(f"SELECT {order_col} AS pk, observacion_diana FROM seriales_inversa WHERE serial_rr=%s ORDER BY {order_col} DESC LIMIT 1", (serial_rr,))
                except Exception:
                    cur_check.execute("SELECT observacion_diana FROM seriales_inversa WHERE serial_rr=%s LIMIT 1", (serial_rr,))
                row = cur_check.fetchone()
                cur_check.close()
                if row:
                    old_obs = None
                    try:
                        old_obs = str((row.get('observacion_diana') if isinstance(row, dict) else row[1]) or '').strip()
                    except Exception:
                        old_obs = None
                    new_obs_norm = observacion_diana.strip()
                    old_obs_norm = (old_obs or '').strip()
                    set_parts = []
                    params_up = []
                    if new_obs_norm.lower() != old_obs_norm.lower():
                        set_parts.append("observacion_diana=%s")
                        params_up.append(observacion_diana)
                    if tecnico:
                        set_parts.append("tecnico=%s")
                        params_up.append(tecnico)
                    if superv:
                        set_parts.append("super=%s")
                        params_up.append(superv)
                    if descripcion:
                        set_parts.append("descripcion=%s")
                        params_up.append(descripcion)
                    if cuenta:
                        set_parts.append("cuenta=%s")
                        params_up.append(cuenta)
                    if cedula:
                        set_parts.append("recurso_operativo_cedula=%s")
                        params_up.append(cedula)
                    if lapso:
                        set_parts.append("lapso=%s")
                        params_up.append(lapso)
                    try:
                        dval = int(dia) if dia is not None and str(dia).strip() != '' else None
                    except Exception:
                        dval = None
                    try:
                        mval = int(mes) if mes is not None and str(mes).strip() != '' else None
                    except Exception:
                        mval = None
                    if dval is not None:
                        set_parts.append("dia=%s")
                        params_up.append(dval)
                    if mval is not None:
                        set_parts.append("mes=%s")
                        params_up.append(mval)
                    if set_parts:
                        set_sql = ", ".join(set_parts)
                        cur_up = connection.cursor()
                        if pk_col_name and isinstance(row, dict) and 'pk' in row:
                            cur_up.execute(f"UPDATE seriales_inversa SET {set_sql} WHERE {pk_col_name}=%s", tuple(params_up + [row['pk']]))
                        elif pk_col_name and not isinstance(row, dict):
                            cur_up.execute(f"UPDATE seriales_inversa SET {set_sql} WHERE {pk_col_name}=%s", tuple(params_up + [row[0]]))
                        else:
                            cur_up.execute(f"UPDATE seriales_inversa SET {set_sql} WHERE serial_rr=%s", tuple(params_up + [serial_rr]))
                        cur_up.close()
                        actualizados += 1
                    else:
                        omitidos_iguales += 1
                else:
                    cursor.execute(
                        """
                        INSERT INTO seriales_inversa
                        (lapso, recurso_operativo_cedula, cuenta, dia, mes, descripcion, observacion_diana, serial_rr, tecnico, super)
                        VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
                        """,
                        (lapso, cedula, cuenta, dia, mes, descripcion, observacion_diana, serial_rr, tecnico, superv)
                    )
                    insertados += 1
                procesados += 1
            except Exception:
                procesados += 1
                continue
        connection.commit()
        if cursor:
            cursor.close()
        if connection:
            connection.close()
        return jsonify({'success': True, 'message': 'Carga completada', 'procesados': procesados, 'insertados': insertados, 'actualizados': actualizados, 'omitidos_iguales': omitidos_iguales})
    except Exception as e:
        if cursor:
            try:
                cursor.close()
            except Exception:
                pass
        if connection:
            try:
                connection.close()
            except Exception:
                pass
        return jsonify({'success': False, 'message': str(e)})

@app.route('/logistica/seriales_inversa/list', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_list():
    try:
        draw = int(request.args.get('draw', '1'))
        length = int(request.args.get('length', request.args.get('per_page', '10')))
        start = int(request.args.get('start', '0'))
        tecnico = (request.args.get('tecnico') or '').strip()
        observacion_diana = (request.args.get('observacion_diana') or '').strip()
        supervisor = (request.args.get('supervisor') or request.args.get('super') or '').strip()
        fecha_desde = (request.args.get('fecha_desde') or '').strip()
        fecha_hasta = (request.args.get('fecha_hasta') or '').strip()

        conn = get_db_connection()
        if conn is None:
            return jsonify({'draw': draw, 'recordsTotal': 0, 'recordsFiltered': 0, 'data': [], 'success': False, 'error': 'Error de conexión a la base de datos'})
        cur = conn.cursor(dictionary=True)

        date_col = None
        try:
            curc = conn.cursor()
            curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'FECHA_REGISTRO'")
            if curc.fetchone():
                date_col = 'si.FECHA_REGISTRO'
            else:
                curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'fecha_registro'")
                if curc.fetchone():
                    date_col = 'si.fecha_registro'
                else:
                    curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'created_at'")
                    if curc.fetchone():
                        date_col = 'si.created_at'
            curc.close()
        except Exception:
            date_col = None

        pk_col = None
        try:
            curp = conn.cursor(dictionary=True)
            curp.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'id'")
            if curp.fetchone():
                pk_col = 'si.id'
            else:
                curp.execute("SHOW KEYS FROM seriales_inversa WHERE Key_name='PRIMARY'")
                pk = curp.fetchone()
                if pk and pk.get('Column_name'):
                    pk_col = 'si.' + pk['Column_name']
                else:
                    for alt in ('id_inversa','id_seriales_inversa','idseriales_inversa'):
                        curp.execute(f"SHOW COLUMNS FROM seriales_inversa LIKE '{alt}'")
                        if curp.fetchone():
                            pk_col = 'si.' + alt
                            break
            curp.close()
        except Exception:
            pk_col = 'NULL'
        if not pk_col:
            pk_col = 'NULL'

        # Detectar columna de observación (observacion_diana/opservacion_diana)
        obs_col = None
        try:
            cur_obs = conn.cursor()
            cur_obs.execute("SHOW COLUMNS FROM seriales_inversa")
            cols_obs = [r[0] for r in cur_obs.fetchall()]
            cur_obs.close()
            for cname in cols_obs:
                cn = str(cname or '').strip().lower()
                if cn == 'observacion_diana' or cn == 'opservacion_diana':
                    obs_col = cname
                    break
        except Exception:
            obs_col = 'observacion_diana'
        if not obs_col:
            obs_col = 'observacion_diana'

        where = []
        params = []
        if tecnico:
            where.append("si.tecnico = %s")
            params.append(tecnico)
        if observacion_diana:
            where.append(f"si.{obs_col} = %s")
            params.append(observacion_diana)
        if supervisor:
            where.append("si.super = %s")
            params.append(supervisor)
        if date_col:
            if fecha_desde:
                where.append(f"DATE({date_col}) >= %s")
                params.append(fecha_desde)
            if fecha_hasta:
                where.append(f"DATE({date_col}) <= %s")
                params.append(fecha_hasta)
        where_sql = (" WHERE " + " AND ".join(where)) if where else ""

        cur.execute("SELECT COUNT(*) AS total FROM seriales_inversa AS si")
        total = cur.fetchone()['total']
        cur.execute("SELECT COUNT(*) AS total FROM seriales_inversa AS si" + where_sql, tuple(params))
        filtered = cur.fetchone()['total']
        if date_col:
            select_cols = f"{pk_col} AS id, lapso, recurso_operativo_cedula, cuenta, dia, mes, descripcion, {obs_col} AS observacion_diana, serial_rr, tecnico, super, DATE_FORMAT({date_col}, '%Y-%m-%d %H:%i:%S') AS fecha_registro"
        else:
            select_cols = (
                f"{pk_col} AS id, lapso, recurso_operativo_cedula, cuenta, dia, mes, descripcion, {obs_col} AS observacion_diana, serial_rr, tecnico, super, "
                "DATE_FORMAT(STR_TO_DATE(CONCAT(YEAR(CURDATE()), '-', "
                "CASE LOWER(si.mes) "
                "WHEN 'enero' THEN '01' WHEN 'febrero' THEN '02' WHEN 'marzo' THEN '03' WHEN 'abril' THEN '04' "
                "WHEN 'mayo' THEN '05' WHEN 'junio' THEN '06' WHEN 'julio' THEN '07' WHEN 'agosto' THEN '08' "
                "WHEN 'septiembre' THEN '09' WHEN 'setiembre' THEN '09' WHEN 'octubre' THEN '10' WHEN 'noviembre' THEN '11' WHEN 'diciembre' THEN '12' ELSE NULL END, "
                "'-', LPAD(CAST(si.dia AS UNSIGNED), 2, '0')), '%Y-%m-%d'), '%Y-%m-%d %H:%i:%S') AS fecha_registro"
            )
        order_by = 'id'
        if pk_col and pk_col.startswith('si.'):
            order_by = pk_col.split('.',1)[1]
        else:
            try:
                curo = conn.cursor()
                for alt in ('created_at','fecha_registro','FECHA_REGISTRO','serial_rr','cuenta'):
                    curo.execute(f"SHOW COLUMNS FROM seriales_inversa LIKE '{alt}'")
                    if curo.fetchone():
                        order_by = alt
                        break
                curo.close()
            except Exception:
                order_by = 'serial_rr'
        cur.execute(
            f"""
            SELECT {select_cols}
            FROM seriales_inversa AS si
            """ + where_sql + f" ORDER BY {order_by} DESC LIMIT %s OFFSET %s",
            tuple(params + [length, start])
        )
        rows = cur.fetchall()
        cur.close(); conn.close()
        return jsonify({'draw': draw, 'recordsTotal': total, 'recordsFiltered': filtered, 'data': rows, 'success': True})
    except Exception as e:
        try:
            d = int(request.args.get('draw', '1'))
        except Exception:
            d = 1
        return jsonify({'draw': d, 'recordsTotal': 0, 'recordsFiltered': 0, 'data': [], 'success': False, 'error': str(e)})

@app.route('/logistica/seriales_inversa/tecnicos', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_tecnicos():
    try:
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor()
        cur.execute("SELECT DISTINCT tecnico FROM seriales_inversa WHERE tecnico IS NOT NULL AND TRIM(tecnico) != '' ORDER BY tecnico")
        names = [r[0] for r in cur.fetchall() if r and r[0]]
        cur.close(); conn.close()
        return jsonify({'success': True, 'tecnicos': names})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/observaciones', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_observaciones():
    try:
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        # Detectar nombre de columna correcto
        obs_col = None
        cur0 = conn.cursor()
        cur0.execute("SHOW COLUMNS FROM seriales_inversa")
        all_cols = [row[0] for row in cur0.fetchall()]
        cur0.close()
        for cname in all_cols:
            cn = str(cname or '').strip().lower()
            if cn == 'observacion_diana' or cn == 'opservacion_diana':
                obs_col = cname
                break
        if not obs_col:
            obs_col = 'observacion_diana'
        cur = conn.cursor()
        cur.execute(f"SELECT DISTINCT TRIM({obs_col}) AS obs FROM seriales_inversa WHERE {obs_col} IS NOT NULL AND TRIM({obs_col}) != '' ORDER BY obs")
        values = [r[0] for r in cur.fetchall() if r and r[0]]
        cur.close(); conn.close()
        return jsonify({'success': True, 'observaciones': values})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/supervisores', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_supervisores():
    try:
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor()
        cur.execute("SELECT DISTINCT super FROM seriales_inversa WHERE super IS NOT NULL AND TRIM(super) != '' ORDER BY super")
        values = [r[0] for r in cur.fetchall() if r and r[0]]
        cur.close(); conn.close()
        return jsonify({'success': True, 'supervisores': values})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/dias_con_registros', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_dias_con_registros():
    try:
        year = int(request.args.get('year', '0') or '0')
        month = int(request.args.get('month', '0') or '0')
        if year <= 0 or month <= 0 or month > 12:
            from datetime import datetime
            now = datetime.now()
            year = now.year
            month = now.month
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor(dictionary=True)
        date_col = None
        try:
            curc = conn.cursor()
            curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'FECHA_REGISTRO'")
            if curc.fetchone():
                date_col = 'si.FECHA_REGISTRO'
            else:
                curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'fecha_registro'")
                if curc.fetchone():
                    date_col = 'si.fecha_registro'
                else:
                    curc.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'created_at'")
                    if curc.fetchone():
                        date_col = 'si.created_at'
            curc.close()
        except Exception:
            date_col = None
        rows = []
        if date_col:
            cur.execute(
                f"SELECT DISTINCT DAY({date_col}) AS dia FROM seriales_inversa AS si WHERE YEAR({date_col})=%s AND MONTH({date_col})=%s ORDER BY dia",
                (year, month)
            )
            rows = cur.fetchall() or []
        else:
            meses = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre']
            mname = meses[month-1]
            if month == 9:
                cur.execute("SELECT DISTINCT si.dia AS dia FROM seriales_inversa AS si WHERE LOWER(si.mes) IN ('septiembre','setiembre') ORDER BY si.dia")
            else:
                cur.execute("SELECT DISTINCT si.dia AS dia FROM seriales_inversa AS si WHERE LOWER(si.mes)=%s ORDER BY si.dia", (mname,))
            rows = cur.fetchall() or []
        cur.close(); conn.close()
        dias = [{'dia': int(r.get('dia') or 0)} for r in rows if r and (r.get('dia') is not None)]
        return jsonify({'success': True, 'year': year, 'month': month, 'dias': dias})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/update_observacion', methods=['POST'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_update_observacion():
    try:
        data = None
        try:
            data = request.get_json(silent=True) or {}
        except Exception:
            data = {}
        rid = request.form.get('id') or data.get('id')
        serial = request.form.get('serial_rr') or data.get('serial_rr')
        obs = request.form.get('observacion_diana') or data.get('observacion_diana') or request.form.get('opservacion_diana') or data.get('opservacion_diana')
        if not obs or str(obs).strip() == '':
            return jsonify({'success': False, 'message': 'Observación requerida'}), 400
        rid_val = None
        try:
            rid_val = int(str(rid).strip())
        except Exception:
            rid_val = None
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        pk_name = None
        try:
            curp = conn.cursor(dictionary=True)
            curp.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'id'")
            if curp.fetchone():
                pk_name = 'id'
            else:
                curp.execute("SHOW KEYS FROM seriales_inversa WHERE Key_name='PRIMARY'")
                pk = curp.fetchone()
                if pk and pk.get('Column_name'):
                    pk_name = pk['Column_name']
                else:
                    for alt in ('id_inversa','id_seriales_inversa','idseriales_inversa'):
                        curp.execute(f"SHOW COLUMNS FROM seriales_inversa LIKE '{alt}'")
                        if curp.fetchone():
                            pk_name = alt
                            break
            curp.close()
        except Exception:
            pk_name = None
        obs_col = None
        try:
            cur0 = conn.cursor()
            cur0.execute("SHOW COLUMNS FROM seriales_inversa")
            cols = [r[0] for r in cur0.fetchall()]
            cur0.close()
            for cname in cols:
                cn = str(cname or '').strip().lower()
                if cn == 'observacion_diana' or cn == 'opservacion_diana':
                    obs_col = cname
                    break
        except Exception:
            obs_col = None
        if not obs_col:
            obs_col = 'observacion_diana'
        cur = conn.cursor()
        updated = 0
        if rid_val is not None and pk_name:
            cur.execute(f"UPDATE seriales_inversa SET {obs_col}=%s WHERE {pk_name}=%s", (str(obs).strip(), rid_val))
            updated = cur.rowcount
        elif serial:
            cur.execute(f"UPDATE seriales_inversa SET {obs_col}=%s WHERE serial_rr=%s", (str(obs).strip(), serial))
            updated = cur.rowcount
        else:
            cur.close(); conn.close()
            return jsonify({'success': False, 'message': 'ID o serial requerido'}), 400
        conn.commit()
        cur.close(); conn.close()
        return jsonify({'success': True, 'updated': updated})
    except Exception as e:
        try:
            conn.close()
        except Exception:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/delete', methods=['POST'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_delete():
    try:
        rid = None
        data = None
        try:
            data = request.get_json(silent=True) or {}
        except Exception:
            data = {}
        rid = request.form.get('id') or data.get('id')
        try:
            rid = int(str(rid))
        except Exception:
            return jsonify({'success': False, 'message': 'ID inválido'}), 400
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        pk_name = None
        try:
            curp = conn.cursor(dictionary=True)
            curp.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'id'")
            if curp.fetchone():
                pk_name = 'id'
            else:
                curp.execute("SHOW KEYS FROM seriales_inversa WHERE Key_name='PRIMARY'")
                pk = curp.fetchone()
                if pk and pk.get('Column_name'):
                    pk_name = pk['Column_name']
                else:
                    for alt in ('id_inversa','id_seriales_inversa','idseriales_inversa'):
                        curp.execute(f"SHOW COLUMNS FROM seriales_inversa LIKE '{alt}'")
                        if curp.fetchone():
                            pk_name = alt
                            break
            curp.close()
        except Exception:
            pk_name = None
        if not pk_name:
            return jsonify({'success': False, 'message': 'No se encontró columna identificadora en la tabla'}), 500
        import re as _re
        if not _re.match(r'^[A-Za-z0-9_]+$', pk_name):
            return jsonify({'success': False, 'message': 'Columna PK inválida'}), 500
        cur = conn.cursor()
        cur.execute(f"DELETE FROM seriales_inversa WHERE {pk_name}=%s", (rid,))
        deleted = cur.rowcount
        conn.commit()
        cur.close(); conn.close()
        return jsonify({'success': True, 'deleted': deleted})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/pending', methods=['GET'])
@login_required_api(role=['tecnicos','operativo','logistica','administrativo'])
def logistica_seriales_inversa_pending():
    try:
        user_role = session.get('user_role')
        cedulas_objetivo = []

        if user_role == 'tecnicos':
            cedula = (session.get('user_cedula') or '').strip()
            if not cedula:
                try:
                    uid = session.get('id_codigo_consumidor')
                    if uid:
                        conn0 = get_db_connection()
                        if conn0:
                            cur0 = conn0.cursor()
                            cur0.execute("SELECT recurso_operativo_cedula FROM recurso_operativo WHERE id_codigo_consumidor=%s", (uid,))
                            row0 = cur0.fetchone()
                            if row0:
                                cedula = str(row0[0]).strip()
                            cur0.close(); conn0.close()
                except Exception:
                    pass
            if cedula:
                cedulas_objetivo = [cedula]
            else:
                return jsonify({'success': False, 'message': 'No se encontró cédula de usuario'}), 200

        elif user_role == 'operativo':
            supervisor_nombre = (session.get('user_name') or '').strip()
            if supervisor_nombre:
                try:
                    conn1 = get_db_connection()
                    if conn1:
                        cur1 = conn1.cursor()
                        cur1.execute("SELECT recurso_operativo_cedula FROM recurso_operativo WHERE LOWER(TRIM(super)) = LOWER(TRIM(%s)) AND estado='Activo'", (supervisor_nombre,))
                        cedulas_objetivo = [str(r[0]).strip() for r in cur1.fetchall() if r and r[0]]
                        cur1.close(); conn1.close()
                except Exception:
                    cedulas_objetivo = []
            if not cedulas_objetivo:
                return jsonify({'success': True, 'count': 0, 'items': [], 'message': 'Sin técnicos a cargo o sin pendientes'}), 200

        else:
            try:
                cedula_param = (request.args.get('cedula') or '').strip()
                if cedula_param:
                    cedulas_objetivo = [cedula_param]
            except Exception:
                pass
            if not cedulas_objetivo:
                cedula = (session.get('user_cedula') or '').strip()
                if cedula:
                    cedulas_objetivo = [cedula]
                else:
                    return jsonify({'success': False, 'message': 'No se encontró cédula de usuario'}), 200

        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 200
        cur = conn.cursor(dictionary=True)
        rows = []
        has_fecha_registro = False
        fr_upper = False
        has_created_at = False
        has_dia = False
        has_mes = False
        try:
            cur_check = conn.cursor()
            cur_check.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'FECHA_REGISTRO'")
            fr_upper = cur_check.fetchone() is not None
            if not fr_upper:
                cur_check.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'fecha_registro'")
                has_fecha_registro = cur_check.fetchone() is not None
            else:
                has_fecha_registro = True
            cur_check.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'created_at'")
            has_created_at = cur_check.fetchone() is not None
            cur_check.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'dia'")
            has_dia = cur_check.fetchone() is not None
            cur_check.execute("SHOW COLUMNS FROM seriales_inversa LIKE 'mes'")
            has_mes = cur_check.fetchone() is not None
            cur_check.close()
        except Exception:
            pass
        # Detectar columna de observación
        obs_col = None
        try:
            cur_obs2 = conn.cursor()
            cur_obs2.execute("SHOW COLUMNS FROM seriales_inversa")
            cols_obs2 = [r[0] for r in cur_obs2.fetchall()]
            cur_obs2.close()
            for cname in cols_obs2:
                cn = str(cname or '').strip().lower()
                if cn == 'observacion_diana' or cn == 'opservacion_diana':
                    obs_col = cname
                    break
        except Exception:
            pass
        if not obs_col:
            obs_col = 'observacion_diana'

        cols = [
            "si.serial_rr",
            "si.cuenta",
            "si.recurso_operativo_cedula AS cedula",
            "si.lapso",
            "si.descripcion",
            f"si.{obs_col} AS observacion_diana"
        ]
        if has_fecha_registro:
            cols.append(("si.FECHA_REGISTRO" if fr_upper else "si.fecha_registro") + " AS fecha_registro")
        if has_created_at:
            cols.append("si.created_at")
        if has_dia:
            cols.append("si.dia")
        if has_mes:
            cols.append("si.mes")
        cols.append("ro.nombre AS tecnico_nombre")
        base_sql = "SELECT " + ", ".join(cols) + """
                FROM seriales_inversa AS si
                JOIN recurso_operativo AS ro ON ro.recurso_operativo_cedula = si.recurso_operativo_cedula
                WHERE UPPER(si.""" + obs_col + """) LIKE '%%PENDIENTE%%'
              """
        if len(cedulas_objetivo) == 1:
            sql = base_sql + " AND si.recurso_operativo_cedula = %s"
            params = (cedulas_objetivo[0],)
        else:
            placeholders = ",".join(["%s"] * len(cedulas_objetivo))
            sql = base_sql + f" AND si.recurso_operativo_cedula IN ({placeholders})"
            params = tuple(cedulas_objetivo)
        cur.execute(sql, params)
        rows = cur.fetchall()
        ext_map = {}
        try:
            if cedulas_objetivo:
                placeholders = ",".join(["%s"] * len(cedulas_objetivo))
                cur_ext = conn.cursor()
                cur_ext.execute(f"SELECT cedula, MAX(expires_at) FROM seriales_inversa_unlocks WHERE expires_at > UTC_TIMESTAMP() AND cedula IN ({placeholders}) GROUP BY cedula", tuple(cedulas_objetivo))
                for r0 in cur_ext.fetchall() or []:
                    if r0 and r0[0]:
                        ext_map[str(r0[0]).strip()] = r0[1]
                cur_ext.close()
        except Exception:
            ext_map = {}
        cur.close(); conn.close()

        items = []
        from datetime import datetime, date
        now = datetime.now()
        for r in rows:
            fr = r.get('fecha_registro')
            created = r.get('created_at')
            dias = 0
            fr_dt = None
            try:
                if fr:
                    if hasattr(fr, 'year'):
                        fr_dt = fr.date() if hasattr(fr, 'hour') else fr
                    else:
                        s = str(fr).strip()
                        fmts = ('%Y-%m-%d','%d/%m/%Y','%Y/%m/%d','%d-%m-%Y','%m/%d/%Y')
                        for fmt in fmts:
                            try:
                                fr_dt = datetime.strptime(s, fmt).date()
                                break
                            except Exception:
                                pass
                        if fr_dt is None and s.isdigit() and len(s)==8:
                            try:
                                fr_dt = datetime.strptime(s, '%Y%m%d').date()
                            except Exception:
                                pass
                if fr_dt:
                    dias = max(0, (date.today() - fr_dt).days)
            except Exception:
                pass
            if fr_dt is None:
                try:
                    if created:
                        if hasattr(created, 'tzinfo') and created.tzinfo:
                            created_naive = created.astimezone(None).replace(tzinfo=None)
                        else:
                            created_naive = created
                        delta = now - created_naive
                        dias = max(0, delta.days)
                except Exception:
                    pass
            if fr_dt is None and not created:
                try:
                    d = int(r.get('dia') or 0)
                    mes_txt = (r.get('mes') or '').strip().lower()
                    meses = {
                        'enero':1,'febrero':2,'marzo':3,'abril':4,'mayo':5,'junio':6,
                        'julio':7,'agosto':8,'septiembre':9,'setiembre':9,'octubre':10,
                        'noviembre':11,'diciembre':12
                    }
                    m = meses.get(mes_txt)
                    if m and d:
                        dt = date(datetime.now().year, m, d)
                        dias = max(0, (date.today()-dt).days)
                except Exception:
                    pass
            dias_restantes = 2 - dias
            try:
                cdl = str(r.get('cedula') or '').strip()
                dt_exp = ext_map.get(cdl)
                if cdl and dt_exp:
                    from datetime import datetime as _dt
                    try:
                        delta = dt_exp - _dt.utcnow()
                        secs = max(0, delta.total_seconds())
                        add_days = int((secs + 86399) // 86400)
                        dias_restantes += add_days
                    except Exception:
                        dias_restantes += 1
            except Exception:
                pass
            items.append({
                'serial_rr': r.get('serial_rr'),
                'cuenta': r.get('cuenta'),
                'lapso': r.get('lapso'),
                'descripcion': r.get('descripcion'),
                'observacion_diana': r.get('observacion_diana'),
                'fecha_registro': fr_dt.isoformat() if fr_dt else (str(fr) if fr else None),
                'created_at': r.get('created_at').isoformat() if r.get('created_at') else None,
                'dias_restantes': dias_restantes,
                'tecnico_nombre': r.get('tecnico_nombre')
            })

        return jsonify({
            'success': True,
            'count': len(items),
            'items': items,
            'message': 'SERIALES PENDIENTES INVERSA POR FAVOR DEVOLVERLOS O SE BLOQUEARÁ PREOPERACIONAL EN 2 DÍAS'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/pending_summary', methods=['GET'])
@login_required_api(role=['logistica','operativo','administrativo','tecnicos'])
def logistica_seriales_inversa_pending_summary():
    try:
        supervisor_filter = (request.args.get('supervisor') or '').strip()
        try:
            user_role = session.get('user_role')
            if user_role == 'operativo' and not supervisor_filter:
                supervisor_filter = (session.get('user_name') or '').strip()
        except Exception:
            pass
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        obs_col = None
        try:
            cur0 = conn.cursor()
            cur0.execute("SHOW COLUMNS FROM seriales_inversa")
            all_cols = [row[0] for row in cur0.fetchall()]
            cur0.close()
            for cname in all_cols:
                cn = str(cname or '').strip().lower()
                if cn == 'observacion_diana' or cn == 'opservacion_diana':
                    obs_col = cname
                    break
        except Exception:
            obs_col = 'observacion_diana'
        if not obs_col:
            obs_col = 'observacion_diana'

        now_bog = datetime.now(TIMEZONE)
        start_month_bog = TIMEZONE.localize(datetime(now_bog.year, now_bog.month, 1, 0, 0, 0))
        if now_bog.month == 12:
            next_month_bog = TIMEZONE.localize(datetime(now_bog.year + 1, 1, 1, 0, 0, 0))
        else:
            next_month_bog = TIMEZONE.localize(datetime(now_bog.year, now_bog.month + 1, 1, 0, 0, 0))
        start_utc = start_month_bog.astimezone(pytz.UTC).replace(tzinfo=None)
        end_utc = next_month_bog.astimezone(pytz.UTC).replace(tzinfo=None)

        cur = conn.cursor(dictionary=True)
        params = [start_utc, end_utc]
        where_sup = ""
        if supervisor_filter:
            where_sup = " AND LOWER(TRIM(ro.super)) = LOWER(TRIM(%s))"
            params.append(supervisor_filter)
        cur.execute(
            f"""
            SELECT 
                ro.nombre AS tecnico_nombre,
                ro.super AS supervisor,
                COUNT(*) AS cantidad,
                si.recurso_operativo_cedula AS cedula,
                act.max_exp AS active_expires_at,
                cnt.cnt AS extensiones_mes,
                last.granted_by_name AS ultimo_por
            FROM seriales_inversa AS si
            JOIN recurso_operativo AS ro ON ro.recurso_operativo_cedula = si.recurso_operativo_cedula
            LEFT JOIN (
                SELECT cedula, MAX(expires_at) AS max_exp
                FROM seriales_inversa_unlocks
                WHERE expires_at > UTC_TIMESTAMP()
                GROUP BY cedula
            ) AS act ON act.cedula = si.recurso_operativo_cedula
            LEFT JOIN (
                SELECT cedula, COUNT(*) AS cnt
                FROM seriales_inversa_unlocks
                WHERE created_at >= %s AND created_at < %s
                GROUP BY cedula
            ) AS cnt ON cnt.cedula = si.recurso_operativo_cedula
            LEFT JOIN (
                SELECT u.cedula, u.granted_by_name
                FROM seriales_inversa_unlocks u
                JOIN (
                    SELECT cedula, MAX(created_at) AS max_created
                    FROM seriales_inversa_unlocks
                    GROUP BY cedula
                ) um ON um.cedula = u.cedula AND um.max_created = u.created_at
            ) AS last ON last.cedula = si.recurso_operativo_cedula
            WHERE UPPER(si.{obs_col}) LIKE '%%PENDIENTE%%'""" + where_sup + """
            GROUP BY ro.nombre, ro.super, si.recurso_operativo_cedula, act.max_exp, cnt.cnt, last.granted_by_name
            ORDER BY cantidad DESC
            """,
            tuple(params)
        )
        rows = cur.fetchall() or []
        cur.close(); conn.close()
        data = []
        for r in rows:
            try:
                if supervisor_filter and str(r.get('supervisor') or '').strip().lower() != supervisor_filter.strip().lower():
                    continue
            except Exception:
                pass
            exp_str = None
            try:
                exp_dt = r.get('active_expires_at')
                if exp_dt:
                    if getattr(exp_dt, 'tzinfo', None) is None:
                        exp_dt = pytz.UTC.localize(exp_dt)
                    exp_str = exp_dt.astimezone(TIMEZONE).strftime('%Y-%m-%d %H:%M')
            except Exception:
                exp_str = None
            data.append({
                'tecnico_nombre': r.get('tecnico_nombre'),
                'supervisor': r.get('supervisor'),
                'cantidad': int(r.get('cantidad') or 0),
                'cedula': r.get('cedula'),
                'extension_activa': bool(r.get('active_expires_at') is not None),
                'unlock_expires_at': exp_str,
                'extensiones_mes': int(r.get('extensiones_mes') or 0),
                'ultimo_por': r.get('ultimo_por')
            })
        return jsonify({'success': True, 'items': data})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/supervisor_summary', methods=['GET'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_supervisor_summary():
    try:
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        # Detectar columna de observación
        obs_col = None
        try:
            cur0 = conn.cursor()
            cur0.execute("SHOW COLUMNS FROM seriales_inversa")
            all_cols = [row[0] for row in cur0.fetchall()]
            cur0.close()
            for cname in all_cols:
                cn = str(cname or '').strip().lower()
                if cn == 'observacion_diana' or cn == 'opservacion_diana':
                    obs_col = cname
                    break
        except Exception:
            obs_col = 'observacion_diana'
        if not obs_col:
            obs_col = 'observacion_diana'
        cur = conn.cursor(dictionary=True)
        cur.execute(
            f"""
            SELECT 
                COALESCE(TRIM(ro.super), '') AS supervisor,
                COUNT(*) AS cantidad_total,
                COUNT(DISTINCT CASE WHEN UPPER(si.{obs_col}) LIKE '%%PENDIENTE%%' THEN si.recurso_operativo_cedula END) AS tecnicos_con_pendientes,
                SUM(CASE WHEN UPPER(si.{obs_col}) LIKE '%%PENDIENTE%%' THEN 1 ELSE 0 END) AS cantidad_pendientes,
                SUM(CASE WHEN UPPER(si.{obs_col}) LIKE '%%ENTREG%%' OR UPPER(si.{obs_col}) LIKE '%%DEVUELT%%' THEN 1 ELSE 0 END) AS cantidad_entregado,
                SUM(CASE WHEN UPPER(si.{obs_col}) LIKE '%%DESCONT%%' THEN 1 ELSE 0 END) AS cantidad_descontar,
                SUM(CASE WHEN si.{obs_col} IS NOT NULL AND UPPER(si.{obs_col}) NOT LIKE '%%PENDIENTE%%' AND UPPER(si.{obs_col}) NOT LIKE '%%ENTREG%%' AND UPPER(si.{obs_col}) NOT LIKE '%%DEVUELT%%' AND UPPER(si.{obs_col}) NOT LIKE '%%DESCONT%%' THEN 1 ELSE 0 END) AS otros_estados
            FROM seriales_inversa AS si
            JOIN recurso_operativo AS ro ON ro.recurso_operativo_cedula = si.recurso_operativo_cedula
            GROUP BY supervisor
            ORDER BY cantidad_pendientes DESC, supervisor ASC
            """
        )
        rows = cur.fetchall() or []
        cur.close(); conn.close()
        # Asegurar tipos enteros
        data = []
        for r in rows:
            data.append({
                'supervisor': r.get('supervisor') or '',
                'cantidad_total': int(r.get('cantidad_total') or 0),
                'tecnicos_con_pendientes': int(r.get('tecnicos_con_pendientes') or 0),
                'cantidad_pendientes': int(r.get('cantidad_pendientes') or 0),
                'cantidad_entregado': int(r.get('cantidad_entregado') or 0),
                'cantidad_descontar': int(r.get('cantidad_descontar') or 0),
                'otros_estados': int(r.get('otros_estados') or 0)
            })
        return jsonify({'success': True, 'items': data})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/seriales_inversa/unlock', methods=['POST'])
@login_required_api(role='logistica')
def logistica_seriales_inversa_unlock():
    try:
        cedula = None
        data = None
        try:
            data = request.get_json(silent=True) or {}
        except Exception:
            data = {}
        cedula = (request.form.get('cedula') or data.get('cedula') or '').strip()
        if not cedula:
            return jsonify({'success': False, 'message': 'Cédula requerida'}), 400
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        # Límite: máximo 2 extensiones por mes (zona horaria Bogotá)
        try:
            now_bog = datetime.now(TIMEZONE)
            start_month_bog = now_bog.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            if now_bog.month == 12:
                next_month_bog = TIMEZONE.localize(datetime(now_bog.year + 1, 1, 1, 0, 0, 0))
            else:
                next_month_bog = TIMEZONE.localize(datetime(now_bog.year, now_bog.month + 1, 1, 0, 0, 0))
            start_utc = start_month_bog.astimezone(pytz.UTC).replace(tzinfo=None)
            end_utc = next_month_bog.astimezone(pytz.UTC).replace(tzinfo=None)
            cur_cnt = conn.cursor()
            cur_cnt.execute("SELECT COUNT(*) FROM seriales_inversa_unlocks WHERE cedula=%s AND created_at >= %s AND created_at < %s", (cedula, start_utc, end_utc))
            cnt = (cur_cnt.fetchone() or [0])[0]
            cur_cnt.close()
            try:
                cnt_val = int(cnt)
            except Exception:
                cnt_val = 0
            if cnt_val >= 2:
                conn.close()
                return jsonify({'success': False, 'message': 'Máximo 2 extensiones por mes'}), 200
        except Exception:
            pass
        cur = conn.cursor()
        cur_max = conn.cursor()
        cur_max.execute("SELECT MAX(expires_at) FROM seriales_inversa_unlocks WHERE cedula=%s AND expires_at > UTC_TIMESTAMP()", (cedula,))
        row = cur_max.fetchone()
        cur_max.close()
        from datetime import datetime as _dt, timedelta as _td
        base = row[0] if row and row[0] else None
        if base is None:
            new_exp = _dt.utcnow() + _td(days=1)
        else:
            new_exp = base + _td(days=1)
        granted_by_id = (session.get('user_cedula') or session.get('id_codigo_consumidor') or '')
        granted_by_name = (session.get('user_name') or '')
        granted_by_role = (session.get('user_role') or '')
        cur.execute(
            "INSERT INTO seriales_inversa_unlocks (cedula, expires_at, extension_days, granted_by_id, granted_by_name, granted_by_role) VALUES (%s, %s, 1, %s, %s, %s)",
            (cedula, new_exp, granted_by_id, granted_by_name, granted_by_role)
        )
        conn.commit()
        cur.close(); conn.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/logistica/buscar_serial', methods=['POST'])
@login_required()
@role_required('logistica')
def buscar_serial():
    """Buscar historial de un serial específico"""
    try:
        # Manejar tanto JSON como form data
        if request.is_json:
            data = request.get_json()
            serial = data.get('serial', '').strip()
        else:
            serial = request.form.get('serial', '').strip()
        
        if not serial:
            return jsonify({
                'success': False,
                'message': 'El número de serial es requerido'
            })
        
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Buscar el serial en la tabla qry
        cursor.execute("""
            SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
            FROM qry 
            WHERE serial = %s
            ORDER BY fecha DESC
        """, (serial,))
        
        resultados = cursor.fetchall()
        
        # Calcular estadísticas
        estadisticas = {
            'total_registros': len(resultados),
            'seriales_unicos': len(set(r['serial'] for r in resultados if r['serial'])),
            'cuentas_unicas': len(set(r['cuenta'] for r in resultados if r['cuenta'])),
            'ot_unicas': len(set(r['ot'] for r in resultados if r['ot']))
        }
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': resultados,
            'estadisticas': estadisticas
        })
        
    except Exception as e:
        print(f"Error al buscar serial: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al buscar el serial: {str(e)}'
        })

@app.route('/logistica/buscar_cuenta', methods=['POST'])
@login_required()
@role_required('logistica')
def buscar_cuenta():
    """Buscar historial por cuenta y/o OT (búsqueda flexible)"""
    try:
        # Manejar tanto JSON como form data
        if request.is_json:
            data = request.get_json()
            cuenta = data.get('cuenta', '').strip()
            ot = data.get('ot', '').strip()
        else:
            cuenta = request.form.get('cuenta', '').strip()
            ot = request.form.get('ot', '').strip()
        
        # Validar que al menos uno de los campos esté presente
        if not cuenta and not ot:
            return jsonify({
                'success': False,
                'message': 'Debe proporcionar al menos una Cuenta o una OT para realizar la búsqueda'
            })
        
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Construir consulta dinámica según los parámetros proporcionados
        if cuenta and ot:
            # Buscar por cuenta Y OT
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE cuenta = %s AND ot = %s
                ORDER BY fecha DESC
            """, (cuenta, ot))
        elif cuenta:
            # Buscar solo por cuenta
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE cuenta = %s
                ORDER BY fecha DESC
            """, (cuenta,))
        else:
            # Buscar solo por OT
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE ot = %s
                ORDER BY fecha DESC
            """, (ot,))
        
        resultados = cursor.fetchall()
        
        # Calcular estadísticas
        estadisticas = {
            'total_registros': len(resultados),
            'seriales_unicos': len(set(r['serial'] for r in resultados if r['serial'])),
            'cuentas_unicas': len(set(r['cuenta'] for r in resultados if r['cuenta'])),
            'ot_unicas': len(set(r['ot'] for r in resultados if r['ot']))
        }
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': resultados,
            'estadisticas': estadisticas
        })
        
    except Exception as e:
        print(f"Error al buscar cuenta/OT: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al buscar la cuenta/OT: {str(e)}'
        })

@app.route('/logistica/buscar_ot', methods=['POST'])
@login_required()
@role_required('logistica')
def buscar_ot():
    """Buscar historial por OT y/o cuenta (búsqueda flexible)"""
    try:
        # Manejar tanto JSON como form data
        if request.is_json:
            data = request.get_json()
            ot = data.get('ot', '').strip()
            cuenta = data.get('cuenta', '').strip()
        else:
            ot = request.form.get('ot', '').strip()
            cuenta = request.form.get('cuenta', '').strip()
        
        # Validar que al menos uno de los campos esté presente
        if not ot and not cuenta:
            return jsonify({
                'success': False,
                'message': 'Debe proporcionar al menos una OT o una Cuenta para realizar la búsqueda'
            })
        
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Construir consulta dinámica según los parámetros proporcionados
        if ot and cuenta:
            # Buscar por OT Y cuenta
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE ot = %s AND cuenta = %s
                ORDER BY fecha DESC
            """, (ot, cuenta))
        elif ot:
            # Buscar solo por OT
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE ot = %s
                ORDER BY fecha DESC
            """, (ot,))
        else:
            # Buscar solo por cuenta
            cursor.execute("""
                SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                FROM qry 
                WHERE cuenta = %s
                ORDER BY fecha DESC
            """, (cuenta,))
        
        resultados = cursor.fetchall()
        
        # Calcular estadísticas
        estadisticas = {
            'total_registros': len(resultados),
            'seriales_unicos': len(set(r['serial'] for r in resultados if r['serial'])),
            'cuentas_unicas': len(set(r['cuenta'] for r in resultados if r['cuenta'])),
            'ot_unicas': len(set(r['ot'] for r in resultados if r['ot']))
        }
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': resultados,
            'estadisticas': estadisticas
        })
        
    except Exception as e:
        print(f"Error al buscar OT/cuenta: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al buscar la OT/cuenta: {str(e)}'
        })

@app.route('/logistica/buscar_masivo', methods=['POST'])
@login_required()
@role_required('logistica')
def buscar_masivo():
    """Buscar historial masivo desde archivo TXT"""
    try:
        if 'archivo_masivo' not in request.files:
            return jsonify({
                'success': False,
                'message': 'No se ha seleccionado ningún archivo'
            })
        
        archivo = request.files['archivo_masivo']
        tipo_busqueda = request.form.get('tipo_consulta_masiva', 'seriales')
        
        if archivo.filename == '':
            return jsonify({
                'success': False,
                'message': 'No se ha seleccionado ningún archivo'
            })
        
        # Leer el contenido del archivo
        contenido = archivo.read().decode('utf-8')
        lineas = [linea.strip() for linea in contenido.split('\n') if linea.strip()]
        
        if not lineas:
            return jsonify({
                'success': False,
                'message': 'El archivo está vacío o no contiene datos válidos'
            })
        
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        resultados = []
        
        # Buscar cada elemento según el tipo
        for item in lineas:
            if tipo_busqueda == 'seriales':
                cursor.execute("""
                    SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                    FROM qry 
                    WHERE serial = %s
                    ORDER BY fecha DESC
                """, (item,))
            elif tipo_busqueda == 'cuentas':
                cursor.execute("""
                    SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                    FROM qry 
                    WHERE cuenta = %s
                    ORDER BY fecha DESC
                """, (item,))
            elif tipo_busqueda == 'ot':
                cursor.execute("""
                    SELECT id, serial, fecha, estado, ot, cuenta, codigo, descripcion
                    FROM qry 
                    WHERE ot = %s
                    ORDER BY fecha DESC
                """, (item,))
            
            resultados.extend(cursor.fetchall())
        
        cursor.close()
        connection.close()
        
        # Calcular estadísticas
        estadisticas = {
            'total_registros': len(resultados),
            'seriales_unicos': len(set(r['serial'] for r in resultados if r['serial'])),
            'cuentas_unicas': len(set(r['cuenta'] for r in resultados if r['cuenta'])),
            'ot_unicas': len(set(r['ot'] for r in resultados if r['ot']))
        }
        
        return jsonify({
            'success': True,
            'data': resultados,
            'estadisticas': estadisticas,
            'total': len(resultados),
            'items_procesados': len(lineas)
        })
        
    except Exception as e:
        print(f"Error en búsqueda masiva: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error en la búsqueda masiva: {str(e)}'
        })

@app.route('/logistica/cargar_qry', methods=['POST'])
@login_required()
@role_required('logistica')
def cargar_qry():
    """Cargar datos masivamente a la tabla qry desde archivo CSV/Excel"""
    connection = None
    cursor = None
    
    try:
        if 'archivo_qry' not in request.files:
            return jsonify({
                'success': False,
                'message': 'No se ha seleccionado ningún archivo'
            })
        
        archivo = request.files['archivo_qry']
        validar_datos = request.form.get('validar_datos', 'false').lower() == 'true'
        actualizar_existentes = request.form.get('actualizar_existentes', 'false').lower() == 'true'
        
        if archivo.filename == '':
            return jsonify({
                'success': False,
                'message': 'No se ha seleccionado ningún archivo'
            })
        
        # Validar extensión del archivo
        extension = archivo.filename.lower().split('.')[-1]
        if extension not in ['csv', 'xlsx', 'xls']:
            return jsonify({
                'success': False,
                'message': 'Formato de archivo no soportado. Use CSV o Excel (.xlsx, .xls)'
            })
        
        # Procesar archivo según su tipo
        datos = []
        errores = []
        
        try:
            if extension == 'csv':
                import csv
                import io
                
                # Intentar múltiples codificaciones para archivos CSV
                contenido_bytes = archivo.read()
                contenido = None
                
                # Lista de codificaciones a probar
                encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
                
                for encoding in encodings:
                    try:
                        contenido = contenido_bytes.decode(encoding)
                        break
                    except UnicodeDecodeError:
                        continue
                
                if contenido is None:
                    return jsonify({
                        'success': False,
                        'message': 'No se pudo decodificar el archivo CSV. Verifique la codificación del archivo.'
                    })
                
                reader = csv.DictReader(io.StringIO(contenido))
                datos = list(reader)
            else:
                import pandas as pd
                df = pd.read_excel(archivo)
                datos = df.to_dict('records')
        except Exception as e:
            return jsonify({
                'success': False,
                'message': f'Error al leer el archivo: {str(e)}'
            })
        
        if not datos:
            return jsonify({
                'success': False,
                'message': 'El archivo está vacío o no contiene datos válidos'
            })
        
        # Validar columnas requeridas
        columnas_requeridas = ['serial', 'fecha', 'estado', 'ot', 'cuenta', 'codigo', 'descripcion']
        primera_fila = datos[0]
        columnas_archivo = list(primera_fila.keys())
        
        # Verificar que todas las columnas requeridas estén presentes
        columnas_faltantes = [col for col in columnas_requeridas if col not in columnas_archivo]
        if columnas_faltantes:
            return jsonify({
                'success': False,
                'message': f'Faltan las siguientes columnas en el archivo: {", ".join(columnas_faltantes)}'
            })
        
        # Conectar a la base de datos usando la función centralizada
        from datetime import datetime
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos. Por favor, inténtelo más tarde.'
            })
        
        cursor = connection.cursor()
        
        registros_procesados = 0
        registros_insertados = 0
        registros_actualizados = 0
        
        for i, fila in enumerate(datos, 1):
            try:
                # Extraer datos de la fila
                serial = str(fila.get('serial', '')).strip()
                fecha = fila.get('fecha', '')
                estado = str(fila.get('estado', '')).strip()
                ot = str(fila.get('ot', '')).strip()
                cuenta = str(fila.get('cuenta', '')).strip()
                codigo = str(fila.get('codigo', '')).strip()
                descripcion = str(fila.get('descripcion', '')).strip()
                
                # Validaciones básicas si está habilitado
                if validar_datos:
                    if not serial:
                        errores.append(f'Fila {i}: Serial es requerido')
                        continue
                    
                    # Validar formato de fecha si es necesario
                    if fecha:
                        try:
                            if isinstance(fecha, str):
                                # Intentar parsear diferentes formatos de fecha
                                from dateutil import parser
                                fecha = parser.parse(fecha).strftime('%Y-%m-%d')
                            elif hasattr(fecha, 'strftime'):
                                fecha = fecha.strftime('%Y-%m-%d')
                        except:
                            errores.append(f'Fila {i}: Formato de fecha inválido')
                            continue
                
                # Verificar si el registro ya existe (por serial)
                if actualizar_existentes:
                    cursor.execute("SELECT id FROM qry WHERE serial = %s", (serial,))
                    existe = cursor.fetchone()
                    
                    if existe:
                        # Actualizar registro existente
                        cursor.execute("""
                            UPDATE qry 
                            SET fecha = %s, estado = %s, ot = %s, cuenta = %s, codigo = %s, descripcion = %s
                            WHERE serial = %s
                        """, (fecha, estado, ot, cuenta, codigo, descripcion, serial))
                        registros_actualizados += 1
                    else:
                        # Insertar nuevo registro
                        cursor.execute("""
                            INSERT INTO qry (serial, fecha, estado, ot, cuenta, codigo, descripcion)
                            VALUES (%s, %s, %s, %s, %s, %s, %s)
                        """, (serial, fecha, estado, ot, cuenta, codigo, descripcion))
                        registros_insertados += 1
                else:
                    # Solo insertar (puede generar duplicados)
                    cursor.execute("""
                        INSERT INTO qry (serial, fecha, estado, ot, cuenta, codigo, descripcion)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (serial, fecha, estado, ot, cuenta, codigo, descripcion))
                    registros_insertados += 1
                
                registros_procesados += 1
                
            except Exception as e:
                errores.append(f'Fila {i}: Error al procesar - {str(e)}')
                continue
        
        # Confirmar transacción
        connection.commit()
        
        # Preparar respuesta
        mensaje = f'Carga completada. Procesados: {registros_procesados}'
        if registros_insertados > 0:
            mensaje += f', Insertados: {registros_insertados}'
        if registros_actualizados > 0:
            mensaje += f', Actualizados: {registros_actualizados}'
        if errores:
            mensaje += f', Errores: {len(errores)}'
        
        # Asegurar que los mensajes de error no contengan caracteres problemáticos
        errores_limpios = []
        for error in errores[:10]:
            try:
                # Intentar codificar y decodificar para limpiar caracteres problemáticos
                error_limpio = str(error).encode('utf-8', errors='replace').decode('utf-8')
                errores_limpios.append(error_limpio)
            except:
                errores_limpios.append('Error de codificación en mensaje')
        
        return jsonify({
            'success': True,
            'message': mensaje,
            'registros_procesados': registros_procesados,
            'registros_insertados': registros_insertados,
            'registros_actualizados': registros_actualizados,
            'errores': errores_limpios
        })
        
    except mysql.connector.Error as db_error:
        if connection:
            connection.rollback()
        # Limpiar mensaje de error de base de datos
        try:
            error_msg = str(db_error).encode('utf-8', errors='replace').decode('utf-8')
        except:
            error_msg = 'Error de base de datos (problema de codificación)'
        
        return jsonify({
            'success': False,
            'message': f'Error de base de datos: {error_msg}'
        })
    
    except Exception as e:
        print(f"Error en carga de QRY: {str(e)}")
        # Limpiar mensaje de error general
        try:
            error_msg = str(e).encode('utf-8', errors='replace').decode('utf-8')
        except:
            error_msg = 'Error interno del servidor (problema de codificación)'
        
        return jsonify({
            'success': False,
            'message': f'Error interno del servidor: {error_msg}'
        })
    
    finally:
        if cursor:
            cursor.close()
        if connection:
            connection.close()

@app.route('/logistica/limites_tecnico/<int:id_codigo_consumidor>')
@login_required()
@role_required('logistica')
def obtener_limites_tecnico(id_codigo_consumidor):
    """Endpoint para obtener los límites actualizados de un técnico específico"""
    try:
        print(f"\n=== DEPURACIÓN LÍMITES TÉCNICO ===")
        print(f"ID recibido: {id_codigo_consumidor} (tipo: {type(id_codigo_consumidor)})")
        
        connection = get_db_connection()
        if connection is None:
            print("ERROR: No se pudo conectar a la base de datos")
            return jsonify({
                'success': False,
                'mensaje': 'Error de conexión a la base de datos'
            })
                               
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información del técnico
        print(f"Ejecutando consulta para técnico ID: {id_codigo_consumidor}")
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula, cargo, carpeta 
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
        """, (id_codigo_consumidor,))
        
        tecnico = cursor.fetchone()
        print(f"Resultado consulta técnico: {tecnico}")
        
        if not tecnico:
            print(f"ERROR: Técnico con ID {id_codigo_consumidor} no encontrado")
            return jsonify({
                'success': False,
                'mensaje': 'Técnico no encontrado'
            })
        
        # Definir límites según área de trabajo
        limites = {
            'FTTH INSTALACIONES': {
                'cinta_aislante': {'cantidad': 3, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
            },
            'INSTALACIONES DOBLES': {
                'cinta_aislante': {'cantidad': 3, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 150, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
            },
            'POSTVENTA': {
                'cinta_aislante': {'cantidad': 3, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 7, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
            },
            'MANTENIMIENTO FTTH': {
                'cinta_aislante': {'cantidad': 1, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 8, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
            },
            'ARREGLOS HFC': {
                'cinta_aislante': {'cantidad': 1, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 8, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 100, 'periodo': 7, 'unidad': 'días'}
            },
            'CONDUCTOR': {
                'cinta_aislante': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'}
            },
            'SUPERVISORES': {
                'cinta_aislante': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 99, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 99, 'periodo': 7, 'unidad': 'días'}
            },
            'BROWNFIELD': {
                'cinta_aislante': {'cantidad': 5, 'periodo': 15, 'unidad': 'días'},
                'silicona': {'cantidad': 16, 'periodo': 7, 'unidad': 'días'},
                'amarres_negros': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'amarres_blancos': {'cantidad': 50, 'periodo': 15, 'unidad': 'días'},
                'grapas_blancas': {'cantidad': 200, 'periodo': 15, 'unidad': 'días'},
                'grapas_negras': {'cantidad': 200, 'periodo': 15, 'unidad': 'días'}
            },
        }
        
        # Determinar área de trabajo
        carpeta = tecnico.get('carpeta', '').upper() if tecnico.get('carpeta') else ''
        cargo = tecnico.get('cargo', '').upper()
        
        print(f"Datos del técnico:")
        print(f"  - Nombre: {tecnico.get('nombre')}")
        print(f"  - Carpeta: '{carpeta}' (original: '{tecnico.get('carpeta')}')")
        print(f"  - Cargo: '{cargo}' (original: '{tecnico.get('cargo')}')")
        
        area_trabajo = None
        
        # Primero intentar determinar por carpeta
        if carpeta:
            print(f"Buscando área por carpeta: '{carpeta}'")
            for area in limites.keys():
                print(f"  - Comparando con área: '{area}' -> {area in carpeta}")
                if area in carpeta:
                    area_trabajo = area
                    print(f"  - ¡ENCONTRADA! Área asignada: {area_trabajo}")
                    break
        
        # Si no se encontró por carpeta, intentar por cargo
        if area_trabajo is None:
            print(f"Buscando área por cargo: '{cargo}'")
            for area in limites.keys():
                print(f"  - Comparando con área: '{area}' -> {area in cargo}")
                if area in cargo:
                    area_trabajo = area
                    print(f"  - ¡ENCONTRADA! Área asignada: {area_trabajo}")
                    break
        
        # Si no se encuentra un área específica, usar límites por defecto
        if area_trabajo is None:
            print("No se encontró área específica, usando POSTVENTA por defecto")
            area_trabajo = 'POSTVENTA'
        
        print(f"Área de trabajo final: {area_trabajo}")
        
        # Obtener asignaciones previas para este técnico
        fecha_actual = datetime.now()
        print(f"\nConsultando asignaciones previas para técnico ID: {id_codigo_consumidor}")
        cursor.execute("""
            SELECT 
                fecha_asignacion,
                silicona,
                amarres_negros,
                amarres_blancos,
                cinta_aislante,
                grapas_blancas,
                grapas_negras
            FROM ferretero 
            WHERE id_codigo_consumidor = %s
            ORDER BY fecha_asignacion DESC
        """, (id_codigo_consumidor,))
        asignaciones_tecnico = cursor.fetchall()
        print(f"Asignaciones encontradas: {len(asignaciones_tecnico)}")
        
        if asignaciones_tecnico:
            print("Primeras 3 asignaciones:")
            for i, asig in enumerate(asignaciones_tecnico[:3]):
                print(f"  {i+1}. Fecha: {asig['fecha_asignacion']}, Silicona: {asig['silicona']}, Cintas: {asig['cinta_aislante']}")
        
        # Inicializar contadores para materiales en los períodos correspondientes
        contadores = {
            'cinta_aislante': 0,
            'silicona': 0,
            'amarres_negros': 0,
            'amarres_blancos': 0,
            'grapas_blancas': 0,
            'grapas_negras': 0
        }
        
        # Calcular consumo previo en los periodos correspondientes
        for asignacion in asignaciones_tecnico:
            fecha_asignacion = asignacion['fecha_asignacion']
            diferencia_dias = (fecha_actual - fecha_asignacion).days
            
            # Verificar límite de cintas
            if diferencia_dias <= limites[area_trabajo]['cinta_aislante']['periodo']:
                contadores['cinta_aislante'] += int(asignacion.get('cinta_aislante', 0) or 0)
                
            # Verificar límite de siliconas
            if diferencia_dias <= limites[area_trabajo]['silicona']['periodo']:
                contadores['silicona'] += int(asignacion.get('silicona', 0) or 0)
                
            # Verificar límite de amarres negros
            if diferencia_dias <= limites[area_trabajo]['amarres_negros']['periodo']:
                contadores['amarres_negros'] += int(asignacion.get('amarres_negros', 0) or 0)
                
            # Verificar límite de amarres blancos
            if diferencia_dias <= limites[area_trabajo]['amarres_blancos']['periodo']:
                contadores['amarres_blancos'] += int(asignacion.get('amarres_blancos', 0) or 0)
                
            # Verificar límite de grapas blancas
            if diferencia_dias <= limites[area_trabajo]['grapas_blancas']['periodo']:
                contadores['grapas_blancas'] += int(asignacion.get('grapas_blancas', 0) or 0)
                
            # Verificar límite de grapas negras
            if diferencia_dias <= limites[area_trabajo]['grapas_negras']['periodo']:
                contadores['grapas_negras'] += int(asignacion.get('grapas_negras', 0) or 0)
        
        # Calcular límites disponibles
        print(f"\nContadores finales:")
        print(f"  - Cintas consumidas: {contadores['cinta_aislante']} / {limites[area_trabajo]['cinta_aislante']['cantidad']}")
        print(f"  - Siliconas consumidas: {contadores['silicona']} / {limites[area_trabajo]['silicona']['cantidad']}")
        print(f"  - Amarres negros consumidos: {contadores['amarres_negros']} / {limites[area_trabajo]['amarres_negros']['cantidad']}")
        print(f"  - Amarres blancos consumidos: {contadores['amarres_blancos']} / {limites[area_trabajo]['amarres_blancos']['cantidad']}")
        print(f"  - Grapas blancas consumidas: {contadores['grapas_blancas']} / {limites[area_trabajo]['grapas_blancas']['cantidad']}")
        print(f"  - Grapas negras consumidas: {contadores['grapas_negras']} / {limites[area_trabajo]['grapas_negras']['cantidad']}")
        
        limites_disponibles = {
            'area': area_trabajo,
            'cinta_aislante': max(0, limites[area_trabajo]['cinta_aislante']['cantidad'] - contadores['cinta_aislante']),
            'silicona': max(0, limites[area_trabajo]['silicona']['cantidad'] - contadores['silicona']),
            'amarres_negros': max(0, limites[area_trabajo]['amarres_negros']['cantidad'] - contadores['amarres_negros']),
            'amarres_blancos': max(0, limites[area_trabajo]['amarres_blancos']['cantidad'] - contadores['amarres_blancos']),
            'grapas_blancas': max(0, limites[area_trabajo]['grapas_blancas']['cantidad'] - contadores['grapas_blancas']),
            'grapas_negras': max(0, limites[area_trabajo]['grapas_negras']['cantidad'] - contadores['grapas_negras']),
            'periodos': {
                'cinta_aislante': f"{limites[area_trabajo]['cinta_aislante']['periodo']} {limites[area_trabajo]['cinta_aislante']['unidad']}",
                'silicona': f"{limites[area_trabajo]['silicona']['periodo']} {limites[area_trabajo]['silicona']['unidad']}",
                'amarres_negros': f"{limites[area_trabajo]['amarres_negros']['periodo']} {limites[area_trabajo]['amarres_negros']['unidad']}",
                'amarres_blancos': f"{limites[area_trabajo]['amarres_blancos']['periodo']} {limites[area_trabajo]['amarres_blancos']['unidad']}",
                'grapas_blancas': f"{limites[area_trabajo]['grapas_blancas']['periodo']} {limites[area_trabajo]['grapas_blancas']['unidad']}",
                'grapas_negras': f"{limites[area_trabajo]['grapas_negras']['periodo']} {limites[area_trabajo]['grapas_negras']['unidad']}"
            }
        }
        
        print(f"\nLímites disponibles calculados:")
        print(f"  - Cintas disponibles: {limites_disponibles['cinta_aislante']}")
        print(f"  - Siliconas disponibles: {limites_disponibles['silicona']}")
        print(f"  - Amarres negros disponibles: {limites_disponibles['amarres_negros']}")
        print(f"  - Amarres blancos disponibles: {limites_disponibles['amarres_blancos']}")
        print(f"  - Grapas blancas disponibles: {limites_disponibles['grapas_blancas']}")
        print(f"  - Grapas negras disponibles: {limites_disponibles['grapas_negras']}")
        print(f"=== FIN DEPURACIÓN ===\n")
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'tecnico': tecnico,
            'limites': limites_disponibles
        })
        
    except Exception as e:
        print(f"\n=== ERROR EN LÍMITES TÉCNICO ===")
        print(f"ID técnico: {id_codigo_consumidor}")
        print(f"Error: {str(e)}")
        import traceback
        print(f"Traceback: {traceback.format_exc()}")
        print(f"=== FIN ERROR ===\n")
        return jsonify({
            'success': False,
            'mensaje': f'Error al obtener límites: {str(e)}'
        })

# Las rutas de asistencia operativa han sido eliminadas - ahora se redirige al módulo administrativo

# Importar las nuevas APIs de reportes
from api_reportes import (
    api_reportes_filtros_avanzados,
    api_reportes_generar_consolidado,
    api_reportes_validar_consistencia,
    api_reportes_configuracion,
    api_reportes_consolidacion_jerarquica,
    api_reportes_analisis_tendencias,
    api_reportes_exportar,
    api_reportes_programados,
    login_required_api
)

# Nuevas rutas API para el módulo de reportes optimizado
@app.route('/api/reportes/filtros/avanzados', methods=['GET', 'POST'])
@login_required_api()
def route_api_reportes_filtros_avanzados():
    return api_reportes_filtros_avanzados()

@app.route('/api/reportes/generar/consolidado', methods=['POST'])
@login_required_api()
def route_api_reportes_generar_consolidado():
    return api_reportes_generar_consolidado()

@app.route('/api/reportes/validar/consistencia', methods=['GET'])
@login_required_api()
def route_api_reportes_validar_consistencia():
    return api_reportes_validar_consistencia()

@app.route('/api/reportes/configuracion', methods=['GET', 'POST', 'PUT', 'DELETE'])
@login_required_api()
def route_api_reportes_configuracion():
    return api_reportes_configuracion()

@app.route('/api/reportes/consolidacion/jerarquica', methods=['POST'])
@login_required_api()
def route_api_reportes_consolidacion_jerarquica():
    return api_reportes_consolidacion_jerarquica()

@app.route('/api/reportes/analisis/tendencias', methods=['POST'])
@login_required_api()
def route_api_reportes_analisis_tendencias():
    return api_reportes_analisis_tendencias()

@app.route('/api/reportes/exportar', methods=['POST'])
@login_required_api()
def route_api_reportes_exportar():
    return api_reportes_exportar()

@app.route('/api/reportes/programados', methods=['GET', 'POST', 'PUT', 'DELETE'])
@login_required_api()
def route_api_reportes_programados():
    return api_reportes_programados()

@app.route('/logistica/estadisticas_generales', methods=['GET'])
@login_required()
@role_required('logistica')
def estadisticas_generales():
    """Obtener estadísticas generales de la tabla QRY"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener total de registros
        cursor.execute("SELECT COUNT(*) as total FROM qry")
        total_registros = cursor.fetchone()['total']
        
        # Obtener seriales únicos
        cursor.execute("SELECT COUNT(DISTINCT serial) as unicos FROM qry WHERE serial IS NOT NULL AND serial != ''")
        seriales_unicos = cursor.fetchone()['unicos']
        
        # Obtener cuentas únicas
        cursor.execute("SELECT COUNT(DISTINCT cuenta) as unicos FROM qry WHERE cuenta IS NOT NULL AND cuenta != ''")
        cuentas_unicas = cursor.fetchone()['unicos']
        
        # Obtener OT únicas
        cursor.execute("SELECT COUNT(DISTINCT ot) as unicos FROM qry WHERE ot IS NOT NULL AND ot != ''")
        ot_unicas = cursor.fetchone()['unicos']
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'total_registros': total_registros,
            'seriales_unicos': seriales_unicos,
            'cuentas_unicas': cuentas_unicas,
            'ot_unicas': ot_unicas
        })
        
    except Exception as e:
        print(f"Error al obtener estadísticas generales: {str(e)}")
        return jsonify({
            'success': False,
            'message': f'Error al obtener estadísticas: {str(e)}'
        })

# Endpoint para obtener lista de supervisores para el módulo de logística
@app.route('/api/logistica/supervisores', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_supervisores_logistica():
    """Obtiene la lista de supervisores desde la tabla recurso_operativo"""
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener supervisores filtrados por carpeta 'supervisores'
        cursor.execute("""
            SELECT 
                id_codigo_consumidor,
                nombre,
                recurso_operativo_cedula,
                cargo
            FROM recurso_operativo 
            WHERE carpeta = 'supervisores' AND estado = 'Activo'
            ORDER BY nombre ASC
        """)
        
        supervisores = cursor.fetchall()
        
        return jsonify({
            'status': 'success',
            'supervisores': supervisores
        })
        
    except mysql.connector.Error as e:
        print(f"Error MySQL al obtener supervisores: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener supervisores: {str(e)}'
        }), 500
    except Exception as e:
        print(f"Error general al obtener supervisores: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener supervisores: {str(e)}'
        }), 500
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Definir la clase User para Flask-Login
class User(UserMixin):
    def __init__(self, id, nombre, role):
        self.id = id
        self.nombre = nombre
        self.role = role
    
    def has_role(self, role_id):
        return str(self.role) == str(role_id) or self.role == 'administrativo'

@login_manager.user_loader
def load_user(user_id):
    connection = get_db_connection()
    if connection is None:
        return None
    
    cursor = connection.cursor(dictionary=True)
    cursor.execute("SELECT id_codigo_consumidor, nombre, id_roles FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
    user_data = cursor.fetchone()
    cursor.close()
    connection.close()
    
    if user_data:
        return User(user_data['id_codigo_consumidor'], user_data['nombre'], ROLES.get(str(user_data['id_roles'])))
    return None

# ===== MÓDULO DE DEVOLUCIONES Y CAMBIOS DE DOTACIÓN =====

@app.route('/logistica/cambios_dotacion')
@login_required()
@role_required('logistica')
def cambios_dotacion():
    """Mostrar formulario de cambios de dotación"""
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('logistica_dashboard'))
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener lista de técnicos activos
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula
            FROM recurso_operativo 
            WHERE estado = 'Activo' AND carpeta IN ('FTTH INSTALACIONES', 'POSTVENTA', 'BROWFIELD', 'MANTENIMIENTO FTTH', 'ARREGLOS HFC', 'INSTALACIONES DOBLES')
            ORDER BY nombre ASC
        """)
        tecnicos = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/logistica/cambios_dotacion.html', tecnicos=tecnicos)
        
    except Exception as e:
        print(f"Error en cambios_dotacion: {str(e)}")
        flash('Error al cargar el formulario de cambios', 'danger')
        return redirect(url_for('logistica_dashboard'))

@app.route('/logistica/devoluciones_dotacion')
@login_required()
@role_required('logistica')
def devoluciones_dotacion():
    """Mostrar formulario de devoluciones de dotación"""
    try:
        connection = get_db_connection()
        if connection is None:
            flash('Error de conexión a la base de datos', 'danger')
            return redirect(url_for('logistica_dashboard'))
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener lista de técnicos activos
        cursor.execute("""
            SELECT id_codigo_consumidor, nombre, recurso_operativo_cedula
            FROM recurso_operativo 
            WHERE estado = 'Activo' AND carpeta IN ('FTTH INSTALACIONES', 'POSTVENTA', 'BROWFIELD', 'MANTENIMIENTO FTTH', 'ARREGLOS HFC', 'INSTALACIONES DOBLES')
            ORDER BY nombre ASC
        """)
        tecnicos = cursor.fetchall()
        
        # Obtener lista de clientes activos con IDs únicos
        cursor.execute("""
            SELECT 
                ROW_NUMBER() OVER (ORDER BY cliente ASC) as id,
                cliente as nombre
            FROM (
                SELECT DISTINCT cliente
                FROM recurso_operativo 
                WHERE cliente IS NOT NULL AND cliente != '' AND estado = 'Activo'
            ) as clientes_unicos
            ORDER BY cliente ASC
        """)
        clientes = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/logistica/devoluciones_dotacion.html', 
                             tecnicos=tecnicos, clientes=clientes)
        
    except Exception as e:
        print(f"Error en devoluciones_dotacion: {str(e)}")
        flash('Error al cargar el formulario de devoluciones', 'danger')
        return redirect(url_for('logistica_dashboard'))

@app.route('/logistica/registrar_cambio_dotacion', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_cambio_dotacion():
    """Procesar registro de cambio de dotación con gestión diferenciada de stock"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener datos del formulario
        id_codigo_consumidor = request.form.get('id_codigo_consumidor')
        fecha_cambio = request.form.get('fecha_cambio')
        observaciones = request.form.get('observaciones', '')
        
        # Función auxiliar para convertir cantidad a entero o None
        def convertir_cantidad(valor):
            if valor is None or valor == '' or valor == '0':
                return None
            try:
                cantidad = int(valor)
                return cantidad if cantidad > 0 else None
            except (ValueError, TypeError):
                return None
        
        # Función auxiliar para convertir talla a valor válido o None si está vacío
        def convertir_talla(valor):
            if valor is None or valor == '' or valor.strip() == '':
                return None
            return valor.strip()
        
        # Obtener cantidades, tallas y estados de valoración de dotación
        elementos_dotacion = {
            'pantalon': {
                'cantidad': convertir_cantidad(request.form.get('pantalon')),
                'talla': convertir_talla(request.form.get('pantalon_talla')),
                'valorado': request.form.get('pantalon_valorado') == 'on'
            },
            'camisetagris': {
                'cantidad': convertir_cantidad(request.form.get('camisetagris')),
                'talla': convertir_talla(request.form.get('camiseta_gris_talla')),
                'valorado': request.form.get('camisetagris_valorado') == 'on'
            },
            'guerrera': {
                'cantidad': convertir_cantidad(request.form.get('guerrera')),
                'talla': convertir_talla(request.form.get('guerrera_talla')),
                'valorado': request.form.get('guerrera_valorado') == 'on'
            },
            'camisetapolo': {
                'cantidad': convertir_cantidad(request.form.get('camisetapolo')),
                'talla': convertir_talla(request.form.get('camiseta_polo_talla')),
                'valorado': request.form.get('camisetapolo_valorado') == 'on'
            },
            'guantes_nitrilo': {
                'cantidad': convertir_cantidad(request.form.get('guantes_nitrilo')),
                'talla': None,
                'valorado': request.form.get('guantesnitrilo_valorado') == 'on'
            },
            'guantes_carnaza': {
                'cantidad': convertir_cantidad(request.form.get('guantes_carnaza')),
                'talla': None,
                'valorado': request.form.get('guantescarnaza_valorado') == 'on'
            },
            'gafas': {
                'cantidad': convertir_cantidad(request.form.get('gafas')),
                'talla': None,
                'valorado': request.form.get('gafas_valorado') == 'on'
            },
            'gorra': {
                'cantidad': convertir_cantidad(request.form.get('gorra')),
                'talla': None,
                'valorado': request.form.get('gorra_valorado') == 'on'
            },
            'casco': {
                'cantidad': convertir_cantidad(request.form.get('casco')),
                'talla': None,
                'valorado': request.form.get('casco_valorado') == 'on'
            },
            'botas': {
                'cantidad': convertir_cantidad(request.form.get('botas')),
                'talla': convertir_talla(request.form.get('botas_talla')),
                'valorado': request.form.get('botas_valorado') == 'on'
            },
            'chaqueta': {
                'cantidad': convertir_cantidad(request.form.get('chaqueta')),
                'talla': convertir_talla(request.form.get('chaqueta_talla')),
                'valorado': request.form.get('chaqueta_valorado') == 'on'
            },
            'arnes': {
                'cantidad': convertir_cantidad(request.form.get('arnes')),
                'talla': None,
                'valorado': request.form.get('arnes_valorado') == 'on'
            },
            'eslinga': {
                'cantidad': convertir_cantidad(request.form.get('eslinga')),
                'talla': None,
                'valorado': request.form.get('eslinga_valorado') == 'on'
            },
            'tie_of': {
                'cantidad': convertir_cantidad(request.form.get('tie_of')),
                'talla': None,
                'valorado': request.form.get('tie_of_valorado') == 'on'
            },
            'mosqueton': {
                'cantidad': convertir_cantidad(request.form.get('mosqueton')),
                'talla': None,
                'valorado': request.form.get('mosqueton_valorado') == 'on'
            },
            'pretales': {
                'cantidad': convertir_cantidad(request.form.get('pretales')),
                'talla': None,
                'valorado': request.form.get('pretales_valorado') == 'on'
            }
        }
        
        # Validaciones básicas
        if not id_codigo_consumidor or not fecha_cambio:
            flash('Técnico y fecha son campos obligatorios', 'danger')
            return redirect(url_for('cambios_dotacion'))
        
        # Obtener configuración de valoración de elementos
        cursor.execute("SELECT elemento, es_valorado FROM dotacion_elementos_config")
        config_valoracion = {row['elemento']: row['es_valorado'] for row in cursor.fetchall()}
        
        # Validar stock disponible antes de procesar usando el stock unificado por estado
        errores_stock = []
        for elemento, datos in elementos_dotacion.items():
            cantidad = datos['cantidad']
            if cantidad is not None and cantidad > 0:
                
                # Verificar stock disponible según estado valorado del formulario
                es_valorado = datos['valorado']
                tipo_stock = "VALORADO" if es_valorado else "NO VALORADO"
                
                # Obtener stock actual del elemento filtrado por estado valorado
                cursor.execute("""
                    SELECT COALESCE(SUM(cantidad), 0) as stock_disponible
                    FROM ingresos_dotaciones 
                    WHERE tipo_elemento = %s AND estado = %s
                """, (elemento, tipo_stock))
                
                ingresos_result = cursor.fetchone()
                stock_ingresos = ingresos_result['stock_disponible'] if ingresos_result else 0
                
                # Obtener salidas del elemento con el mismo estado
                cursor.execute("""
                    SELECT COALESCE(SUM(
                        CASE 
                            WHEN %s = 'pantalon' AND estado_pantalon = %s THEN pantalon
                            WHEN %s = 'camisetagris' AND estado_camiseta_gris = %s THEN camisetagris
                            WHEN %s = 'guerrera' AND estado_guerrera = %s THEN guerrera
                            WHEN %s = 'camisetapolo' AND estado_camiseta_polo = %s THEN camisetapolo
                            WHEN %s = 'guantes_nitrilo' AND estado_guantes_nitrilo = %s THEN guantes_nitrilo
                            WHEN %s = 'guantes_carnaza' AND estado_guantes_carnaza = %s THEN guantes_carnaza
                            WHEN %s = 'gafas' AND estado_gafas = %s THEN gafas
                            WHEN %s = 'gorra' AND estado_gorra = %s THEN gorra
                            WHEN %s = 'casco' AND estado_casco = %s THEN casco
                            WHEN %s = 'botas' AND estado_botas = %s THEN botas
                            WHEN %s = 'chaqueta' AND estado_chaqueta = %s THEN chaqueta
                            WHEN %s = 'arnes' AND estado_arnes = %s THEN arnes
                            WHEN %s = 'eslinga' AND estado_eslinga = %s THEN eslinga
                            WHEN %s = 'tie_of' AND estado_tie_of = %s THEN tie_of
                            WHEN %s = 'mosqueton' AND estado_mosqueton = %s THEN mosqueton
                            WHEN %s = 'pretales' AND estado_pretales = %s THEN pretales
                            ELSE 0
                        END
                    ), 0) as total_salidas
                    FROM cambios_dotacion
                """, (elemento, tipo_stock, elemento, tipo_stock, elemento, tipo_stock, 
                      elemento, tipo_stock, elemento, tipo_stock, elemento, tipo_stock,
                      elemento, tipo_stock, elemento, tipo_stock, elemento, tipo_stock,
                      elemento, tipo_stock, elemento, tipo_stock,
                      elemento, tipo_stock, elemento, tipo_stock, elemento, tipo_stock,
                      elemento, tipo_stock, elemento, tipo_stock))
                
                salidas_result = cursor.fetchone()
                stock_salidas = salidas_result['total_salidas'] if salidas_result else 0
                
                # Calcular stock disponible real por estado
                stock_disponible = stock_ingresos - stock_salidas
                
                if stock_disponible < cantidad:
                    nombre_elemento = elemento.replace('_', ' ').title()
                    errores_stock.append(
                        f"Stock insuficiente para {nombre_elemento} ({tipo_stock}): "
                        f"Disponible: {stock_disponible}, Solicitado: {cantidad}"
                    )
        
        # Si hay errores de stock, mostrarlos y no procesar
        if errores_stock:
            for error in errores_stock:
                flash(error, 'warning')
            return redirect(url_for('cambios_dotacion'))
        
        # Procesar el cambio de dotación
        # 1. Insertar en cambios_dotacion con estados de valoración
        query_cambio = """
            INSERT INTO cambios_dotacion (
                id_codigo_consumidor, fecha_cambio, pantalon, pantalon_talla, estado_pantalon,
                camisetagris, camiseta_gris_talla, estado_camiseta_gris, guerrera, guerrera_talla, estado_guerrera,
                camisetapolo, camiseta_polo_talla, estado_camiseta_polo, guantes_nitrilo, estado_guantes_nitrilo,
                guantes_carnaza, estado_guantes_carnaza, gafas, estado_gafas, gorra, estado_gorra,
                casco, estado_casco, botas, botas_talla, estado_botas, chaqueta, chaqueta_talla, estado_chaqueta,
                arnes, estado_arnes, eslinga, estado_eslinga, tie_of, estado_tie_of, mosqueton, estado_mosqueton, pretales, estado_pretales,
                observaciones
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                %s
            )
        """
        
        cursor.execute(query_cambio, (
            id_codigo_consumidor, fecha_cambio, 
            elementos_dotacion['pantalon']['cantidad'], elementos_dotacion['pantalon']['talla'], 
            'VALORADO' if elementos_dotacion['pantalon']['valorado'] else 'NO VALORADO',
            elementos_dotacion['camisetagris']['cantidad'], elementos_dotacion['camisetagris']['talla'],
            'VALORADO' if elementos_dotacion['camisetagris']['valorado'] else 'NO VALORADO',
            elementos_dotacion['guerrera']['cantidad'], elementos_dotacion['guerrera']['talla'],
            'VALORADO' if elementos_dotacion['guerrera']['valorado'] else 'NO VALORADO',
            elementos_dotacion['camisetapolo']['cantidad'], elementos_dotacion['camisetapolo']['talla'],
            'VALORADO' if elementos_dotacion['camisetapolo']['valorado'] else 'NO VALORADO',
            elementos_dotacion['guantes_nitrilo']['cantidad'], 
            'VALORADO' if elementos_dotacion['guantes_nitrilo']['valorado'] else 'NO VALORADO',
            elementos_dotacion['guantes_carnaza']['cantidad'],
            'VALORADO' if elementos_dotacion['guantes_carnaza']['valorado'] else 'NO VALORADO',
            elementos_dotacion['gafas']['cantidad'],
            'VALORADO' if elementos_dotacion['gafas']['valorado'] else 'NO VALORADO',
            elementos_dotacion['gorra']['cantidad'],
            'VALORADO' if elementos_dotacion['gorra']['valorado'] else 'NO VALORADO',
            elementos_dotacion['casco']['cantidad'],
            'VALORADO' if elementos_dotacion['casco']['valorado'] else 'NO VALORADO',
            elementos_dotacion['botas']['cantidad'], elementos_dotacion['botas']['talla'],
            'VALORADO' if elementos_dotacion['botas']['valorado'] else 'NO VALORADO',
            elementos_dotacion['chaqueta']['cantidad'], elementos_dotacion['chaqueta']['talla'],
            'VALORADO' if elementos_dotacion['chaqueta']['valorado'] else 'NO VALORADO',
            elementos_dotacion['arnes']['cantidad'], 'VALORADO' if elementos_dotacion['arnes']['valorado'] else 'NO VALORADO',
            elementos_dotacion['eslinga']['cantidad'], 'VALORADO' if elementos_dotacion['eslinga']['valorado'] else 'NO VALORADO',
            elementos_dotacion['tie_of']['cantidad'], 'VALORADO' if elementos_dotacion['tie_of']['valorado'] else 'NO VALORADO',
            elementos_dotacion['mosqueton']['cantidad'], 'VALORADO' if elementos_dotacion['mosqueton']['valorado'] else 'NO VALORADO',
            elementos_dotacion['pretales']['cantidad'], 'VALORADO' if elementos_dotacion['pretales']['valorado'] else 'NO VALORADO',
            observaciones
        ))
        
        # NOTA: Los cambios de dotación solo se registran en cambios_dotacion
        # NO se debe insertar en la tabla dotaciones para evitar contaminación cruzada
        
        connection.commit()
        
        # Preparar mensaje de éxito con detalles de estado valorado
        elementos_procesados = []
        for elemento, datos in elementos_dotacion.items():
            cantidad = datos['cantidad']
            if cantidad is not None and cantidad > 0:
                estado_valorado = "VALORADO" if datos['valorado'] else "NO VALORADO"
                nombre_elemento = elemento.replace('_', ' ').title()
                elementos_procesados.append(f"{nombre_elemento}: {cantidad} ({estado_valorado})")
        
        mensaje_exito = f"Cambio de dotación registrado exitosamente. Elementos procesados: {', '.join(elementos_procesados)}"
        flash(mensaje_exito, 'success')
        
        cursor.close()
        connection.close()
        
        return redirect(url_for('cambios_dotacion'))
        
    except Exception as e:
        print(f"Error al registrar cambio de dotación: {str(e)}")
        flash(f'Error al registrar cambio: {str(e)}', 'danger')
        return redirect(url_for('cambios_dotacion'))

@app.route('/api/cambios_dotacion/historial', methods=['GET'])
@login_required()
@role_required('logistica')
def api_cambios_dotacion_historial():
    """API para obtener el historial de cambios de dotación"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Consulta mejorada con JOIN para obtener información completa del técnico
        # Incluye los campos de estado (valorado/no valorado) directamente de cambios_dotacion
        query = """
            SELECT 
                cd.id_cambio as id,
                cd.id_codigo_consumidor,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula,
                cd.fecha_cambio,
                cd.pantalon,
                cd.pantalon_talla,
                cd.estado_pantalon,
                cd.camisetagris,
                cd.camiseta_gris_talla,
                cd.estado_camiseta_gris,
                cd.guerrera,
                cd.guerrera_talla,
                cd.estado_guerrera,
                cd.camisetapolo,
                cd.camiseta_polo_talla,
                cd.estado_camiseta_polo,
                cd.chaqueta,
                cd.chaqueta_talla,
                cd.estado_chaqueta,
                cd.guantes_nitrilo,
                cd.estado_guantes_nitrilo,
                cd.guantes_carnaza,
                cd.estado_guantes_carnaza,
                cd.gafas,
                cd.estado_gafas,
                cd.gorra,
                cd.estado_gorra,
                cd.casco,
                cd.estado_casco,
                cd.botas,
                cd.botas_talla,
                cd.estado_botas,
                cd.arnes,
                cd.estado_arnes,
                cd.eslinga,
                cd.estado_eslinga,
                cd.tie_of,
                cd.estado_tie_of,
                cd.mosqueton,
                cd.estado_mosqueton,
                cd.pretales,
                cd.estado_pretales,
                cd.observaciones,
                cd.fecha_registro as created_at
            FROM cambios_dotacion cd
            LEFT JOIN recurso_operativo ro ON cd.id_codigo_consumidor = ro.id_codigo_consumidor
            ORDER BY cd.fecha_cambio DESC, cd.fecha_registro DESC
        """
        
        cursor.execute(query)
        cambios = cursor.fetchall()
        
        # Formatear los datos para el frontend con información mejorada
        historial = []
        for cambio in cambios:
            # Crear lista de elementos modificados con estado de valoración
            elementos_modificados = []
            
            # Mapeo de elementos con sus configuraciones incluyendo estados de valoración
            elementos_data = [
                ('pantalon', cambio['pantalon'], cambio['pantalon_talla'], cambio['estado_pantalon']),
                ('camisetagris', cambio['camisetagris'], cambio['camiseta_gris_talla'], cambio['estado_camiseta_gris']),
                ('guerrera', cambio['guerrera'], cambio['guerrera_talla'], cambio['estado_guerrera']),
                ('camisetapolo', cambio['camisetapolo'], cambio['camiseta_polo_talla'], cambio['estado_camiseta_polo']),
                ('chaqueta', cambio['chaqueta'], cambio['chaqueta_talla'], cambio['estado_chaqueta']),
                ('guantes_nitrilo', cambio['guantes_nitrilo'], None, cambio['estado_guantes_nitrilo']),
                ('guantes_carnaza', cambio['guantes_carnaza'], None, cambio['estado_guantes_carnaza']),
                ('gafas', cambio['gafas'], None, cambio['estado_gafas']),
                ('gorra', cambio['gorra'], None, cambio['estado_gorra']),
                ('casco', cambio['casco'], None, cambio['estado_casco']),
                ('botas', cambio['botas'], cambio['botas_talla'], cambio['estado_botas']),
                ('arnes', cambio.get('arnes'), None, cambio.get('estado_arnes')),
                ('eslinga', cambio.get('eslinga'), None, cambio.get('estado_eslinga')),
                ('tie_of', cambio.get('tie_of'), None, cambio.get('estado_tie_of')),
                ('mosqueton', cambio.get('mosqueton'), None, cambio.get('estado_mosqueton')),
                ('pretales', cambio.get('pretales'), None, cambio.get('estado_pretales'))
            ]
            
            # Nombres descriptivos para elementos
            nombres_elementos = {
                'pantalon': 'Pantalón',
                'camisetagris': 'Camiseta Gris',
                'guerrera': 'Guerrera',
                'camisetapolo': 'Camiseta Polo',
                'chaqueta': 'Chaqueta',
                'guantes_nitrilo': 'Guantes Nitrilo',
                'guantes_carnaza': 'Guantes Carnaza',
                'gafas': 'Gafas',
                'gorra': 'Gorra',
                'casco': 'Casco',
                'botas': 'Botas',
                'arnes': 'Arnés',
                'eslinga': 'Eslinga',
                'tie_of': 'Tie Off',
                'mosqueton': 'Mosquetón',
                'pretales': 'Pretales'
            }
            
            for elemento, cantidad, talla, estado_valoracion in elementos_data:
                if cantidad and cantidad > 0:
                    # Usar el estado de valoración directamente de cambios_dotacion
                    es_valorado = estado_valoracion == 'VALORADO' if estado_valoracion else False
                    nombre_elemento = nombres_elementos.get(elemento, elemento.title())
                    
                    # Crear objeto con la estructura que espera el frontend
                    elemento_obj = {
                        'descripcion': nombre_elemento,
                        'elemento': nombre_elemento,
                        'cantidad': cantidad,
                        'es_valorado': es_valorado,
                        'estado_valoracion': estado_valoracion or 'NO VALORADO',  # Campo adicional para mostrar el estado exacto
                        'precio_unitario': None  # Se puede agregar lógica de precios aquí si es necesario
                    }
                    
                    if talla:
                        elemento_obj['talla'] = talla
                    
                    elementos_modificados.append(elemento_obj)
            
            # Formatear información completa del técnico
            tecnico_info = "Técnico no encontrado"
            if cambio['tecnico_nombre'] and cambio['tecnico_cedula']:
                tecnico_info = f"{cambio['tecnico_nombre']} (ID: {cambio['tecnico_cedula']})"
            elif cambio['tecnico_nombre']:
                tecnico_info = f"{cambio['tecnico_nombre']} (ID: {cambio['id_codigo_consumidor']})"
            elif cambio['tecnico_cedula']:
                tecnico_info = f"Cédula: {cambio['tecnico_cedula']}"
            else:
                tecnico_info = f"ID Sistema: {cambio['id_codigo_consumidor']}"
            
            # Enviar fechas en formato ISO para que JavaScript pueda parsearlas correctamente
            fecha_cambio_iso = None
            fecha_registro_iso = None
            
            if cambio['fecha_cambio']:
                fecha_cambio_iso = cambio['fecha_cambio'].isoformat()
            
            if cambio['created_at']:
                fecha_registro_iso = cambio['created_at'].isoformat()
            
            # Crear string de elementos para compatibilidad con versiones anteriores
            elementos_texto = ', '.join([f"{elem['descripcion']}: {elem['cantidad']}" + (f" (Talla: {elem['talla']})" if elem.get('talla') else "") for elem in elementos_modificados]) if elementos_modificados else 'Sin elementos especificados'
            
            historial.append({
                'id': cambio['id'],
                'tecnico': tecnico_info,
                'tecnico_nombre': cambio['tecnico_nombre'] or 'No disponible',
                'tecnico_cedula': cambio['tecnico_cedula'] or 'No disponible',
                'id_codigo_consumidor': cambio['id_codigo_consumidor'],
                'elementos_modificados': elementos_texto,  # String para compatibilidad
                'elementos_modificados_detalle': elementos_modificados,  # Array de objetos para el frontend
                'fecha_cambio': fecha_cambio_iso,
                'fecha_registro': fecha_registro_iso,
                'observaciones': cambio['observaciones'] or 'Sin observaciones'
            })
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': historial
        })
        
    except Exception as e:
        print(f"Error al obtener historial de cambios de dotación: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error al cargar el historial: {str(e)}'
        }), 500

@app.route('/api/cambios_dotacion/exportar', methods=['GET'])
@login_required()
@role_required('logistica')
def api_cambios_dotacion_exportar():
    """API para exportar cambios de dotación a Excel con dos hojas"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        from openpyxl import Workbook
        from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
        from openpyxl.utils import get_column_letter
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Consulta para obtener todos los cambios de dotación
        query = """
            SELECT 
                cd.id_cambio as id,
                cd.id_codigo_consumidor,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula,
                cd.fecha_cambio,
                cd.pantalon,
                cd.pantalon_talla,
                cd.estado_pantalon,
                cd.camisetagris,
                cd.camiseta_gris_talla,
                cd.estado_camiseta_gris,
                cd.guerrera,
                cd.guerrera_talla,
                cd.estado_guerrera,
                cd.camisetapolo,
                cd.camiseta_polo_talla,
                cd.estado_camiseta_polo,
                cd.chaqueta,
                cd.chaqueta_talla,
                cd.estado_chaqueta,
                cd.guantes_nitrilo,
                cd.estado_guantes_nitrilo,
                cd.guantes_carnaza,
                cd.estado_guantes_carnaza,
                cd.gafas,
                cd.estado_gafas,
                cd.gorra,
                cd.estado_gorra,
                cd.casco,
                cd.estado_casco,
                cd.botas,
                cd.botas_talla,
                cd.estado_botas,
                cd.observaciones,
                cd.fecha_registro as created_at
            FROM cambios_dotacion cd
            LEFT JOIN recurso_operativo ro ON cd.id_codigo_consumidor = ro.id_codigo_consumidor
            ORDER BY cd.fecha_cambio DESC, cd.fecha_registro DESC
        """
        
        cursor.execute(query)
        cambios = cursor.fetchall()
        
        # Crear el libro de Excel
        wb = Workbook()
        
        # Eliminar la hoja por defecto
        wb.remove(wb.active)
        
        # Estilos para el Excel
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_alignment = Alignment(horizontal="center", vertical="center")
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        # HOJA 1: Resumen por Elementos
        ws1 = wb.create_sheet("Resumen por Elementos")
        
        # Configurar encabezados de la Hoja 1
        headers_resumen = ["Elemento", "Cantidad Total", "Cantidad Valorada", "Cantidad No Valorada"]
        for col, header in enumerate(headers_resumen, 1):
            cell = ws1.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = header_alignment
            cell.border = border
        
        # Mapeo de elementos para el resumen
        elementos_resumen = {
            'Pantalón': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Camiseta Gris': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Guerrera': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Camiseta Polo': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Chaqueta': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Guantes Nitrilo': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Guantes Carnaza': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Gafas': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Gorra': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Casco': {'total': 0, 'valorado': 0, 'no_valorado': 0},
            'Botas': {'total': 0, 'valorado': 0, 'no_valorado': 0}
        }
        
        # Procesar datos para el resumen
        for cambio in cambios:
            elementos_data = [
                ('Pantalón', cambio['pantalon'], cambio['estado_pantalon']),
                ('Camiseta Gris', cambio['camisetagris'], cambio['estado_camiseta_gris']),
                ('Guerrera', cambio['guerrera'], cambio['estado_guerrera']),
                ('Camiseta Polo', cambio['camisetapolo'], cambio['estado_camiseta_polo']),
                ('Chaqueta', cambio['chaqueta'], cambio['estado_chaqueta']),
                ('Guantes Nitrilo', cambio['guantes_nitrilo'], cambio['estado_guantes_nitrilo']),
                ('Guantes Carnaza', cambio['guantes_carnaza'], cambio['estado_guantes_carnaza']),
                ('Gafas', cambio['gafas'], cambio['estado_gafas']),
                ('Gorra', cambio['gorra'], cambio['estado_gorra']),
                ('Casco', cambio['casco'], cambio['estado_casco']),
                ('Botas', cambio['botas'], cambio['estado_botas'])
            ]
            
            for nombre_elemento, cantidad, estado in elementos_data:
                if cantidad and cantidad > 0:
                    elementos_resumen[nombre_elemento]['total'] += cantidad
                    if estado == 'VALORADO':
                        elementos_resumen[nombre_elemento]['valorado'] += cantidad
                    else:
                        elementos_resumen[nombre_elemento]['no_valorado'] += cantidad
        
        # Escribir datos del resumen
        row = 2
        for elemento, datos in elementos_resumen.items():
            ws1.cell(row=row, column=1, value=elemento).border = border
            ws1.cell(row=row, column=2, value=datos['total']).border = border
            ws1.cell(row=row, column=3, value=datos['valorado']).border = border
            ws1.cell(row=row, column=4, value=datos['no_valorado']).border = border
            row += 1
        
        # Ajustar ancho de columnas de la Hoja 1
        for col in range(1, 5):
            ws1.column_dimensions[get_column_letter(col)].width = 20
        
        # HOJA 2: Historial Completo
        ws2 = wb.create_sheet("Historial Completo")
        
        # Configurar encabezados de la Hoja 2
        headers_historial = [
            "ID", "Técnico", "Cédula", "Fecha Cambio", "Fecha Registro",
            "Pantalón", "Talla Pantalón", "Estado Pantalón",
            "Camiseta Gris", "Talla Camiseta Gris", "Estado Camiseta Gris",
            "Guerrera", "Talla Guerrera", "Estado Guerrera",
            "Camiseta Polo", "Talla Camiseta Polo", "Estado Camiseta Polo",
            "Chaqueta", "Talla Chaqueta", "Estado Chaqueta",
            "Guantes Nitrilo", "Estado Guantes Nitrilo",
            "Guantes Carnaza", "Estado Guantes Carnaza",
            "Gafas", "Estado Gafas",
            "Gorra", "Estado Gorra",
            "Casco", "Estado Casco",
            "Botas", "Talla Botas", "Estado Botas",
            "Observaciones"
        ]
        
        for col, header in enumerate(headers_historial, 1):
            cell = ws2.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = header_alignment
            cell.border = border
        
        # Escribir datos del historial
        row = 2
        for cambio in cambios:
            ws2.cell(row=row, column=1, value=cambio['id']).border = border
            ws2.cell(row=row, column=2, value=cambio['tecnico_nombre'] or 'No disponible').border = border
            ws2.cell(row=row, column=3, value=cambio['tecnico_cedula'] or 'No disponible').border = border
            ws2.cell(row=row, column=4, value=cambio['fecha_cambio'].strftime('%Y-%m-%d') if cambio['fecha_cambio'] else '').border = border
            ws2.cell(row=row, column=5, value=cambio['created_at'].strftime('%Y-%m-%d %H:%M:%S') if cambio['created_at'] else '').border = border
            
            # Elementos de dotación
            col = 6
            elementos_data = [
                (cambio['pantalon'], cambio['pantalon_talla'], cambio['estado_pantalon']),
                (cambio['camisetagris'], cambio['camiseta_gris_talla'], cambio['estado_camiseta_gris']),
                (cambio['guerrera'], cambio['guerrera_talla'], cambio['estado_guerrera']),
                (cambio['camisetapolo'], cambio['camiseta_polo_talla'], cambio['estado_camiseta_polo']),
                (cambio['chaqueta'], cambio['chaqueta_talla'], cambio['estado_chaqueta']),
                (cambio['guantes_nitrilo'], None, cambio['estado_guantes_nitrilo']),
                (cambio['guantes_carnaza'], None, cambio['estado_guantes_carnaza']),
                (cambio['gafas'], None, cambio['estado_gafas']),
                (cambio['gorra'], None, cambio['estado_gorra']),
                (cambio['casco'], None, cambio['estado_casco']),
                (cambio['botas'], cambio['botas_talla'], cambio['estado_botas'])
            ]
            
            for cantidad, talla, estado in elementos_data:
                ws2.cell(row=row, column=col, value=cantidad or 0).border = border
                col += 1
                if talla is not None:  # Solo para elementos con talla
                    ws2.cell(row=row, column=col, value=talla or '').border = border
                    col += 1
                ws2.cell(row=row, column=col, value=estado or 'NO VALORADO').border = border
                col += 1
            
            ws2.cell(row=row, column=col, value=cambio['observaciones'] or '').border = border
            row += 1
        
        # Ajustar ancho de columnas de la Hoja 2
        for col in range(1, len(headers_historial) + 1):
            ws2.column_dimensions[get_column_letter(col)].width = 15
        
        cursor.close()
        connection.close()
        
        # Crear el archivo en memoria
        output = io.BytesIO()
        wb.save(output)
        output.seek(0)
        
        # Generar nombre del archivo con timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'cambios_dotacion_{timestamp}.xlsx'
        
        # Crear la respuesta
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = f'attachment; filename={filename}'
        
        return response
        
    except Exception as e:
        print(f"Error al exportar cambios de dotación: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error al exportar: {str(e)}'
        }), 500

@app.route('/api/cambios_dotacion/exportar_csv', methods=['GET'])
@login_required()
@role_required('logistica')
def api_cambios_dotacion_exportar_csv():
    """API para exportar cambios de dotación a CSV con una fila por elemento modificado"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        import csv
        import io
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Consulta para obtener todos los cambios de dotación
        query = """
            SELECT 
                cd.id_cambio as id,
                cd.id_codigo_consumidor,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula,
                cd.fecha_cambio,
                cd.pantalon,
                cd.pantalon_talla,
                cd.estado_pantalon,
                cd.camisetagris,
                cd.camiseta_gris_talla,
                cd.estado_camiseta_gris,
                cd.guerrera,
                cd.guerrera_talla,
                cd.estado_guerrera,
                cd.camisetapolo,
                cd.camiseta_polo_talla,
                cd.estado_camiseta_polo,
                cd.chaqueta,
                cd.chaqueta_talla,
                cd.estado_chaqueta,
                cd.guantes_nitrilo,
                cd.estado_guantes_nitrilo,
                cd.guantes_carnaza,
                cd.estado_guantes_carnaza,
                cd.gafas,
                cd.estado_gafas,
                cd.gorra,
                cd.estado_gorra,
                cd.casco,
                cd.estado_casco,
                cd.botas,
                cd.botas_talla,
                cd.estado_botas,
                cd.observaciones,
                cd.fecha_registro as created_at
            FROM cambios_dotacion cd
            LEFT JOIN recurso_operativo ro ON cd.id_codigo_consumidor = ro.id_codigo_consumidor
            ORDER BY cd.fecha_cambio DESC, cd.fecha_registro DESC
        """
        
        cursor.execute(query)
        cambios = cursor.fetchall()
        
        # Crear el archivo CSV en memoria
        output = io.StringIO()
        
        # Definir las nuevas columnas del CSV - una fila por elemento
        fieldnames = [
            'Tecnico',
            'Cedula',
            'Fecha_Cambio',
            'Elemento_Modificado',
            'Cantidad',
            'Talla',
            'Estado',
            'Observaciones',
            'Fecha_Registro'
        ]
        
        # Crear el writer CSV con delimitador de coma y quoting mínimo
        writer = csv.DictWriter(output, fieldnames=fieldnames, delimiter=',', quoting=csv.QUOTE_MINIMAL)
        
        # Escribir encabezados
        writer.writeheader()
        
        # Definir los elementos de dotación con sus campos correspondientes
        elementos_dotacion = [
            ('pantalon', 'pantalon', 'pantalon_talla', 'estado_pantalon'),
            ('camiseta_gris', 'camisetagris', 'camiseta_gris_talla', 'estado_camiseta_gris'),
            ('guerrera', 'guerrera', 'guerrera_talla', 'estado_guerrera'),
            ('camiseta_polo', 'camisetapolo', 'camiseta_polo_talla', 'estado_camiseta_polo'),
            ('chaqueta', 'chaqueta', 'chaqueta_talla', 'estado_chaqueta'),
            ('guantes_nitrilo', 'guantes_nitrilo', None, 'estado_guantes_nitrilo'),
            ('guantes_carnaza', 'guantes_carnaza', None, 'estado_guantes_carnaza'),
            ('gafas', 'gafas', None, 'estado_gafas'),
            ('gorra', 'gorra', None, 'estado_gorra'),
            ('casco', 'casco', None, 'estado_casco'),
            ('botas', 'botas', 'botas_talla', 'estado_botas')
        ]
        
        # Escribir datos - una fila por elemento modificado
        for cambio in cambios:
            # Datos comunes del técnico y cambio
            tecnico = str(cambio['tecnico_nombre'] or 'No disponible').strip()
            cedula = str(cambio['tecnico_cedula'] or 'No disponible').strip()
            fecha_cambio = cambio['fecha_cambio'].strftime('%d/%m/%Y') if cambio['fecha_cambio'] else ''
            observaciones = str(cambio['observaciones'] or '').strip()
            fecha_registro = cambio['created_at'].strftime('%d/%m/%Y %H:%M') if cambio['created_at'] else ''
            
            # Iterar por cada elemento de dotación
            for elemento_nombre, campo_cantidad, campo_talla, campo_estado in elementos_dotacion:
                cantidad = cambio.get(campo_cantidad, 0) or 0
                
                # Solo incluir elementos con cantidad > 0
                if cantidad > 0:
                    talla = ''
                    if campo_talla and cambio.get(campo_talla):
                        talla = str(cambio[campo_talla]).strip()
                    
                    estado = str(cambio.get(campo_estado, 'NO VALORADO') or 'NO VALORADO').strip()
                    
                    row = {
                        'Tecnico': tecnico,
                        'Cedula': cedula,
                        'Fecha_Cambio': fecha_cambio,
                        'Elemento_Modificado': elemento_nombre,
                        'Cantidad': str(cantidad).strip(),
                        'Talla': talla,
                        'Estado': estado,
                        'Observaciones': observaciones,
                        'Fecha_Registro': fecha_registro
                    }
                    writer.writerow(row)
        
        cursor.close()
        connection.close()
        
        # Obtener el contenido CSV sin BOM para evitar problemas de formato
        csv_content = output.getvalue()
        csv_bytes = csv_content.encode('utf-8')
        
        # Generar nombre del archivo con timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'cambios_dotacion_detallado_{timestamp}.csv'
        
        # Crear la respuesta
        response = make_response(csv_bytes)
        response.headers['Content-Type'] = 'text/csv; charset=utf-8'
        response.headers['Content-Disposition'] = f'attachment; filename={filename}'
        
        return response
        
    except Exception as e:
        print(f"Error al exportar cambios de dotación CSV: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error al exportar CSV: {str(e)}'
        }), 500

@app.route('/api/validar_pin', methods=['POST'])
@login_required()
def api_validar_pin():
    """API para validar el PIN del usuario logueado - Optimizado para respuesta rápida"""
    connection = None
    cursor = None
    
    try:
        # Validación rápida de datos de entrada
        data = request.get_json()
        if not data or 'pin' not in data:
            return jsonify({
                'success': False,
                'error': 'PIN no proporcionado'
            }), 400
        
        pin_ingresado = data['pin'].strip()
        usuario_id = session.get('user_id')
        
        if not usuario_id:
            return jsonify({
                'success': False,
                'error': 'Usuario no autenticado'
            }), 401
        
        # Validación básica del PIN ingresado
        if not pin_ingresado or len(pin_ingresado) < 4:
            return jsonify({
                'success': False,
                'error': 'PIN debe tener al menos 4 dígitos'
            }), 400
        
        # Conectar a la base de datos con timeout optimizado
        connection = mysql.connector.connect(
            **db_config,
            connection_timeout=5,  # Timeout de conexión de 5 segundos
            autocommit=True
        )
        cursor = connection.cursor()
        
        # Consulta optimizada - usar la columna correcta id_codigo_consumidor
        query = """
            SELECT pin 
            FROM recurso_operativo 
            WHERE id_codigo_consumidor = %s
            LIMIT 1
        """
        
        # Ejecutar consulta con timeout
        cursor.execute(query, (usuario_id,))
        result = cursor.fetchone()
        
        # Verificar si el usuario existe
        if not result:
            return jsonify({
                'success': False,
                'error': 'Usuario no encontrado en recursos operativos'
            }), 404
        
        pin_usuario = result[0]
        
        # Verificación rápida si el usuario tiene PIN asignado
        if pin_usuario is None or pin_usuario == 0:
            return jsonify({
                'success': False,
                'error': 'No tiene PIN asignado. Contacte al administrador para configurar su PIN de seguridad.'
            }), 403
        
        # Validar el PIN (conversión a string para comparación)
        if str(pin_ingresado) == str(pin_usuario):
            return jsonify({
                'success': True,
                'message': 'PIN validado correctamente'
            })
        else:
            return jsonify({
                'success': False,
                'error': 'PIN incorrecto'
            }), 401
            
    except mysql.connector.Error as err:
        print(f"Error de base de datos al validar PIN: {err}")
        return jsonify({
            'success': False,
            'error': 'Error de conexión con la base de datos'
        }), 500
    except Exception as e:
        print(f"Error al validar PIN: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Error interno del servidor'
        }), 500
    finally:
        # Cerrar conexiones de forma segura
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

@app.route('/api/cambios_dotacion/<int:cambio_id>', methods=['PUT'])
@login_required()
@role_required('logistica')
def api_actualizar_cambio_dotacion(cambio_id):
    """API para actualizar un cambio de dotación existente"""
    try:
        # Obtener datos del formulario
        data = request.get_json()
        
        if not data:
            return jsonify({
                'success': False,
                'error': 'No se recibieron datos para actualizar'
            }), 400
        
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Verificar que el registro existe
        cursor.execute("SELECT id_cambio FROM cambios_dotacion WHERE id_cambio = %s", (cambio_id,))
        if not cursor.fetchone():
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': 'El registro no existe'
            }), 404
        
        # Preparar los datos para actualizar
        fecha_cambio = data.get('fecha_cambio')
        observaciones = data.get('observaciones', '')
        
        # Elementos de dotación con sus cantidades, tallas y estados
        elementos = {
            'pantalon': {
                'cantidad': int(data.get('pantalon', 0)) if data.get('pantalon') else 0,
                'talla': data.get('pantalon_talla', ''),
                'estado': 'VALORADO' if data.get('estado_pantalon') else 'NO VALORADO'
            },
            'camisetagris': {
                'cantidad': int(data.get('camisetagris', 0)) if data.get('camisetagris') else 0,
                'talla': data.get('camiseta_gris_talla', ''),
                'estado': 'VALORADO' if data.get('estado_camiseta_gris') else 'NO VALORADO'
            },
            'guerrera': {
                'cantidad': int(data.get('guerrera', 0)) if data.get('guerrera') else 0,
                'talla': data.get('guerrera_talla', ''),
                'estado': 'VALORADO' if data.get('estado_guerrera') else 'NO VALORADO'
            },
            'camisetapolo': {
                'cantidad': int(data.get('camisetapolo', 0)) if data.get('camisetapolo') else 0,
                'talla': data.get('camiseta_polo_talla', ''),
                'estado': 'VALORADO' if data.get('estado_camiseta_polo') else 'NO VALORADO'
            },
            'botas': {
                'cantidad': int(data.get('botas', 0)) if data.get('botas') else 0,
                'talla': data.get('botas_talla', ''),
                'estado': 'VALORADO' if data.get('estado_botas') else 'NO VALORADO'
            },
            'guantes_nitrilo': {
                'cantidad': int(data.get('guantes_nitrilo', 0)) if data.get('guantes_nitrilo') else 0,
                'talla': '',
                'estado': 'VALORADO' if data.get('estado_guantes_nitrilo') else 'NO VALORADO'
            },
            'guantes_carnaza': {
                'cantidad': int(data.get('guantes_carnaza', 0)) if data.get('guantes_carnaza') else 0,
                'talla': '',
                'estado': 'VALORADO' if data.get('estado_guantes_carnaza') else 'NO VALORADO'
            },
            'gafas': {
                'cantidad': int(data.get('gafas', 0)) if data.get('gafas') else 0,
                'talla': '',
                'estado': 'VALORADO' if data.get('estado_gafas') else 'NO VALORADO'
            },
            'gorra': {
                'cantidad': int(data.get('gorra', 0)) if data.get('gorra') else 0,
                'talla': '',
                'estado': 'VALORADO' if data.get('estado_gorra') else 'NO VALORADO'
            },
            'casco': {
                'cantidad': int(data.get('casco', 0)) if data.get('casco') else 0,
                'talla': '',
                'estado': 'VALORADO' if data.get('estado_casco') else 'NO VALORADO'
            },
            'chaqueta': {
                'cantidad': int(data.get('chaqueta', 0)) if data.get('chaqueta') else 0,
                'talla': data.get('chaqueta_talla', ''),
                'estado': 'VALORADO' if data.get('estado_chaqueta') else 'NO VALORADO'
            }
        }
        
        # Construir la consulta de actualización
        update_query = """
            UPDATE cambios_dotacion SET
                fecha_cambio = %s,
                pantalon = %s,
                pantalon_talla = %s,
                estado_pantalon = %s,
                camisetagris = %s,
                camiseta_gris_talla = %s,
                estado_camiseta_gris = %s,
                guerrera = %s,
                guerrera_talla = %s,
                estado_guerrera = %s,
                camisetapolo = %s,
                camiseta_polo_talla = %s,
                estado_camiseta_polo = %s,
                botas = %s,
                botas_talla = %s,
                estado_botas = %s,
                guantes_nitrilo = %s,
                estado_guantes_nitrilo = %s,
                guantes_carnaza = %s,
                estado_guantes_carnaza = %s,
                gafas = %s,
                estado_gafas = %s,
                gorra = %s,
                estado_gorra = %s,
                casco = %s,
                estado_casco = %s,
                chaqueta = %s,
                chaqueta_talla = %s,
                estado_chaqueta = %s,
                observaciones = %s
            WHERE id_cambio = %s
        """
        
        # Preparar los valores para la consulta
        valores = [
            fecha_cambio,
            elementos['pantalon']['cantidad'],
            elementos['pantalon']['talla'] if elementos['pantalon']['talla'] else None,
            elementos['pantalon']['estado'],
            elementos['camisetagris']['cantidad'],
            elementos['camisetagris']['talla'] if elementos['camisetagris']['talla'] else None,
            elementos['camisetagris']['estado'],
            elementos['guerrera']['cantidad'],
            elementos['guerrera']['talla'] if elementos['guerrera']['talla'] else None,
            elementos['guerrera']['estado'],
            elementos['camisetapolo']['cantidad'],
            elementos['camisetapolo']['talla'] if elementos['camisetapolo']['talla'] else None,
            elementos['camisetapolo']['estado'],
            elementos['botas']['cantidad'],
            elementos['botas']['talla'] if elementos['botas']['talla'] else None,
            elementos['botas']['estado'],
            elementos['guantes_nitrilo']['cantidad'],
            elementos['guantes_nitrilo']['estado'],
            elementos['guantes_carnaza']['cantidad'],
            elementos['guantes_carnaza']['estado'],
            elementos['gafas']['cantidad'],
            elementos['gafas']['estado'],
            elementos['gorra']['cantidad'],
            elementos['gorra']['estado'],
            elementos['casco']['cantidad'],
            elementos['casco']['estado'],
            elementos['chaqueta']['cantidad'],
            elementos['chaqueta']['talla'] if elementos['chaqueta']['talla'] else None,
            elementos['chaqueta']['estado'],
            observaciones,
            cambio_id
        ]
        
        # Ejecutar la actualización
        print(f"Ejecutando actualización para cambio_id: {cambio_id}")
        print(f"Consulta SQL: {update_query}")
        print(f"Valores: {valores}")
        
        cursor.execute(update_query, valores)
        connection.commit()
        
        # Verificar que se actualizó al menos un registro
        if cursor.rowcount == 0:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': 'No se pudo actualizar el registro. Verifique que el ID sea válido.'
            }), 400
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Cambio de dotación actualizado exitosamente'
        })
        
    except mysql.connector.Error as db_error:
        print(f"Error de base de datos al actualizar cambio de dotación: {str(db_error)}")
        if 'connection' in locals():
            connection.close()
        return jsonify({
            'success': False,
            'error': f'Error de base de datos: {str(db_error)}'
        }), 500
    except Exception as e:
        print(f"Error general al actualizar cambio de dotación: {str(e)}")
        if 'connection' in locals():
            connection.close()
        return jsonify({
            'success': False,
            'error': f'Error al actualizar el registro: {str(e)}'
        }), 500

@app.route('/api/indicadores_cambios_dotacion', methods=['GET'])
@login_required()
@role_required('logistica')
def api_indicadores_cambios_dotacion():
    """API para obtener datos de indicadores de cambios de dotación para gráficas"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener parámetros de filtros
        estado_valorado = request.args.get('estado_valorado', 'todos')  # 'valorado', 'no_valorado', 'todos'
        mes = request.args.get('mes', '')  # 1-12 o vacío para todos
        elemento = request.args.get('elemento', 'todos')  # nombre del elemento o 'todos'
        anio = request.args.get('anio', str(datetime.now().year))  # año actual por defecto
        
        # Construir la consulta base
        base_query = """
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'pantalon' as elemento_tipo,
                'Pantalón' as elemento_nombre,
                SUM(cd.pantalon) as cantidad_total,
                SUM(CASE WHEN cd.estado_pantalon = 'VALORADO' THEN cd.pantalon ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_pantalon != 'VALORADO' OR cd.estado_pantalon IS NULL THEN cd.pantalon ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.pantalon > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'camisetagris' as elemento_tipo,
                'Camiseta Gris' as elemento_nombre,
                SUM(cd.camisetagris) as cantidad_total,
                SUM(CASE WHEN cd.estado_camiseta_gris = 'VALORADO' THEN cd.camisetagris ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_camiseta_gris != 'VALORADO' OR cd.estado_camiseta_gris IS NULL THEN cd.camisetagris ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.camisetagris > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'guerrera' as elemento_tipo,
                'Guerrera' as elemento_nombre,
                SUM(cd.guerrera) as cantidad_total,
                SUM(CASE WHEN cd.estado_guerrera = 'VALORADO' THEN cd.guerrera ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_guerrera != 'VALORADO' OR cd.estado_guerrera IS NULL THEN cd.guerrera ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.guerrera > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'camisetapolo' as elemento_tipo,
                'Camiseta Polo' as elemento_nombre,
                SUM(cd.camisetapolo) as cantidad_total,
                SUM(CASE WHEN cd.estado_camiseta_polo = 'VALORADO' THEN cd.camisetapolo ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_camiseta_polo != 'VALORADO' OR cd.estado_camiseta_polo IS NULL THEN cd.camisetapolo ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.camisetapolo > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'guantes_nitrilo' as elemento_tipo,
                'Guantes Nitrilo' as elemento_nombre,
                SUM(cd.guantes_nitrilo) as cantidad_total,
                SUM(CASE WHEN cd.estado_guantes_nitrilo = 'VALORADO' THEN cd.guantes_nitrilo ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_guantes_nitrilo != 'VALORADO' OR cd.estado_guantes_nitrilo IS NULL THEN cd.guantes_nitrilo ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.guantes_nitrilo > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'guantes_carnaza' as elemento_tipo,
                'Guantes Carnaza' as elemento_nombre,
                SUM(cd.guantes_carnaza) as cantidad_total,
                SUM(CASE WHEN cd.estado_guantes_carnaza = 'VALORADO' THEN cd.guantes_carnaza ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_guantes_carnaza != 'VALORADO' OR cd.estado_guantes_carnaza IS NULL THEN cd.guantes_carnaza ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.guantes_carnaza > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'gafas' as elemento_tipo,
                'Gafas' as elemento_nombre,
                SUM(cd.gafas) as cantidad_total,
                SUM(CASE WHEN cd.estado_gafas = 'VALORADO' THEN cd.gafas ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_gafas != 'VALORADO' OR cd.estado_gafas IS NULL THEN cd.gafas ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.gafas > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'gorra' as elemento_tipo,
                'Gorra' as elemento_nombre,
                SUM(cd.gorra) as cantidad_total,
                SUM(CASE WHEN cd.estado_gorra = 'VALORADO' THEN cd.gorra ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_gorra != 'VALORADO' OR cd.estado_gorra IS NULL THEN cd.gorra ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.gorra > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'casco' as elemento_tipo,
                'Casco' as elemento_nombre,
                SUM(cd.casco) as cantidad_total,
                SUM(CASE WHEN cd.estado_casco = 'VALORADO' THEN cd.casco ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_casco != 'VALORADO' OR cd.estado_casco IS NULL THEN cd.casco ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.casco > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            UNION ALL
            
            SELECT 
                MONTH(cd.fecha_cambio) as mes,
                YEAR(cd.fecha_cambio) as anio,
                'botas' as elemento_tipo,
                'Botas' as elemento_nombre,
                SUM(cd.botas) as cantidad_total,
                SUM(CASE WHEN cd.estado_botas = 'VALORADO' THEN cd.botas ELSE 0 END) as cantidad_valorado,
                SUM(CASE WHEN cd.estado_botas != 'VALORADO' OR cd.estado_botas IS NULL THEN cd.botas ELSE 0 END) as cantidad_no_valorado
            FROM cambios_dotacion cd
            WHERE cd.botas > 0 AND YEAR(cd.fecha_cambio) = %s
            GROUP BY MONTH(cd.fecha_cambio), YEAR(cd.fecha_cambio)
            
            ORDER BY mes, elemento_nombre
        """
        
        # Ejecutar consulta con parámetros (año repetido para cada UNION)
        params = [anio] * 10  # 10 elementos diferentes
        cursor.execute(base_query, params)
        resultados = cursor.fetchall()
        
        # Procesar y filtrar resultados según los parámetros
        if mes and mes != '':
            # Filtro por mes específico - comportamiento actual
            datos_filtrados = []
            for row in resultados:
                # Aplicar filtro de mes si se especifica
                if str(row['mes']) != str(mes):
                    continue
                    
                # Aplicar filtro de elemento si se especifica
                if elemento != 'todos' and row['elemento_tipo'] != elemento:
                    continue
                    
                # Aplicar filtro de estado valorado
                if estado_valorado == 'valorado':
                    cantidad_mostrar = row['cantidad_valorado']
                elif estado_valorado == 'no_valorado':
                    cantidad_mostrar = row['cantidad_no_valorado']
                else:  # 'todos'
                    cantidad_mostrar = row['cantidad_total']
                
                # Solo incluir si hay cantidad para mostrar
                if cantidad_mostrar > 0:
                    datos_filtrados.append({
                        'mes': row['mes'],
                        'anio': row['anio'],
                        'elemento_tipo': row['elemento_tipo'],
                        'elemento_nombre': row['elemento_nombre'],
                        'cantidad': cantidad_mostrar,
                        'cantidad_total': row['cantidad_total'],
                        'cantidad_valorado': row['cantidad_valorado'],
                        'cantidad_no_valorado': row['cantidad_no_valorado']
                    })
        else:
            # Todos los meses - agregar datos por elemento
            elementos_agregados = {}
            
            for row in resultados:
                # Aplicar filtro de elemento si se especifica
                if elemento != 'todos' and row['elemento_tipo'] != elemento:
                    continue
                
                elemento_key = row['elemento_tipo']
                
                # Aplicar filtro de estado valorado
                if estado_valorado == 'valorado':
                    cantidad_mostrar = row['cantidad_valorado']
                elif estado_valorado == 'no_valorado':
                    cantidad_mostrar = row['cantidad_no_valorado']
                else:  # 'todos'
                    cantidad_mostrar = row['cantidad_total']
                
                # Agregar al elemento existente o crear nuevo
                if elemento_key in elementos_agregados:
                    elementos_agregados[elemento_key]['cantidad'] += cantidad_mostrar
                    elementos_agregados[elemento_key]['cantidad_total'] += row['cantidad_total']
                    elementos_agregados[elemento_key]['cantidad_valorado'] += row['cantidad_valorado']
                    elementos_agregados[elemento_key]['cantidad_no_valorado'] += row['cantidad_no_valorado']
                else:
                    elementos_agregados[elemento_key] = {
                        'mes': None,  # No hay mes específico para datos agregados
                        'anio': row['anio'],
                        'elemento_tipo': row['elemento_tipo'],
                        'elemento_nombre': row['elemento_nombre'],
                        'cantidad': cantidad_mostrar,
                        'cantidad_total': row['cantidad_total'],
                        'cantidad_valorado': row['cantidad_valorado'],
                        'cantidad_no_valorado': row['cantidad_no_valorado']
                    }
            
            # Convertir a lista y filtrar elementos con cantidad > 0
            datos_filtrados = []
            for elemento_data in elementos_agregados.values():
                if elemento_data['cantidad'] > 0:
                    datos_filtrados.append(elemento_data)
        
        # Obtener años disponibles para el filtro
        cursor.execute("""
            SELECT DISTINCT YEAR(fecha_cambio) as anio 
            FROM cambios_dotacion 
            WHERE fecha_cambio IS NOT NULL 
            ORDER BY anio DESC
        """)
        anios_disponibles = [row['anio'] for row in cursor.fetchall()]
        
        # Obtener elementos disponibles para el filtro
        elementos_disponibles = [
            {'tipo': 'pantalon', 'nombre': 'Pantalón'},
            {'tipo': 'camisetagris', 'nombre': 'Camiseta Gris'},
            {'tipo': 'guerrera', 'nombre': 'Guerrera'},
            {'tipo': 'camisetapolo', 'nombre': 'Camiseta Polo'},
            {'tipo': 'guantes_nitrilo', 'nombre': 'Guantes Nitrilo'},
            {'tipo': 'guantes_carnaza', 'nombre': 'Guantes Carnaza'},
            {'tipo': 'gafas', 'nombre': 'Gafas'},
            {'tipo': 'gorra', 'nombre': 'Gorra'},
            {'tipo': 'casco', 'nombre': 'Casco'},
            {'tipo': 'botas', 'nombre': 'Botas'}
        ]
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'data': datos_filtrados,
            'filtros': {
                'anios_disponibles': anios_disponibles,
                'elementos_disponibles': elementos_disponibles,
                'meses': [
                    {'numero': 1, 'nombre': 'Enero'},
                    {'numero': 2, 'nombre': 'Febrero'},
                    {'numero': 3, 'nombre': 'Marzo'},
                    {'numero': 4, 'nombre': 'Abril'},
                    {'numero': 5, 'nombre': 'Mayo'},
                    {'numero': 6, 'nombre': 'Junio'},
                    {'numero': 7, 'nombre': 'Julio'},
                    {'numero': 8, 'nombre': 'Agosto'},
                    {'numero': 9, 'nombre': 'Septiembre'},
                    {'numero': 10, 'nombre': 'Octubre'},
                    {'numero': 11, 'nombre': 'Noviembre'},
                    {'numero': 12, 'nombre': 'Diciembre'}
                ]
            },
            'filtros_aplicados': {
                'estado_valorado': estado_valorado,
                'mes': mes,
                'elemento': elemento,
                'anio': anio
            }
        })
        
    except Exception as e:
        print(f"Error al obtener indicadores de cambios de dotación: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error al cargar los indicadores: {str(e)}'
        }), 500

@app.route('/logistica/registrar_devolucion_dotacion', methods=['POST'])
@login_required()
@role_required('logistica')
def registrar_devolucion_dotacion():
    """Procesar registro de devolución de dotación"""
    try:
        # Conectar a la base de datos capired
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Obtener datos del formulario
        tecnico_id = request.form.get('tecnico_id')
        cliente_id = request.form.get('cliente_id')
        fecha_devolucion = request.form.get('fecha_devolucion')
        motivo = request.form.get('motivo')
        observaciones = request.form.get('observaciones', '')
        estado = request.form.get('estado', 'REGISTRADA')
        created_by = session.get('user_id')
        
        # Validaciones básicas
        if not tecnico_id or not cliente_id or not motivo:
            flash('Técnico, cliente y motivo son campos obligatorios', 'danger')
            return redirect(url_for('devoluciones_dotacion'))
        
        # Obtener el nombre del cliente basado en el ID
        cursor_temp = connection.cursor(dictionary=True)
        cursor_temp.execute("""
            SELECT cliente as nombre
            FROM (
                SELECT 
                    ROW_NUMBER() OVER (ORDER BY cliente ASC) as id,
                    cliente
                FROM (
                    SELECT DISTINCT cliente
                    FROM recurso_operativo 
                    WHERE cliente IS NOT NULL AND cliente != '' AND estado = 'Activo'
                ) as clientes_unicos
            ) as clientes_numerados
            WHERE id = %s
        """, (cliente_id,))
        cliente_data = cursor_temp.fetchone()
        cursor_temp.close()
        
        if not cliente_data:
            flash('Cliente no válido', 'danger')
            return redirect(url_for('devoluciones_dotacion'))
        
        cliente_nombre = cliente_data['nombre']
        
        # Insertar en la base de datos
        query = """
            INSERT INTO devoluciones_dotacion (
                tecnico_id, cliente_id, fecha_devolucion, motivo, 
                observaciones, estado, created_by
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
        """
        
        cursor.execute(query, (
            tecnico_id, cliente_id, fecha_devolucion, motivo,
            observaciones, estado, created_by
        ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        flash('Devolución de dotación registrada exitosamente', 'success')
        return redirect(url_for('devoluciones_dotacion'))
        
    except Exception as e:
        print(f"Error al registrar devolución de dotación: {str(e)}")
        flash(f'Error al registrar devolución: {str(e)}', 'danger')
        return redirect(url_for('devoluciones_dotacion'))

@app.route('/api/devoluciones/listar', methods=['GET'])
@login_required()
@role_required('logistica')
def listar_devoluciones():
    """API para listar todas las devoluciones registradas"""
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener devoluciones con información del técnico
        query = """
            SELECT 
                d.id,
                d.tecnico_id,
                ro.nombre as tecnico_nombre,
                d.cliente_id,
                d.fecha_devolucion,
                d.motivo,
                d.observaciones,
                d.estado,
                d.created_at,
                d.updated_at,
                COUNT(dd.id) as total_elementos
            FROM devoluciones_dotacion d
            LEFT JOIN recurso_operativo ro ON d.tecnico_id = ro.id_codigo_consumidor
            LEFT JOIN devolucion_detalles dd ON d.id = dd.devolucion_id
            GROUP BY d.id
            ORDER BY d.created_at DESC
        """
        
        cursor.execute(query)
        devoluciones = cursor.fetchall()
        
        # Obtener nombres de clientes para cada devolución
        for devolucion in devoluciones:
            cursor.execute("""
                SELECT cliente as nombre
                FROM (
                    SELECT 
                        ROW_NUMBER() OVER (ORDER BY cliente ASC) as id,
                        cliente
                    FROM (
                        SELECT DISTINCT cliente
                        FROM recurso_operativo 
                        WHERE cliente IS NOT NULL AND cliente != '' AND estado = 'Activo'
                    ) as clientes_unicos
                ) as clientes_numerados
                WHERE id = %s
            """, (devolucion['cliente_id'],))
            cliente_data = cursor.fetchone()
            devolucion['cliente_nombre'] = cliente_data['nombre'] if cliente_data else 'Cliente no encontrado'
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'devoluciones': devoluciones
        })
        
    except Exception as e:
        print(f"Error al listar devoluciones: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/devoluciones/<int:devolucion_id>/detalles', methods=['GET'])
@app.route('/obtener_detalles_devolucion/<int:devolucion_id>', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_detalles_devolucion(devolucion_id):
    """API para obtener detalles de una devolución específica"""
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener información de la devolución
        cursor.execute("""
            SELECT 
                d.*,
                ro.nombre as tecnico_nombre
            FROM devoluciones_dotacion d
            LEFT JOIN recurso_operativo ro ON d.tecnico_id = ro.id_codigo_consumidor
            WHERE d.id = %s
        """, (devolucion_id,))
        
        devolucion = cursor.fetchone()
        
        if not devolucion:
            return jsonify({
                'success': False,
                'error': 'Devolución no encontrada'
            }), 404
        
        # Obtener nombre del cliente
        cursor.execute("""
            SELECT cliente as nombre
            FROM (
                SELECT 
                    ROW_NUMBER() OVER (ORDER BY cliente ASC) as id,
                    cliente
                FROM (
                    SELECT DISTINCT cliente
                    FROM recurso_operativo 
                    WHERE cliente IS NOT NULL AND cliente != '' AND estado = 'Activo'
                ) as clientes_unicos
            ) as clientes_numerados
            WHERE id = %s
        """, (devolucion['cliente_id'],))
        cliente_data = cursor.fetchone()
        devolucion['cliente_nombre'] = cliente_data['nombre'] if cliente_data else 'Cliente no encontrado'
        
        # Obtener detalles de elementos devueltos
        cursor.execute("""
            SELECT *
            FROM devolucion_detalles
            WHERE devolucion_id = %s
            ORDER BY created_at ASC
        """, (devolucion_id,))
        
        detalles = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'devolucion': devolucion,
            'detalles': detalles
        })
        
    except Exception as e:
        print(f"Error al obtener detalles de devolución: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/devoluciones/<int:devolucion_id>/detalles', methods=['POST'])
@login_required()
@role_required('logistica')
def agregar_detalle_devolucion(devolucion_id):
    """API para agregar un elemento específico a una devolución"""
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Obtener datos del formulario
        data = request.get_json() if request.is_json else request.form
        
        elemento = data.get('elemento')
        talla = data.get('talla')
        cantidad = data.get('cantidad', 1)
        estado_elemento = data.get('estado_elemento', 'USADO_BUENO')
        observaciones = data.get('observaciones', '')
        
        # Validaciones
        if not elemento:
            return jsonify({
                'success': False,
                'error': 'El elemento es obligatorio'
            }), 400
        
        # Verificar que la devolución existe
        cursor.execute("SELECT id FROM devoluciones_dotacion WHERE id = %s", (devolucion_id,))
        if not cursor.fetchone():
            return jsonify({
                'success': False,
                'error': 'Devolución no encontrada'
            }), 404
        
        # Insertar detalle
        query = """
            INSERT INTO devolucion_detalles 
            (devolucion_id, elemento, talla, cantidad, estado_elemento, observaciones)
            VALUES (%s, %s, %s, %s, %s, %s)
        """
        
        cursor.execute(query, (
            devolucion_id, elemento, talla, cantidad, estado_elemento, observaciones
        ))
        
        detalle_id = cursor.lastrowid
        connection.commit()
        
        # Obtener el elemento recién creado
        cursor.execute("""
            SELECT id, devolucion_id, elemento, talla, cantidad, estado_elemento, observaciones, created_at
            FROM devolucion_detalles WHERE id = %s
        """, (detalle_id,))
        
        elemento_creado = cursor.fetchone()
        cursor.close()
        connection.close()
        
        # Formatear el elemento para la respuesta
        elemento_data = {
            'id': elemento_creado[0],
            'devolucion_id': elemento_creado[1],
            'elemento': elemento_creado[2],
            'talla': elemento_creado[3],
            'cantidad': elemento_creado[4],
            'estado_elemento': elemento_creado[5],
            'observaciones': elemento_creado[6],
            'created_at': elemento_creado[7].isoformat() if elemento_creado[7] else None
        }
        
        return jsonify({
            'success': True,
            'detalle_id': detalle_id,
            'elemento': elemento_data,
            'message': 'Elemento agregado exitosamente'
        })
        
    except Exception as e:
        print(f"Error al agregar detalle de devolución: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/devoluciones/detalles/<int:detalle_id>', methods=['PUT'])
@login_required()
@role_required('logistica')
def actualizar_detalle_devolucion(detalle_id):
    """API para actualizar un detalle específico de devolución"""
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Obtener datos del formulario
        data = request.get_json() if request.is_json else request.form
        
        elemento = data.get('elemento')
        talla = data.get('talla')
        cantidad = data.get('cantidad')
        estado_elemento = data.get('estado_elemento')
        observaciones = data.get('observaciones')
        
        # Construir query dinámicamente
        updates = []
        values = []
        
        if elemento:
            updates.append('elemento = %s')
            values.append(elemento)
        if talla is not None:
            updates.append('talla = %s')
            values.append(talla)
        if cantidad:
            updates.append('cantidad = %s')
            values.append(cantidad)
        if estado_elemento:
            updates.append('estado_elemento = %s')
            values.append(estado_elemento)
        if observaciones is not None:
            updates.append('observaciones = %s')
            values.append(observaciones)
        
        if not updates:
            return jsonify({
                'success': False,
                'error': 'No hay campos para actualizar'
            }), 400
        
        updates.append('updated_at = CURRENT_TIMESTAMP')
        values.append(detalle_id)
        
        query = f"UPDATE devolucion_detalles SET {', '.join(updates)} WHERE id = %s"
        
        cursor.execute(query, values)
        connection.commit()
        
        if cursor.rowcount == 0:
            return jsonify({
                'success': False,
                'error': 'Detalle no encontrado'
            }), 404
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Detalle actualizado exitosamente'
        })
        
    except Exception as e:
        print(f"Error al actualizar detalle de devolución: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/devoluciones/detalles/<int:detalle_id>', methods=['DELETE'])
@login_required()
@role_required('logistica')
def eliminar_detalle_devolucion(detalle_id):
    """API para eliminar un detalle específico de devolución"""
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        cursor.execute("DELETE FROM devolucion_detalles WHERE id = %s", (detalle_id,))
        connection.commit()
        
        if cursor.rowcount == 0:
            return jsonify({
                'success': False,
                'error': 'Detalle no encontrado'
            }), 404
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Detalle eliminado exitosamente'
        })
        
    except Exception as e:
        print(f"Error al eliminar detalle de devolución: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# ============================================================================
# SISTEMA DE GESTIÓN DE ESTADOS PARA DEVOLUCIONES
# ============================================================================

def validar_transicion_estado(estado_actual, estado_nuevo, usuario_id):
    """
    Valida si una transición de estado es permitida para un usuario específico
    
    Args:
        estado_actual (str): Estado actual de la devolución
        estado_nuevo (str): Estado al que se quiere transicionar
        usuario_id (int): ID del usuario que intenta hacer la transición
    
    Returns:
        dict: {'valida': bool, 'mensaje': str, 'rol_usuario': str}
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener rol del usuario
        cursor.execute("""
            SELECT r.id_roles as rol_id, r.nombre_rol as rol_nombre
            FROM recurso_operativo ro
            JOIN roles r ON ro.id_roles = r.id_roles
            WHERE ro.id_codigo_consumidor = %s
        """, (usuario_id,))
        
        usuario_rol = cursor.fetchone()
        
        if not usuario_rol:
            return {
                'valida': False,
                'mensaje': 'Usuario no encontrado o sin rol asignado',
                'rol_usuario': None
            }
        
        # Verificar si la transición está permitida para el rol
        cursor.execute("""
            SELECT permitido
            FROM permisos_transicion
            WHERE rol_id = %s AND estado_origen = %s AND estado_destino = %s
        """, (usuario_rol['rol_id'], estado_actual, estado_nuevo))
        
        permiso = cursor.fetchone()
        
        cursor.close()
        connection.close()
        
        if not permiso:
            return {
                'valida': False,
                'mensaje': f'Transición de {estado_actual} a {estado_nuevo} no está configurada para el rol {usuario_rol["rol_nombre"]}',
                'rol_usuario': usuario_rol['rol_nombre']
            }
        
        if not permiso['permitido']:
            return {
                'valida': False,
                'mensaje': f'No tiene permisos para cambiar de {estado_actual} a {estado_nuevo}',
                'rol_usuario': usuario_rol['rol_nombre']
            }
        
        return {
            'valida': True,
            'mensaje': 'Transición permitida',
            'rol_usuario': usuario_rol['rol_nombre']
        }
        
    except Exception as e:
        print(f"Error al validar transición: {str(e)}")
        return {
            'valida': False,
            'mensaje': f'Error interno: {str(e)}',
            'rol_usuario': None
        }

def registrar_auditoria_estado(devolucion_id, estado_anterior, estado_nuevo, usuario_id, motivo_cambio):
    """
    Registra un cambio de estado en la tabla de auditoría
    
    Args:
        devolucion_id (int): ID de la devolución
        estado_anterior (str): Estado previo
        estado_nuevo (str): Nuevo estado
        usuario_id (int): ID del usuario que realizó el cambio
        motivo_cambio (str): Motivo del cambio
    
    Returns:
        bool: True si se registró exitosamente, False en caso contrario
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        query = """
            INSERT INTO auditoria_estados 
            (devolucion_id, estado_anterior, estado_nuevo, usuario_id, motivo_cambio)
            VALUES (%s, %s, %s, %s, %s)
        """
        
        cursor.execute(query, (
            devolucion_id, estado_anterior, estado_nuevo, usuario_id, motivo_cambio
        ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return True
        
    except Exception as e:
        print(f"Error al registrar auditoría: {str(e)}")
        return False

def obtener_transiciones_validas(estado_actual, usuario_id):
    """
    Obtiene las transiciones válidas para un estado y usuario específico
    
    Args:
        estado_actual (str): Estado actual de la devolución
        usuario_id (int): ID del usuario
    
    Returns:
        list: Lista de estados a los que se puede transicionar
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener rol del usuario
        cursor.execute("""
            SELECT r.id_roles as rol_id
            FROM recurso_operativo ro
            JOIN roles r ON ro.id_roles = r.id_roles
            WHERE ro.id_codigo_consumidor = %s
        """, (usuario_id,))
        
        usuario_rol = cursor.fetchone()
        
        if not usuario_rol:
            return []
        
        # Obtener transiciones permitidas
        cursor.execute("""
            SELECT estado_destino
            FROM permisos_transicion
            WHERE rol_id = %s AND estado_origen = %s AND permitido = TRUE
        """, (usuario_rol['rol_id'], estado_actual))
        
        transiciones = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return [t['estado_destino'] for t in transiciones]
        
    except Exception as e:
        print(f"Error al obtener transiciones válidas: {str(e)}")
        return []

def enviar_notificacion_cambio_estado(devolucion_id, estado_anterior, estado_nuevo):
    """
    Envía notificaciones automáticas cuando cambia el estado
    
    Args:
        devolucion_id (int): ID de la devolución
        estado_anterior (str): Estado anterior
        estado_nuevo (str): Nuevo estado
    
    Returns:
        bool: True si se enviaron las notificaciones exitosamente
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener configuración de notificaciones para este cambio de estado
        cursor.execute("""
            SELECT cn.*, pe.nombre as plantilla_email_nombre, ps.nombre as plantilla_sms_nombre
            FROM configuracion_notificaciones cn
            LEFT JOIN plantillas_email pe ON cn.plantilla_email_id = pe.id
            LEFT JOIN plantillas_sms ps ON cn.plantilla_sms_id = ps.id
            WHERE cn.evento_trigger = 'CAMBIO_ESTADO' 
            AND (cn.estado_origen = %s OR cn.estado_origen IS NULL)
            AND cn.estado_destino = %s
            AND cn.activo = TRUE
        """, (estado_anterior, estado_nuevo))
        
        configuraciones = cursor.fetchall()
        
        if not configuraciones:
            print(f"No hay configuraciones de notificación para transición {estado_anterior} -> {estado_nuevo}")
            cursor.close()
            connection.close()
            return True
        
        # Obtener datos de la devolución
        cursor.execute("""
            SELECT d.*, c.nombre as cliente_nombre
            FROM devoluciones_dotacion d
            LEFT JOIN clientes c ON d.cliente_id = c.id
            WHERE d.id = %s
        """, (devolucion_id,))
        
        devolucion_data = cursor.fetchone()
        
        if not devolucion_data:
            print(f"Devolución {devolucion_id} no encontrada")
            cursor.close()
            connection.close()
            return False
        
        # Procesar cada configuración de notificación
        for config in configuraciones:
            # Obtener usuarios destinatarios según roles
            roles_destinatarios = config['destinatarios_roles']
            if isinstance(roles_destinatarios, str):
                import json
                roles_destinatarios = json.loads(roles_destinatarios)
            
            # Convertir nombres de roles a IDs
            placeholders = ','.join(['%s'] * len(roles_destinatarios))
            cursor.execute(f"""
                SELECT ro.id_codigo_consumidor as id, ro.nombre, r.nombre_rol as rol_nombre
                FROM recurso_operativo ro
                JOIN roles r ON ro.id_roles = r.id_roles
                WHERE r.nombre_rol IN ({placeholders}) AND ro.estado = 'Activo'
            """, roles_destinatarios)
            
            usuarios_destinatarios = cursor.fetchall()
            
            # Preparar variables para plantillas
            variables = {
                'devolucion_id': devolucion_id,
                'cliente_nombre': devolucion_data['cliente_nombre'] or 'N/A',
                'fecha_registro': devolucion_data['created_at'].strftime('%d/%m/%Y %H:%M'),
                'observaciones': devolucion_data['observaciones'] or 'Sin observaciones',
                'estado_anterior': estado_anterior,
                'estado_nuevo': estado_nuevo
            }
            
            # Enviar notificaciones según tipo
            for usuario in usuarios_destinatarios:
                if config['tipo_notificacion'] in ['EMAIL', 'AMBOS'] and usuario['email']:
                    programar_notificacion_email(devolucion_id, usuario, config, variables)
                
                if config['tipo_notificacion'] in ['SMS', 'AMBOS'] and usuario['telefono']:
                    programar_notificacion_sms(devolucion_id, usuario, config, variables)
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return True
        
    except Exception as e:
        print(f"Error al enviar notificaciones: {str(e)}")
        return False

def programar_notificacion_email(devolucion_id, usuario, config, variables):
    """
    Programa una notificación por email
    """
    try:
        import mysql.connector
        from datetime import datetime, timedelta
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener plantilla de email
        cursor.execute("""
            SELECT asunto, cuerpo_html, cuerpo_texto
            FROM plantillas_email
            WHERE id = %s AND activo = TRUE
        """, (config['plantilla_email_id'],))
        
        plantilla = cursor.fetchone()
        
        if not plantilla:
            print(f"Plantilla de email {config['plantilla_email_id']} no encontrada")
            return False
        
        # Reemplazar variables en la plantilla
        asunto = plantilla['asunto']
        cuerpo_html = plantilla['cuerpo_html']
        cuerpo_texto = plantilla['cuerpo_texto']
        
        for var, valor in variables.items():
            asunto = asunto.replace(f'{{{var}}}', str(valor))
            cuerpo_html = cuerpo_html.replace(f'{{{var}}}', str(valor))
            if cuerpo_texto:
                cuerpo_texto = cuerpo_texto.replace(f'{{{var}}}', str(valor))
        
        # Calcular fecha de envío (con delay si está configurado)
        fecha_programada = datetime.now()
        if config['delay_minutos'] > 0:
            fecha_programada += timedelta(minutes=config['delay_minutos'])
        
        # Insertar en historial de notificaciones
        cursor.execute("""
            INSERT INTO historial_notificaciones 
            (devolucion_id, tipo_notificacion, destinatario, asunto, mensaje, 
             fecha_programada, configuracion_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            devolucion_id, 'EMAIL', usuario['email'], asunto, 
            cuerpo_html, fecha_programada, config['id']
        ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        # Si no hay delay, enviar inmediatamente
        if config['delay_minutos'] == 0:
            enviar_email_inmediato(usuario['email'], asunto, cuerpo_html, cuerpo_texto)
        
        return True
        
    except Exception as e:
        print(f"Error al programar notificación email: {str(e)}")
        return False

def programar_notificacion_sms(devolucion_id, usuario, config, variables):
    """
    Programa una notificación por SMS
    """
    try:
        import mysql.connector
        from datetime import datetime, timedelta
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener plantilla de SMS
        cursor.execute("""
            SELECT mensaje
            FROM plantillas_sms
            WHERE id = %s AND activo = TRUE
        """, (config['plantilla_sms_id'],))
        
        plantilla = cursor.fetchone()
        
        if not plantilla:
            print(f"Plantilla de SMS {config['plantilla_sms_id']} no encontrada")
            return False
        
        # Reemplazar variables en la plantilla
        mensaje = plantilla['mensaje']
        for var, valor in variables.items():
            mensaje = mensaje.replace(f'{{{var}}}', str(valor))
        
        # Calcular fecha de envío
        fecha_programada = datetime.now()
        if config['delay_minutos'] > 0:
            fecha_programada += timedelta(minutes=config['delay_minutos'])
        
        # Insertar en historial de notificaciones
        cursor.execute("""
            INSERT INTO historial_notificaciones 
            (devolucion_id, tipo_notificacion, destinatario, mensaje, 
             fecha_programada, configuracion_id)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (
            devolucion_id, 'SMS', usuario['telefono'], mensaje, 
            fecha_programada, config['id']
        ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        # Si no hay delay, enviar inmediatamente
        if config['delay_minutos'] == 0:
            enviar_sms_inmediato(usuario['telefono'], mensaje)
        
        return True
        
    except Exception as e:
        print(f"Error al programar notificación SMS: {str(e)}")
        return False

def enviar_email_inmediato(destinatario, asunto, cuerpo_html, cuerpo_texto=None):
    """
    Envía un email inmediatamente usando la configuración SMTP
    """
    try:
        import smtplib
        import mysql.connector
        import json
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        # Obtener configuración SMTP
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT configuracion
            FROM configuracion_servicios
            WHERE servicio = 'SMTP' AND activo = TRUE
            LIMIT 1
        """)
        
        config_smtp = cursor.fetchone()
        cursor.close()
        connection.close()
        
        if not config_smtp:
            print("No hay configuración SMTP activa")
            return False
        
        smtp_config = json.loads(config_smtp['configuracion'])
        
        # Crear mensaje
        msg = MIMEMultipart('alternative')
        msg['Subject'] = asunto
        msg['From'] = smtp_config['from']
        msg['To'] = destinatario
        
        # Agregar contenido
        if cuerpo_texto:
            part1 = MIMEText(cuerpo_texto, 'plain', 'utf-8')
            msg.attach(part1)
        
        part2 = MIMEText(cuerpo_html, 'html', 'utf-8')
        msg.attach(part2)
        
        # Enviar email
        server = smtplib.SMTP(smtp_config['host'], smtp_config['port'])
        if not smtp_config.get('secure', False):
            server.starttls()
        
        server.login(smtp_config['auth']['user'], smtp_config['auth']['pass'])
        server.send_message(msg)
        server.quit()
        
        print(f"Email enviado exitosamente a {destinatario}")
        return True
        
    except Exception as e:
        print(f"Error al enviar email: {str(e)}")
        return False

def enviar_sms_inmediato(telefono, mensaje):
    """
    Envía un SMS inmediatamente (implementación básica)
    """
    try:
        # Aquí se implementaría la integración con un proveedor de SMS como Twilio
        # Por ahora, solo registramos el intento
        print(f"SMS programado para {telefono}: {mensaje}")
        
        # TODO: Implementar integración real con proveedor SMS
        # Ejemplo con Twilio:
        # from twilio.rest import Client
        # client = Client(account_sid, auth_token)
        # message = client.messages.create(
        #     body=mensaje,
        #     from_='+1234567890',
        #     to=telefono
        # )
        
        return True
        
    except Exception as e:
        print(f"Error al enviar SMS: {str(e)}")
        return False

# ============================================================================
# APIs DE CONFIGURACIÓN DE NOTIFICACIONES Y ROLES

@app.route('/api/configuracion/notificaciones', methods=['GET'])
def obtener_configuraciones_notificaciones():
    """
    Obtiene todas las configuraciones de notificaciones
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT cn.*, 
                   pe.nombre as plantilla_email_nombre,
                   ps.nombre as plantilla_sms_nombre
            FROM configuracion_notificaciones cn
            LEFT JOIN plantillas_email pe ON cn.plantilla_email_id = pe.id
            LEFT JOIN plantillas_sms ps ON cn.plantilla_sms_id = ps.id
            ORDER BY cn.evento_trigger, cn.estado_destino
        """)
        
        configuraciones = cursor.fetchall()
        
        # Convertir JSON strings a objetos
        for config in configuraciones:
            if config['destinatarios_roles']:
                import json
                config['destinatarios_roles'] = json.loads(config['destinatarios_roles'])
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'configuraciones': configuraciones
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener configuraciones: {str(e)}'
        }), 500

@app.route('/api/configuracion/notificaciones', methods=['POST'])
def crear_configuracion_notificacion():
    """
    Crea una nueva configuración de notificación
    """
    try:
        data = request.get_json()
        
        # Validaciones
        required_fields = ['evento_trigger', 'estado_destino', 'tipo_notificacion', 'destinatarios_roles']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False,
                    'error': f'Campo requerido: {field}'
                }), 400
        
        import mysql.connector
        import json
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Convertir roles a JSON
        destinatarios_roles_json = json.dumps(data['destinatarios_roles'])
        
        cursor.execute("""
            INSERT INTO configuracion_notificaciones 
            (evento_trigger, estado_origen, estado_destino, tipo_notificacion,
             destinatarios_roles, plantilla_email_id, plantilla_sms_id, 
             delay_minutos, activo)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            data['evento_trigger'],
            data.get('estado_origen'),
            data['estado_destino'],
            data['tipo_notificacion'],
            destinatarios_roles_json,
            data.get('plantilla_email_id'),
            data.get('plantilla_sms_id'),
            data.get('delay_minutos', 0),
            data.get('activo', True)
        ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Configuración creada exitosamente'
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al crear configuración: {str(e)}'
        }), 500

@app.route('/api/configuracion/notificaciones/<int:config_id>', methods=['PUT'])
def actualizar_configuracion_notificacion(config_id):
    """
    Actualiza una configuración de notificación existente
    """
    try:
        data = request.get_json()
        
        import mysql.connector
        import json
        
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Construir query dinámicamente
        update_fields = []
        values = []
        
        if 'evento_trigger' in data:
            update_fields.append('evento_trigger = %s')
            values.append(data['evento_trigger'])
        
        if 'estado_origen' in data:
            update_fields.append('estado_origen = %s')
            values.append(data['estado_origen'])
        
        if 'estado_destino' in data:
            update_fields.append('estado_destino = %s')
            values.append(data['estado_destino'])
        
        if 'tipo_notificacion' in data:
            update_fields.append('tipo_notificacion = %s')
            values.append(data['tipo_notificacion'])
        
        if 'destinatarios_roles' in data:
            update_fields.append('destinatarios_roles = %s')
            values.append(json.dumps(data['destinatarios_roles']))
        
        if 'plantilla_email_id' in data:
            update_fields.append('plantilla_email_id = %s')
            values.append(data['plantilla_email_id'])
        
        if 'plantilla_sms_id' in data:
            update_fields.append('plantilla_sms_id = %s')
            values.append(data['plantilla_sms_id'])
        
        if 'delay_minutos' in data:
            update_fields.append('delay_minutos = %s')
            values.append(data['delay_minutos'])
        
        if 'activo' in data:
            update_fields.append('activo = %s')
            values.append(data['activo'])
        
        if not update_fields:
            return jsonify({
                'success': False,
                'error': 'No hay campos para actualizar'
            }), 400
        
        values.append(config_id)
        
        query = f"UPDATE configuracion_notificaciones SET {', '.join(update_fields)} WHERE id = %s"
        cursor.execute(query, values)
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Configuración actualizada exitosamente'
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al actualizar configuración: {str(e)}'
        }), 500

@app.route('/api/configuracion/plantillas/email', methods=['GET'])
def obtener_plantillas_email():
    """
    Obtiene todas las plantillas de email
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT id, nombre, asunto, descripcion, activo, created_at
            FROM plantillas_email
            ORDER BY nombre
        """)
        
        plantillas = cursor.fetchall()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'plantillas': plantillas
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener plantillas: {str(e)}'
        }), 500

@app.route('/api/configuracion/plantillas/sms', methods=['GET'])
def obtener_plantillas_sms():
    """
    Obtiene todas las plantillas de SMS
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT id, nombre, descripcion, activo, created_at
            FROM plantillas_sms
            ORDER BY nombre
        """)
        
        plantillas = cursor.fetchall()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'plantillas': plantillas
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener plantillas: {str(e)}'
        }), 500

@app.route('/api/configuracion/roles', methods=['GET'])
def obtener_roles_sistema():
    """
    Obtiene todos los roles del sistema con sus permisos
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener roles
        cursor.execute("""
            SELECT r.*, COUNT(u.id) as usuarios_count
            FROM roles r
            LEFT JOIN usuarios u ON r.id = u.rol_id AND u.activo = 1
            GROUP BY r.id
            ORDER BY r.nombre
        """)
        
        roles = cursor.fetchall()
        
        # Obtener permisos para cada rol
        for rol in roles:
            cursor.execute("""
                SELECT p.nombre, p.descripcion, rp.puede_leer, rp.puede_escribir, 
                       rp.puede_actualizar, rp.puede_eliminar
                FROM permisos_roles rp
                JOIN permisos p ON rp.permiso_id = p.id
                WHERE rp.rol_id = %s
                ORDER BY p.nombre
            """, (rol['id'],))
            
            rol['permisos'] = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'roles': roles
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener roles: {str(e)}'
        }), 500

@app.route('/api/configuracion/permisos', methods=['GET'])
def obtener_permisos_disponibles():
    """
    Obtiene todos los permisos disponibles en el sistema
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT id, nombre, descripcion, modulo
            FROM permisos
            ORDER BY modulo, nombre
        """)
        
        permisos = cursor.fetchall()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'permisos': permisos
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener permisos: {str(e)}'
        }), 500

@app.route('/api/configuracion/roles/<int:rol_id>/permisos', methods=['PUT'])
def actualizar_permisos_rol(rol_id):
    """
    Actualiza los permisos de un rol específico
    """
    try:
        data = request.get_json()
        permisos = data.get('permisos', [])
        
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Eliminar permisos existentes
        cursor.execute("DELETE FROM permisos_roles WHERE rol_id = %s", (rol_id,))
        
        # Insertar nuevos permisos
        for permiso in permisos:
            cursor.execute("""
                INSERT INTO permisos_roles 
                (rol_id, permiso_id, puede_leer, puede_escribir, puede_actualizar, puede_eliminar)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (
                rol_id,
                permiso['permiso_id'],
                permiso.get('puede_leer', False),
                permiso.get('puede_escribir', False),
                permiso.get('puede_actualizar', False),
                permiso.get('puede_eliminar', False)
            ))
        
        connection.commit()
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'message': 'Permisos actualizados exitosamente'
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al actualizar permisos: {str(e)}'
        }), 500

# ============================================================================
# APIs DE CONFIGURACIÓN DE HORA PREOPERACIONAL
# ============================================================================

@app.route('/api/configuracion/hora-preoperacional', methods=['GET'])
def obtener_hora_preoperacional():
    """
    API para obtener la hora límite actual del preoperacional
    """
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT id_hora_preoperacional, hora_limite_preoperacional
            FROM hora_preoperacional 
            ORDER BY id_hora_preoperacional DESC 
            LIMIT 1
        """)
        resultado = cursor.fetchone()
        if resultado:
            hora_base = str(resultado['hora_limite_preoperacional'])
            hora_base_fmt = hora_base[:5]
            hora_final = hora_base
            hora_final_fmt = hora_base_fmt
            try:
                user_id = session.get('id_codigo_consumidor')
                if user_id:
                    cursor.execute("SELECT cargo FROM recurso_operativo WHERE id_codigo_consumidor = %s", (user_id,))
                    row = cursor.fetchone()
                    cargo = (row.get('cargo') if row else '') or ''
                    if cargo.strip().upper() == 'CONDUCTOR':
                        hora_final = '09:00:00'
                        hora_final_fmt = '09:00'
            except Exception:
                pass
            return jsonify({
                'success': True,
                'data': {
                    'id': resultado['id_hora_preoperacional'],
                    'hora_limite': hora_final,
                    'hora_limite_formatted': hora_final_fmt
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': 'No se encontró configuración de hora límite'
            }), 404
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener hora límite: {str(e)}'
        }), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/configuracion/hora-preoperacional', methods=['PUT'])
@login_required()
def actualizar_hora_preoperacional():
    """
    API para actualizar la hora límite del preoperacional (solo administradores)
    """
    try:
        # Verificar que el usuario sea administrador
        if session.get('user_role') != 'administrativo':
            return jsonify({
                'success': False,
                'error': 'No tienes permisos para realizar esta acción'
            }), 403
        
        data = request.get_json()
        nueva_hora = data.get('hora_limite')
        
        if not nueva_hora:
            return jsonify({
                'success': False,
                'error': 'La hora límite es obligatoria'
            }), 400
        
        # Validar formato de hora (HH:MM)
        import re
        if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', nueva_hora):
            return jsonify({
                'success': False,
                'error': 'Formato de hora inválido. Use HH:MM'
            }), 400
        
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor()
        
        # Actualizar la hora límite
        cursor.execute("""
            UPDATE hora_preoperacional 
            SET hora_limite_preoperacional = %s
            WHERE id_hora_preoperacional = 1
        """, (nueva_hora + ':00',))  # Agregar segundos
        
        if cursor.rowcount > 0:
            connection.commit()
            
            return jsonify({
                'success': True,
                'message': f'Hora límite actualizada a {nueva_hora}',
                'data': {
                    'hora_limite': nueva_hora
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': 'No se pudo actualizar la hora límite'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al actualizar hora límite: {str(e)}'
        }), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/configuracion/hora-inicio-operacion', methods=['GET'])
def obtener_hora_inicio_operacion_analistas():
    try:
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        cursor = connection.cursor(dictionary=True)

        cursor.execute("""
            CREATE TABLE IF NOT EXISTS hora_inicio_operacion_analistas (
                id_hora_inicio_operacion INT AUTO_INCREMENT PRIMARY KEY,
                hora_limite_inicio_operacion TIME NOT NULL DEFAULT '10:00:00'
            )
        """)

        cursor.execute("""
            SELECT id_hora_inicio_operacion, hora_limite_inicio_operacion
            FROM hora_inicio_operacion_analistas
            ORDER BY id_hora_inicio_operacion DESC
            LIMIT 1
        """)
        resultado = cursor.fetchone()

        if not resultado:
            cursor.execute(
                """
                INSERT INTO hora_inicio_operacion_analistas (hora_limite_inicio_operacion)
                VALUES ('10:00:00')
                """
            )
            connection.commit()
            cursor.execute("""
                SELECT id_hora_inicio_operacion, hora_limite_inicio_operacion
                FROM hora_inicio_operacion_analistas
                ORDER BY id_hora_inicio_operacion DESC
                LIMIT 1
            """)
            resultado = cursor.fetchone()

        hora_limite = str(resultado['hora_limite_inicio_operacion'])

        return jsonify({
            'success': True,
            'data': {
                'id': resultado['id_hora_inicio_operacion'],
                'hora_limite': hora_limite,
                'hora_limite_formatted': hora_limite[:5]
            }
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Error al obtener hora límite: {str(e)}'
        }), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()

@app.route('/api/configuracion/hora-inicio-operacion', methods=['PUT'])
@login_required()
def actualizar_hora_inicio_operacion_analistas():
    try:
        if session.get('user_role') != 'administrativo':
            return jsonify({
                'success': False,
                'error': 'No tienes permisos para realizar esta acción'
            }), 403

        data = request.get_json()
        nueva_hora = data.get('hora_limite')
        if not nueva_hora:
            return jsonify({'success': False, 'error': 'La hora límite es obligatoria'}), 400

        import re
        if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', nueva_hora):
            return jsonify({'success': False, 'error': 'Formato de hora inválido. Use HH:MM'}), 400

        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        cursor = connection.cursor(dictionary=True)

        cursor.execute("""
            CREATE TABLE IF NOT EXISTS hora_inicio_operacion_analistas (
                id_hora_inicio_operacion INT AUTO_INCREMENT PRIMARY KEY,
                hora_limite_inicio_operacion TIME NOT NULL DEFAULT '10:00:00'
            )
        """)

        cursor.execute("SELECT id_hora_inicio_operacion FROM hora_inicio_operacion_analistas ORDER BY id_hora_inicio_operacion DESC LIMIT 1")
        fila = cursor.fetchone()

        if fila:
            cursor.execute(
                """
                UPDATE hora_inicio_operacion_analistas
                SET hora_limite_inicio_operacion = %s
                WHERE id_hora_inicio_operacion = %s
                """,
                (nueva_hora + ':00', fila['id_hora_inicio_operacion'])
            )
        else:
            cursor.execute(
                """
                INSERT INTO hora_inicio_operacion_analistas (hora_limite_inicio_operacion)
                VALUES (%s)
                """,
                (nueva_hora + ':00',)
            )

        connection.commit()

        return jsonify({
            'success': True,
            'message': f'Hora límite actualizada a {nueva_hora}',
            'data': {'hora_limite': nueva_hora}
        })
    except Exception as e:
        return jsonify({'success': False, 'error': f'Error al actualizar hora límite: {str(e)}'}), 500
    finally:
        if 'connection' in locals() and connection.is_connected():
            cursor.close()
            connection.close()

# ============================================================================
# APIs DEL SISTEMA DE GESTIÓN DE ESTADOS
# ============================================================================

@app.route('/api/devoluciones/<int:devolucion_id>/estado', methods=['PUT'])
@login_required()
@role_required('logistica')
def actualizar_estado_devolucion(devolucion_id):
    """
    API para actualizar el estado de una devolución específica
    """
    try:
        # Obtener datos de la petición
        data = request.get_json() if request.is_json else request.form
        
        nuevo_estado = data.get('nuevo_estado')
        motivo = data.get('motivo')
        usuario_id = session.get('user_id')
        
        # Validaciones de entrada
        if not nuevo_estado:
            return jsonify({
                'success': False,
                'error': 'El nuevo estado es obligatorio'
            }), 400
        
        if not motivo:
            return jsonify({
                'success': False,
                'error': 'El motivo del cambio es obligatorio'
            }), 400
        
        estados_validos = ['PENDIENTE', 'REGISTRADA', 'EN_REVISION', 'APROBADA', 'RECHAZADA', 'PROCESADA', 'COMPLETADA', 'CANCELADA']
        if nuevo_estado not in estados_validos:
            return jsonify({
                'success': False,
                'error': f'Estado no válido. Estados permitidos: {", ".join(estados_validos)}'
            }), 400
        
        # Conectar a la base de datos
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener estado actual de la devolución
        cursor.execute(
            "SELECT estado FROM devoluciones_dotacion WHERE id = %s",
            (devolucion_id,)
        )
        
        devolucion = cursor.fetchone()
        
        if not devolucion:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': 'Devolución no encontrada'
            }), 404
        
        estado_actual = devolucion['estado']
        
        # Verificar si el estado ya es el mismo
        if estado_actual == nuevo_estado:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': f'La devolución ya se encuentra en estado {nuevo_estado}'
            }), 400
        
        # Validar transición
        validacion = validar_transicion_estado(estado_actual, nuevo_estado, usuario_id)
        
        if not validacion['valida']:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': validacion['mensaje'],
                'rol_usuario': validacion['rol_usuario']
            }), 403
        
        # Actualizar estado en la base de datos
        cursor.execute(
            "UPDATE devoluciones_dotacion SET estado = %s, updated_by = %s WHERE id = %s",
            (nuevo_estado, usuario_id, devolucion_id)
        )
        
        connection.commit()
        
        # Registrar en auditoría
        auditoria_exitosa = registrar_auditoria_estado(
            devolucion_id, estado_actual, nuevo_estado, usuario_id, motivo
        )
        
        # Enviar notificaciones
        notificacion_exitosa = enviar_notificacion_cambio_estado(
            devolucion_id, estado_actual, nuevo_estado
        )
        
        cursor.close()
        connection.close()
        
        response_data = {
            'success': True,
            'mensaje': 'Estado actualizado exitosamente',
            'estado_anterior': estado_actual,
            'estado_nuevo': nuevo_estado,
            'devolucion_id': devolucion_id
        }
        
        # Agregar información adicional sobre procesos auxiliares
        if not auditoria_exitosa:
            response_data['advertencia_auditoria'] = 'No se pudo registrar en auditoría'
        
        if not notificacion_exitosa:
            response_data['advertencia_notificacion'] = 'No se pudieron enviar notificaciones'
        
        return jsonify(response_data)
        
    except Exception as e:
        print(f"Error al actualizar estado de devolución: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error interno del servidor: {str(e)}'
        }), 500

@app.route('/api/devoluciones/<int:devolucion_id>/transiciones', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_transiciones_devolucion(devolucion_id):
    """
    API para obtener las transiciones válidas para una devolución específica
    """
    try:
        usuario_id = session.get('user_id')
        
        # Conectar a la base de datos
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Obtener estado actual de la devolución
        cursor.execute(
            "SELECT estado FROM devoluciones_dotacion WHERE id = %s",
            (devolucion_id,)
        )
        
        devolucion = cursor.fetchone()
        
        if not devolucion:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': 'Devolución no encontrada'
            }), 404
        
        estado_actual = devolucion['estado']
        
        # Obtener transiciones válidas
        transiciones_validas = obtener_transiciones_validas(estado_actual, usuario_id)
        
        # Obtener información del rol del usuario
        cursor.execute("""
            SELECT r.nombre_rol as rol_nombre
            FROM recurso_operativo ro
            JOIN roles r ON ro.id_roles = r.id_roles
            WHERE ro.id_codigo_consumidor = %s
        """, (usuario_id,))
        
        usuario_info = cursor.fetchone()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'devolucion_id': devolucion_id,
            'estado_actual': estado_actual,
            'transiciones_validas': transiciones_validas,
            'rol_usuario': usuario_info['rol_nombre'] if usuario_info else 'Sin rol'
        })
        
    except Exception as e:
        print(f"Error al obtener transiciones: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error interno del servidor: {str(e)}'
        }), 500

@app.route('/api/devoluciones/<int:devolucion_id>/historial', methods=['GET'])
@login_required_api(role='logistica')
def obtener_historial_estados(devolucion_id):
    """
    API para consultar el historial de cambios de estado de una devolución
    """
    try:
        # Conectar a la base de datos
        import mysql.connector
        connection = mysql.connector.connect(
            host='localhost',
            user='root',
            password='732137A031E4b@',
            database='capired'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # Verificar que la devolución existe
        cursor.execute(
            "SELECT id, estado FROM devoluciones_dotacion WHERE id = %s",
            (devolucion_id,)
        )
        
        devolucion = cursor.fetchone()
        
        if not devolucion:
            cursor.close()
            connection.close()
            return jsonify({
                'success': False,
                'error': 'Devolución no encontrada'
            }), 404
        
        # Obtener historial de auditoría
        cursor.execute("""
            SELECT 
                ae.id,
                ae.estado_anterior,
                ae.estado_nuevo,
                ae.motivo_cambio,
                ae.fecha_cambio,
                ro.nombre as usuario_nombre,
                r.nombre_rol as rol_usuario
            FROM auditoria_estados_devolucion ae
            LEFT JOIN recurso_operativo ro ON ae.usuario_id = ro.recurso_operativo_cedula
            LEFT JOIN roles r ON ro.id_roles = r.id_roles
            WHERE ae.devolucion_id = %s
            ORDER BY ae.fecha_cambio DESC
        """, (devolucion_id,))
        
        historial = cursor.fetchall()
        
        # Formatear fechas para JSON
        for registro in historial:
            if registro['fecha_cambio']:
                registro['fecha_cambio'] = registro['fecha_cambio'].isoformat()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'success': True,
            'devolucion_id': devolucion_id,
            'estado_actual': devolucion['estado'],
            'total_cambios': len(historial),
            'historial': historial
        })
        
    except Exception as e:
        print(f"Error al obtener historial de estados: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error interno del servidor: {str(e)}'
        }), 500

@app.route('/api/estados/validar-transicion', methods=['POST'])
@login_required()
@role_required('logistica')
def validar_transicion_api():
    """
    API para validar si una transición de estado es permitida
    """
    try:
        data = request.get_json() if request.is_json else request.form
        
        estado_actual = data.get('estado_actual')
        estado_nuevo = data.get('estado_nuevo')
        usuario_id = session.get('user_id')
        
        if not estado_actual or not estado_nuevo:
            return jsonify({
                'success': False,
                'error': 'Estado actual y nuevo estado son obligatorios'
            }), 400
        
        validacion = validar_transicion_estado(estado_actual, estado_nuevo, usuario_id)
        
        return jsonify({
            'success': True,
            'validacion': validacion
        })
        
    except Exception as e:
        print(f"Error al validar transición: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Error interno del servidor: {str(e)}'
        }), 500

# ==================== MÓDULO DE LÍMITES FERRETERO ====================

@app.route('/logistica/limites_ferretero')
@login_required()
@role_required('logistica')
def ver_limites_ferretero():
    """Página principal del módulo de límites ferretero"""
    try:
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                               mensaje='Error de conexión a la base de datos',
                               error='No se pudo establecer conexión con la base de datos')
                               
        cursor = connection.cursor(dictionary=True)
        
        # Obtener todas las áreas de trabajo disponibles
        cursor.execute("SELECT DISTINCT area_trabajo FROM limites_ferretero ORDER BY area_trabajo")
        areas_trabajo = cursor.fetchall()
        
        # Obtener todos los límites configurados
        cursor.execute("""
            SELECT 
                id_limite,
                area_trabajo,
                material_tipo,
                cantidad_limite,
                periodo_dias,
                unidad_medida,
                descripcion,
                activo,
                fecha_actualizacion,
                usuario_actualizacion
            FROM limites_ferretero 
            ORDER BY area_trabajo, material_tipo
        """)
        limites = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return render_template('modulos/logistica/limites_ferretero.html',
                             areas_trabajo=areas_trabajo,
                             limites=limites)
                             
    except Exception as e:
        print(f"Error al cargar límites ferretero: {str(e)}")
        return render_template('error.html',
                           mensaje='Error al cargar los límites de ferretero',
                           error=str(e))

@app.route('/logistica/computadores')
@login_required()
@role_required('logistica')
def logistica_computadores_view():
    try:
        connection = get_db_connection()
        if connection is None:
            return render_template('error.html', 
                mensaje='Error de conexión a la base de datos',
                error='No se pudo establecer conexión con la base de datos')
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS `log_computadores` (
              `id` INT AUTO_INCREMENT PRIMARY KEY,
              `marca` VARCHAR(120) NOT NULL,
              `modelo` VARCHAR(120) NULL,
              `descripcion` TEXT,
              `cantidad` INT DEFAULT 1,
              `serial` VARCHAR(120) UNIQUE,
              `costo` DECIMAL(12,2) DEFAULT 0,
              `observacion` TEXT,
              `responsable_id` INT NULL,
              `fecha_creacion` DATETIME DEFAULT CURRENT_TIMESTAMP,
              INDEX (`responsable_id`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
        """)
        # asegurar columna modelo si tabla ya existía
        cursor.execute("""
            SELECT COLUMN_NAME FROM information_schema.columns
            WHERE table_schema=%s AND table_name='log_computadores'
        """, (db_config.get('database'),))
        cols = {r['COLUMN_NAME'].lower(): r['COLUMN_NAME'] for r in cursor.fetchall()}
        if 'modelo' not in cols:
            cursor.execute("ALTER TABLE `log_computadores` ADD COLUMN `modelo` VARCHAR(120) NULL")
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS `log_computadores_asignaciones` (
              `id` INT AUTO_INCREMENT PRIMARY KEY,
              `computador_id` INT NOT NULL,
              `usuario_id` INT NOT NULL,
              `fecha_asignacion` DATETIME DEFAULT CURRENT_TIMESTAMP,
              `fecha_desasignacion` DATETIME NULL,
              INDEX (`computador_id`),
              INDEX (`usuario_id`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
        """)
        cursor.close(); connection.close()
        return render_template('modulos/logistica/computadores.html')
    except Exception as e:
        return render_template('error.html', mensaje='Error al cargar módulo de computadores', error=str(e))

@app.route('/api/logistica/computadores', methods=['GET'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_list():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT c.*, ro.nombre AS responsable_nombre, ro.recurso_operativo_cedula AS responsable_documento
            FROM log_computadores c
            LEFT JOIN recurso_operativo ro ON ro.id_codigo_consumidor = c.responsable_id
            ORDER BY c.id DESC
        """)
        rows = cursor.fetchall()
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': rows})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores', methods=['POST'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_create():
    data = request.get_json() or {}
    cid = int(data.get('id') or 0)
    marca = (data.get('marca') or '').strip()
    modelo = (data.get('modelo') or '').strip()
    descripcion = (data.get('descripcion') or '').strip()
    cantidad = int(data.get('cantidad') or 1)
    serial = (data.get('serial') or '').strip()
    costo = float(data.get('costo') or 0)
    observacion = (data.get('observacion') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        if cid > 0:
            cursor.execute(
                "UPDATE log_computadores SET marca=%s, modelo=%s, descripcion=%s, cantidad=%s, serial=%s, costo=%s, observacion=%s WHERE id=%s",
                (marca, modelo, descripcion, cantidad, serial, costo, observacion, cid)
            )
        else:
            cursor.execute("""
                INSERT INTO log_computadores (marca, modelo, descripcion, cantidad, serial, costo)
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (marca, modelo, descripcion, cantidad, serial, costo))
        connection.commit()
        cursor.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores/asignaciones', methods=['GET'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_asignaciones_list():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT 
              a.id,
              c.marca,
              c.serial,
              ro.nombre AS responsable_nombre,
              ro.recurso_operativo_cedula AS responsable_documento,
              DATE_FORMAT(a.fecha_asignacion, '%Y-%m-%d') AS fecha_asignacion
            FROM log_computadores_asignaciones a
            JOIN log_computadores c ON c.id = a.computador_id
            LEFT JOIN recurso_operativo ro ON ro.id_codigo_consumidor = a.usuario_id
            WHERE a.fecha_desasignacion IS NULL
            ORDER BY a.id DESC
        """)
        rows = cursor.fetchall()
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': rows})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores/historial', methods=['GET'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_historial_list():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("""
            SELECT 
              a.id,
              c.marca,
              c.serial,
              ro.nombre AS responsable_nombre,
              ro.recurso_operativo_cedula AS responsable_documento,
              DATE_FORMAT(a.fecha_asignacion, '%Y-%m-%d') AS fecha_asignacion,
              DATE_FORMAT(a.fecha_desasignacion, '%Y-%m-%d') AS fecha_desasignacion
            FROM log_computadores_asignaciones a
            JOIN log_computadores c ON c.id = a.computador_id
            LEFT JOIN recurso_operativo ro ON ro.id_codigo_consumidor = a.usuario_id
            WHERE a.fecha_desasignacion IS NOT NULL
            ORDER BY a.fecha_desasignacion DESC
        """)
        rows = cursor.fetchall()
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': rows})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores/asignar', methods=['POST'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_asignar():
    data = request.get_json() or {}
    computador_id = int(data.get('computador_id') or 0)
    usuario_id = int(data.get('usuario_id') or 0)
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute("UPDATE log_computadores SET responsable_id=%s WHERE id=%s", (usuario_id, computador_id))
        cur.execute("UPDATE log_computadores_asignaciones SET fecha_desasignacion=NOW() WHERE computador_id=%s AND fecha_desasignacion IS NULL", (computador_id,))
        cur.execute("INSERT INTO log_computadores_asignaciones (computador_id, usuario_id) VALUES (%s, %s)", (computador_id, usuario_id))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores/desasignar', methods=['POST'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_desasignar():
    data = request.get_json() or {}
    computador_id = int(data.get('computador_id') or 0)
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute("UPDATE log_computadores SET responsable_id=NULL WHERE id=%s", (computador_id,))
        cur.execute("UPDATE log_computadores_asignaciones SET fecha_desasignacion=NOW() WHERE computador_id=%s AND fecha_desasignacion IS NULL", (computador_id,))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/usuarios', methods=['GET'])
@login_required_api(role=['logistica','administrativo'])
def api_log_usuarios_search():
    q = (request.args.get('q') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        if q:
            cursor.execute("""
                SELECT id_codigo_consumidor AS id, nombre, recurso_operativo_cedula AS documento
                FROM recurso_operativo
                WHERE nombre LIKE %s OR recurso_operativo_cedula LIKE %s
                ORDER BY nombre LIMIT 50
            """, (f"%{q}%", f"%{q}%"))
        else:
            cursor.execute("""
                SELECT id_codigo_consumidor AS id, nombre, recurso_operativo_cedula AS documento
                FROM recurso_operativo
                ORDER BY nombre LIMIT 50
            """)
        rows = cursor.fetchall()
        cursor.close(); connection.close()
        return jsonify({'success': True, 'items': rows})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/limites_ferretero', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_limites_ferretero():
    """API para obtener límites ferretero con filtros opcionales"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener parámetros de filtro
        area_trabajo = request.args.get('area_trabajo')
        material_tipo = request.args.get('material_tipo')
        activo = request.args.get('activo', 'true').lower() == 'true'
        
        # Construir consulta con filtros
        query = """
            SELECT 
                id_limite,
                area_trabajo,
                material_tipo,
                cantidad_limite,
                periodo_dias,
                unidad_medida,
                descripcion,
                activo,
                fecha_creacion,
                fecha_actualizacion,
                usuario_creacion,
                usuario_actualizacion
            FROM limites_ferretero 
            WHERE activo = %s
        """
        params = [activo]
        
        if area_trabajo:
            query += " AND area_trabajo = %s"
            params.append(area_trabajo)
            
        if material_tipo:
            query += " AND material_tipo = %s"
            params.append(material_tipo)
            
        query += " ORDER BY area_trabajo, material_tipo"
        
        cursor.execute(query, params)
        limites = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'data': limites,
            'total': len(limites)
        })
        
    except Exception as e:
        print(f"Error al obtener límites: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener límites: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero/<int:id_limite>', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_limite_ferretero(id_limite):
    """API para obtener un límite específico"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT 
                id_limite,
                area_trabajo,
                material_tipo,
                cantidad_limite,
                periodo_dias,
                unidad_medida,
                descripcion,
                activo,
                fecha_creacion,
                fecha_actualizacion,
                usuario_creacion,
                usuario_actualizacion
            FROM limites_ferretero 
            WHERE id_limite = %s
        """, (id_limite,))
        
        limite = cursor.fetchone()
        
        cursor.close()
        connection.close()
        
        if limite:
            return jsonify({
                'status': 'success',
                'data': limite
            })
        else:
            return jsonify({
                'status': 'error',
                'message': 'Límite no encontrado'
            }), 404
            
    except Exception as e:
        print(f"Error al obtener límite: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener límite: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero', methods=['POST'])
@login_required()
@role_required('logistica')
def crear_limite_ferretero():
    """API para crear un nuevo límite"""
    try:
        data = request.get_json() if request.is_json else request.form
        
        # Validar campos requeridos
        campos_requeridos = ['area_trabajo', 'material_tipo', 'cantidad_limite', 'periodo_dias']
        for campo in campos_requeridos:
            if not data.get(campo):
                return jsonify({
                    'status': 'error',
                    'message': f'El campo {campo} es requerido'
                }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor()
        
        # Verificar si ya existe un límite para esta combinación
        cursor.execute("""
            SELECT id_limite FROM limites_ferretero 
            WHERE area_trabajo = %s AND material_tipo = %s
        """, (data['area_trabajo'], data['material_tipo']))
        
        if cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'Ya existe un límite para esta área de trabajo y material'
            }), 400
        
        # Insertar nuevo límite
        cursor.execute("""
            INSERT INTO limites_ferretero 
            (area_trabajo, material_tipo, cantidad_limite, periodo_dias, unidad_medida, descripcion, usuario_creacion)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            data['area_trabajo'],
            data['material_tipo'],
            int(data['cantidad_limite']),
            int(data['periodo_dias']),
            data.get('unidad_medida', 'unidades'),
            data.get('descripcion', ''),
            session.get('username', 'sistema')
        ))
        
        id_limite = cursor.lastrowid
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'message': 'Límite creado exitosamente',
            'id_limite': id_limite
        }), 201
        
    except Exception as e:
        print(f"Error al crear límite: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al crear límite: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero/<int:id_limite>', methods=['PUT'])
@login_required()
@role_required('logistica')
def actualizar_limite_ferretero(id_limite):
    """API para actualizar un límite existente"""
    try:
        data = request.get_json() if request.is_json else request.form
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor()
        
        # Verificar que el límite existe
        cursor.execute("SELECT id_limite FROM limites_ferretero WHERE id_limite = %s", (id_limite,))
        if not cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'Límite no encontrado'
            }), 404
        
        # Construir consulta de actualización dinámicamente
        campos_actualizables = ['cantidad_limite', 'periodo_dias', 'unidad_medida', 'descripcion', 'activo']
        campos_update = []
        valores = []
        
        for campo in campos_actualizables:
            if campo in data:
                campos_update.append(f"{campo} = %s")
                valores.append(data[campo])
        
        if not campos_update:
            return jsonify({
                'status': 'error',
                'message': 'No se proporcionaron campos para actualizar'
            }), 400
        
        # Agregar usuario y fecha de actualización
        campos_update.append("usuario_actualizacion = %s")
        valores.append(session.get('username', 'sistema'))
        valores.append(id_limite)
        
        query = f"UPDATE limites_ferretero SET {', '.join(campos_update)} WHERE id_limite = %s"
        cursor.execute(query, valores)
        
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'message': 'Límite actualizado exitosamente'
        })
        
    except Exception as e:
        print(f"Error al actualizar límite: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al actualizar límite: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero/<int:id_limite>', methods=['DELETE'])
@login_required()
@role_required('logistica')
def eliminar_limite_ferretero(id_limite):
    """API para eliminar (desactivar) un límite"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor()
        
        # Verificar que el límite existe
        cursor.execute("SELECT id_limite FROM limites_ferretero WHERE id_limite = %s", (id_limite,))
        if not cursor.fetchone():
            return jsonify({
                'status': 'error',
                'message': 'Límite no encontrado'
            }), 404
        
        # Desactivar el límite en lugar de eliminarlo
        cursor.execute("""
            UPDATE limites_ferretero 
            SET activo = FALSE, usuario_actualizacion = %s 
            WHERE id_limite = %s
        """, (session.get('username', 'sistema'), id_limite))
        
        connection.commit()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'message': 'Límite desactivado exitosamente'
        })
        
    except Exception as e:
        print(f"Error al eliminar límite: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al eliminar límite: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero/areas', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_areas_trabajo():
    """API para obtener todas las áreas de trabajo disponibles"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("SELECT DISTINCT area_trabajo FROM limites_ferretero ORDER BY area_trabajo")
        areas = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'data': [area['area_trabajo'] for area in areas]
        })
        
    except Exception as e:
        print(f"Error al obtener áreas: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener áreas: {str(e)}'
        }), 500

@app.route('/api/limites_ferretero/historial/<int:id_limite>', methods=['GET'])
@login_required()
@role_required('logistica')
def obtener_historial_limite(id_limite):
    """API para obtener el historial de cambios de un límite"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'status': 'error',
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        cursor.execute("""
            SELECT 
                id_historial,
                area_trabajo,
                material_tipo,
                cantidad_limite_anterior,
                cantidad_limite_nueva,
                periodo_dias_anterior,
                periodo_dias_nuevo,
                accion,
                usuario,
                fecha_cambio,
                observaciones
            FROM historial_limites_ferretero 
            WHERE id_limite = %s 
            ORDER BY fecha_cambio DESC
        """, (id_limite,))
        
        historial = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return jsonify({
            'status': 'success',
            'data': historial
        })
        
    except Exception as e:
        print(f"Error al obtener historial: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': f'Error al obtener historial: {str(e)}'
        }), 500

# ============================================================================
# MÓDULO SSTT (SEGURIDAD Y SALUD EN EL TRABAJO) - RUTAS Y API ENDPOINTS
# ============================================================================

@app.route('/sstt')
@login_required()
def sstt_dashboard():
    """Dashboard principal del módulo SSTT"""
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/dashboard.html')

@app.route('/sstt/inspecciones')
@login_required()
def sstt_inspecciones():
    """Página de gestión de inspecciones de seguridad"""
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/inspecciones.html')

@app.route('/sstt/capacitaciones')
@login_required()
def sstt_capacitaciones():
    """Página de gestión de capacitaciones"""
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/capacitaciones.html')

@app.route('/sstt/incidentes')
@login_required()
def sstt_incidentes():
    """Página de gestión de incidentes laborales"""
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/incidentes.html')

@app.route('/sstt/epp')
@login_required()
def sstt_epp():
    """Página de control de EPP (Elementos de Protección Personal)"""
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/epp.html')

@app.route('/sstt/vencimientos-cursos')
@login_required()
def sstt_vencimientos_cursos():
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/vencimientos_cursos.html')

@app.route('/sstt/preoperacional')
@login_required()
def sstt_preoperacional_visual():
    if session.get('user_role') not in ['sstt', 'administrativo']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sstt/preoperacional_visual.html')

# API Endpoints para SSTT

@app.route('/api/sstt/tipos-riesgo', methods=['GET'])
@login_required()
def api_sstt_tipos_riesgo():
    """API para obtener tipos de riesgo"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT * FROM sstt_tipos_riesgo ORDER BY nombre_riesgo")
        tipos_riesgo = cursor.fetchall()
        
        return jsonify({'tipos_riesgo': tipos_riesgo})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/sstt/vencimientos-cursos/tipos', methods=['GET'])
@login_required_api()
def api_sstt_vencimientos_cursos_tipos():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS sstt_vencimientos_cursos (
                id INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                sstt_vencimientos_cursos_nombre VARCHAR(200),
                recurso_operativo_cedula VARCHAR(20),
                sstt_vencimientos_cursos_tipo_curso VARCHAR(100) NOT NULL,
                sstt_vencimientos_cursos_fecha DATE NOT NULL,
                sstt_vencimientos_cursos_fecha_ven DATE NOT NULL,
                sstt_vencimientos_cursos_observacion TEXT,
                sstt_vencimientos_cursos_pendiente TINYINT(1) NOT NULL DEFAULT 0,
                sstt_vencimientos_cursos_fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_cedula (recurso_operativo_cedula),
                INDEX idx_tipo (sstt_vencimientos_cursos_tipo_curso),
                INDEX idx_fecha_ven (sstt_vencimientos_cursos_fecha_ven)
            )
            """
        )
        cursor.execute(
            """
            SELECT DISTINCT sstt_vencimientos_cursos_tipo_curso AS tipo
            FROM sstt_vencimientos_cursos
            WHERE sstt_vencimientos_cursos_tipo_curso IS NOT NULL
              AND TRIM(sstt_vencimientos_cursos_tipo_curso) <> ''
            ORDER BY 1
            """
        )
        _ = cursor.fetchall()
        tipos = [
            'EXAMEN MEDICO INGRESO',
  'EXAMEN MEDICO PERIODICO',
  'CURSO ALTURAS',
  'CURSO MANEJO DEFENSIVO',
  'CURSO INDUCCION SST',
  'CURSO REINDUCCION SST'
        ]
        cursor.close(); connection.close()
        return jsonify({'success': True, 'data': tipos})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/inspecciones', methods=['GET', 'POST'])
@login_required()
def api_sstt_inspecciones():
    """API para gestionar inspecciones de seguridad"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        if request.method == 'GET':
            # Obtener inspecciones con filtros opcionales
            fecha_desde = request.args.get('fecha_desde')
            fecha_hasta = request.args.get('fecha_hasta')
            estado = request.args.get('estado')
            
            query = """
                SELECT i.*, tr.nombre_riesgo, ro.nombre as inspector_nombre
                FROM sstt_inspecciones i
                LEFT JOIN sstt_tipos_riesgo tr ON i.tipo_riesgo_id = tr.id
                LEFT JOIN recurso_operativo ro ON i.usuario_creador = ro.id_codigo_consumidor
                WHERE 1=1
            """
            params = []
            
            if fecha_desde:
                query += " AND i.fecha_inspeccion >= %s"
                params.append(fecha_desde)
            if fecha_hasta:
                query += " AND i.fecha_inspeccion <= %s"
                params.append(fecha_hasta)
            if estado:
                query += " AND i.estado = %s"
                params.append(estado)
                
            query += " ORDER BY i.fecha_inspeccion DESC"
            
            cursor.execute(query, params)
            inspecciones = cursor.fetchall()
            
            return jsonify({'inspecciones': inspecciones})
            
        elif request.method == 'POST':
            # Crear nueva inspección
            data = request.get_json()
            
            cursor.execute("""
                INSERT INTO sstt_inspecciones 
                (area_inspeccionada, fecha_inspeccion, tipo_riesgo_id, descripcion, 
                 estado, usuario_creador, fecha_creacion)
                VALUES (%s, %s, %s, %s, %s, %s, NOW())
            """, (
                data['area_inspeccionada'],
                data['fecha_inspeccion'],
                data['tipo_riesgo_id'],
                data['descripcion'],
                data.get('estado', 'pendiente'),
                session.get('user_id')
            ))
            
            connection.commit()
            inspeccion_id = cursor.lastrowid
            
            return jsonify({
                'success': True, 
                'message': 'Inspección creada exitosamente',
                'inspeccion_id': inspeccion_id
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/sstt/usuarios', methods=['GET'])
@login_required()
def api_sstt_usuarios():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        q = (request.args.get('q') or '').strip()
        limit_param = request.args.get('limit')
        try:
            limit = int(limit_param) if limit_param else 50
        except Exception:
            limit = 50
        solo_activos_param = (request.args.get('solo_activos') or '1').strip().lower()
        solo_activos = solo_activos_param in ['1', 'true', 't', 'yes', 'y']
        where = []
        params = []
        if solo_activos:
            where.append("estado = 'Activo'")
        if q:
            where.append("(recurso_operativo_cedula LIKE %s OR nombre LIKE %s)")
            like = f"%{q}%"
            params.extend([like, like])
        sql = "SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre, id_roles, estado FROM recurso_operativo"
        if where:
            sql += " WHERE " + " AND ".join(where)
        sql += " ORDER BY nombre ASC LIMIT %s"
        params.append(limit)
        cursor.execute(sql, tuple(params))
        rows = cursor.fetchall() or []
        data = [{
            'id_codigo_consumidor': r.get('id_codigo_consumidor'),
            'cedula': r.get('recurso_operativo_cedula'),
            'nombre': r.get('nombre'),
            'id_roles': r.get('id_roles'),
            'estado': r.get('estado')
        } for r in rows]
        cursor.close(); connection.close()
        return jsonify({'success': True, 'data': data, 'total': len(data)})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/vencimientos-cursos', methods=['GET', 'POST'])
@login_required_api()
def api_sstt_vencimientos_cursos():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS sstt_vencimientos_cursos (
                id INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                sstt_vencimientos_cursos_nombre VARCHAR(200),
                recurso_operativo_cedula VARCHAR(20),
                sstt_vencimientos_cursos_tipo_curso VARCHAR(100) NOT NULL,
                sstt_vencimientos_cursos_fecha DATE NOT NULL,
                sstt_vencimientos_cursos_fecha_ven DATE NOT NULL,
                sstt_vencimientos_cursos_observacion TEXT,
                sstt_vencimientos_cursos_pendiente TINYINT(1) NOT NULL DEFAULT 0,
                sstt_vencimientos_cursos_fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_cedula (recurso_operativo_cedula),
                INDEX idx_tipo (sstt_vencimientos_cursos_tipo_curso),
                INDEX idx_fecha_ven (sstt_vencimientos_cursos_fecha_ven)
            )
            """
        )
        if request.method == 'GET':
            cedula = (request.args.get('cedula') or '').strip()
            tipo = (request.args.get('tipo') or '').strip()
            fecha_desde = (request.args.get('fecha_desde') or '').strip()
            fecha_hasta = (request.args.get('fecha_hasta') or '').strip()
            solo_activos_param = (request.args.get('solo_activos') or '1').strip().lower()
            solo_activos = solo_activos_param in ['1', 'true', 't', 'yes', 'y']
            params = []
            where = []
            try:
                cur_check_id = connection.cursor()
                cur_check_id.execute("SHOW COLUMNS FROM sstt_vencimientos_cursos LIKE 'id'")
                has_id_col = bool(cur_check_id.fetchone())
                cur_check_id.close()
                if not has_id_col:
                    try:
                        cur_pk = connection.cursor()
                        cur_pk.execute("SHOW KEYS FROM sstt_vencimientos_cursos WHERE Key_name = 'PRIMARY'")
                        has_pk = bool(cur_pk.fetchone())
                        cur_pk.close()
                        cur_alter_id = connection.cursor()
                        if has_pk:
                            cur_alter_id.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN id INT NOT NULL AUTO_INCREMENT FIRST")
                            cur_alter_id.execute("ALTER TABLE sstt_vencimientos_cursos ADD UNIQUE KEY idx_sstt_vc_id (id)")
                        else:
                            cur_alter_id.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN id INT NOT NULL AUTO_INCREMENT PRIMARY KEY FIRST")
                        connection.commit()
                        cur_alter_id.close()
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                cur_check_valid = connection.cursor()
                cur_check_valid.execute(
                    """
                    SELECT COUNT(*) FROM information_schema.columns
                    WHERE table_schema = DATABASE() AND table_name = 'sstt_vencimientos_cursos' AND column_name = 'sstt_vencimientos_cursos_validado'
                    """
                )
                has_validado = (cur_check_valid.fetchone() or [0])[0]
                cur_check_valid.close()
                if not has_validado:
                    cur_alter_valid = connection.cursor()
                    try:
                        cur_alter_valid.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN sstt_vencimientos_cursos_validado TINYINT(1) DEFAULT 0 AFTER sstt_vencimientos_cursos_observacion")
                        connection.commit()
                    except Exception:
                        pass
                    finally:
                        cur_alter_valid.close()
            except Exception:
                pass
            if cedula:
                where.append("vc.recurso_operativo_cedula = %s")
                params.append(cedula)
            if tipo:
                where.append("sstt_vencimientos_cursos_tipo_curso = %s")
                params.append(tipo)
            if fecha_desde:
                where.append("sstt_vencimientos_cursos_fecha >= %s")
                params.append(fecha_desde)
            if fecha_hasta:
                where.append("sstt_vencimientos_cursos_fecha <= %s")
                params.append(fecha_hasta)
            select_id_prefix = "vc.id AS id, " if has_id_col else "NULL AS id, "
            sql = (
                "SELECT " + select_id_prefix +
                "vc.id_codigo_consumidor, vc.sstt_vencimientos_cursos_nombre, vc.recurso_operativo_cedula, "
                "vc.sstt_vencimientos_cursos_tipo_curso, vc.sstt_vencimientos_cursos_fecha, vc.sstt_vencimientos_cursos_fecha_ven, "
                "vc.sstt_vencimientos_cursos_observacion, vc.sstt_vencimientos_cursos_validado, vc.sstt_vencimientos_cursos_pendiente "
                "FROM sstt_vencimientos_cursos vc LEFT JOIN recurso_operativo ro ON vc.recurso_operativo_cedula = ro.recurso_operativo_cedula"
            )
            if solo_activos:
                where.append("ro.estado = 'Activo'")
            if where:
                sql += " WHERE " + " AND ".join(where)
            sql += " ORDER BY vc.sstt_vencimientos_cursos_fecha_ven ASC"
            cursor.execute(sql, tuple(params))
            rows = cursor.fetchall() or []
            hoy = datetime.now().date()
            out = []
            for r in rows:
                f = r.get('sstt_vencimientos_cursos_fecha')
                fv = r.get('sstt_vencimientos_cursos_fecha_ven')
                fv_date = None
                try:
                    if fv:
                        if hasattr(fv, 'strftime'):
                            fv_date = fv
                        else:
                            s = str(fv).strip()
                            if s:
                                try:
                                    fv_date = datetime.strptime(s, '%Y-%m-%d').date()
                                except Exception:
                                    try:
                                        fv_date = datetime.strptime(s, '%Y-%m-%d %H:%M:%S').date()
                                    except Exception:
                                        fv_date = None
                except Exception:
                    fv_date = None
                dias = (fv_date - hoy).days if fv_date else None
                fecha_str = (f.strftime('%Y-%m-%d') if hasattr(f, 'strftime') else (str(f).strip() if f else ''))
                fv_str = (fv.strftime('%Y-%m-%d') if hasattr(fv, 'strftime') else (str(fv).strip() if fv else ''))
                anio_val = None
                try:
                    if fecha_str and len(fecha_str) >= 4 and fecha_str[0:4].isdigit():
                        anio_val = int(fecha_str[0:4])
                except Exception:
                    anio_val = None
                out.append({
                    'id': r.get('id'),
                    'recurso_operativo_cedula': r.get('recurso_operativo_cedula'),
                    'nombre': r.get('sstt_vencimientos_cursos_nombre'),
                    'tipo_curso': r.get('sstt_vencimientos_cursos_tipo_curso'),
                    'fecha': fecha_str,
                    'fecha_vencimiento': fv_str,
                    'dias_por_vencer': dias,
                    'observacion': r.get('sstt_vencimientos_cursos_observacion'),
                    'anio': anio_val,
                    'validado': r.get('sstt_vencimientos_cursos_validado'),
                    'pendiente': int(r.get('sstt_vencimientos_cursos_pendiente') or 0)
                })

            # Incorporar encuesta_respuestas (encuesta_id=10) como Inducción/Reinducción del año presente
            if cedula:
                cur_user = connection.cursor(dictionary=True)
                cur_user.execute("SELECT id_codigo_consumidor, nombre, estado FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
                ru = cur_user.fetchone()
                cur_user.close()
                if ru and (not solo_activos or str(ru.get('estado') or '') == 'Activo'):
                    idc = ru.get('id_codigo_consumidor')
                    nombre_u = ru.get('nombre')
                    cur_enc = connection.cursor(dictionary=True)
                    try:
                        try:
                            cur_chk_enc = connection.cursor()
                            cur_chk_enc.execute(
                                """
                                SELECT COUNT(*) FROM information_schema.columns
                                WHERE table_schema = DATABASE() AND table_name = 'encuesta_respuestas' AND column_name = 'sstt_vencimientos_cursos_fecha_ven'
                                """
                            )
                            has_er_col = (cur_chk_enc.fetchone() or [0])[0]
                            cur_chk_enc.close()
                            if not has_er_col:
                                cur_alt_enc = connection.cursor()
                                try:
                                    cur_alt_enc.execute("ALTER TABLE encuesta_respuestas ADD COLUMN sstt_vencimientos_cursos_fecha_ven DATE NULL AFTER fecha_respuesta")
                                    connection.commit()
                                except Exception:
                                    pass
                                finally:
                                    cur_alt_enc.close()
                        except Exception:
                            pass
                        cur_enc.execute(
                            """
                            SELECT DATE(fecha_respuesta) AS fecha, sstt_vencimientos_cursos_fecha_ven AS fecha_ven
                            FROM encuesta_respuestas
                            WHERE encuesta_id = %s AND usuario_id = %s AND estado IN ('enviada','respondida','finalizada') AND YEAR(fecha_respuesta) = YEAR(CURDATE())
                            ORDER BY fecha_respuesta DESC
                            LIMIT 1
                            """,
                            (10, idc)
                        )
                        er = cur_enc.fetchone()
                    except Exception:
                        er = None
                    finally:
                        cur_enc.close()
                    if er:
                        fecha_enc = er.get('fecha')
                        fecha_ven_enc = er.get('fecha_ven')
                        # Determinar si ya tiene inducción registrada
                        has_induccion = any(('INDUCCION' in str(i.get('tipo_curso') or '').strip().upper().replace('Ó','O').replace('Ú','U').replace('Á','A').replace('É','E').replace('Í','I').replace('Ñ','N')) for i in out)
                        # Determinar si ya existe reinducción del mismo año
                        enc_year = None
                        try:
                            if hasattr(fecha_enc, 'year'):
                                enc_year = int(fecha_enc.year)
                            else:
                                s = str(fecha_enc)
                                enc_year = int(s[0:4]) if len(s) >= 4 and s[0:4].isdigit() else None
                        except Exception:
                            enc_year = None
                        has_reinduccion_same_year = any(('REINDUCCION' in str(i.get('tipo_curso') or '').strip().upper().replace('Ó','O').replace('Ú','U').replace('Á','A').replace('É','E').replace('Í','I').replace('Ñ','N')) and (i.get('anio') == enc_year) for i in out)
                        fv_date_enc = None
                        fv_str_enc = ''
                        try:
                            if fecha_ven_enc:
                                if hasattr(fecha_ven_enc, 'strftime'):
                                    fv_date_enc = fecha_ven_enc
                                    fv_str_enc = fecha_ven_enc.strftime('%Y-%m-%d')
                                else:
                                    s = str(fecha_ven_enc).strip()
                                    if s:
                                        try:
                                            fv_date_enc = datetime.strptime(s, '%Y-%m-%d').date()
                                            fv_str_enc = fv_date_enc.strftime('%Y-%m-%d')
                                        except Exception:
                                            try:
                                                fv_date_enc = datetime.strptime(s, '%Y-%m-%d %H:%M:%S').date()
                                                fv_str_enc = fv_date_enc.strftime('%Y-%m-%d')
                                            except Exception:
                                                fv_date_enc = None
                                                fv_str_enc = ''
                        except Exception:
                            fv_date_enc = None
                            fv_str_enc = ''
                        dias_enc = (fv_date_enc - datetime.now().date()).days if fv_date_enc else None
                        synthetic_item = {
                            'recurso_operativo_cedula': cedula,
                            'nombre': nombre_u,
                            'tipo_curso': ('CURSO INDUCCION SST' if not has_induccion else 'CURSO REINDUCCION SST'),
                            'fecha': (fecha_enc.strftime('%Y-%m-%d') if hasattr(fecha_enc, 'strftime') else str(fecha_enc)),
                            'fecha_vencimiento': fv_str_enc,
                            'dias_por_vencer': dias_enc,
                            'observacion': 'Origen: Encuesta 10',
                            'anio': enc_year
                        }
                        if not has_induccion:
                            out.append(synthetic_item)
                        elif not has_reinduccion_same_year:
                            out.append(synthetic_item)

            cursor.close(); connection.close()
            return jsonify({'success': True, 'data': out, 'total': len(out)})
        else:
            data = request.get_json() or {}
            cedula = (data.get('recurso_operativo_cedula') or '').strip()
            tipo = (data.get('sstt_vencimientos_cursos_tipo_curso') or '').strip()
            fecha = (data.get('sstt_vencimientos_cursos_fecha') or '').strip()
            fecha_ven = (data.get('sstt_vencimientos_cursos_fecha_ven') or '').strip()
            observ = (data.get('sstt_vencimientos_cursos_observacion') or '').strip()
            pendiente_val = data.get('sstt_vencimientos_cursos_pendiente')
            try:
                pendiente_int = 1 if str(pendiente_val).strip().lower() in ['1','true','t','yes','y'] else 0
            except Exception:
                pendiente_int = 0
            # Permitir creación de encabezado pendiente sin fechas
            if pendiente_int == 1 and (not fecha or not fecha_ven):
                try:
                    cur_null = connection.cursor()
                    cur_null.execute(
                        """
                        SELECT IS_NULLABLE
                        FROM information_schema.columns
                        WHERE table_schema = DATABASE() AND table_name = 'sstt_vencimientos_cursos' AND column_name = 'sstt_vencimientos_cursos_fecha_ven'
                        """
                    )
                    res_v = cur_null.fetchone()
                    if res_v and str(res_v[0]).upper() == 'NO':
                        cur_alter_v = connection.cursor()
                        cur_alter_v.execute("ALTER TABLE sstt_vencimientos_cursos MODIFY COLUMN sstt_vencimientos_cursos_fecha_ven DATE NULL DEFAULT NULL")
                        connection.commit()
                        cur_alter_v.close()
                    cur_null.close()
                except Exception:
                    pass
                # Valores por defecto para pendiente: fecha hoy, vencimiento NULL
                from datetime import datetime as _dt
                fecha = _dt.now().strftime('%Y-%m-%d') if not fecha else fecha
                fecha_ven = None
            if not cedula or not tipo or not fecha or (pendiente_int != 1 and not fecha_ven):
                cursor.close(); connection.close()
                return jsonify({'success': False, 'message': 'Campos requeridos faltantes'}), 400
            cur2 = connection.cursor()
            cur2.execute("SELECT id_codigo_consumidor, nombre FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ru = cur2.fetchone()
            if not ru:
                cur2.close(); cursor.close(); connection.close()
                return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404
            idc = ru[0]
            nombre = ru[1]
            cur2.close()
            cursor.execute(
                """
                INSERT INTO sstt_vencimientos_cursos (
                    id_codigo_consumidor,
                    sstt_vencimientos_cursos_nombre,
                    recurso_operativo_cedula,
                    sstt_vencimientos_cursos_tipo_curso,
                    sstt_vencimientos_cursos_fecha,
                    sstt_vencimientos_cursos_fecha_ven,
                    sstt_vencimientos_cursos_observacion,
                    sstt_vencimientos_cursos_pendiente
                ) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
                """,
                (idc, nombre, cedula, tipo, fecha, fecha_ven, observ, pendiente_int)
            )
            connection.commit()
            new_id = cursor.lastrowid
            cursor.close(); connection.close()
            return jsonify({'success': True, 'id': new_id})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/vencimientos-cursos/export', methods=['GET'])
@login_required_api()
def api_sstt_vencimientos_cursos_export():
    try:
        connection = get_db_connection()
        if connection is None:
            return Response('Error de conexión a la base de datos', status=500)
        cursor = connection.cursor(dictionary=True)
        cedula = (request.args.get('cedula') or '').strip()
        solo_activos_param = (request.args.get('solo_activos') or '1').strip().lower()
        solo_activos = solo_activos_param in ['1', 'true', 't', 'yes', 'y']
        params = []
        emp_filters = []
        if solo_activos:
            emp_filters.append("ro.estado = 'Activo'")
        if cedula:
            emp_filters.append('ro.recurso_operativo_cedula = %s')
            params.append(cedula)
        try:
            cur_check = connection.cursor()
            cur_check.execute(
                """
                SELECT COUNT(*) FROM information_schema.columns
                WHERE table_schema = DATABASE() AND table_name = 'sstt_vencimientos_cursos' AND column_name = 'sstt_vencimientos_cursos_validado'
                """
            )
            has_validado = (cur_check.fetchone() or [0])[0]
            cur_check.close()
            if not has_validado:
                try:
                    cur_alter = connection.cursor()
                    cur_alter.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN sstt_vencimientos_cursos_validado TINYINT(1) DEFAULT 0 AFTER sstt_vencimientos_cursos_observacion")
                    connection.commit()
                except Exception:
                    pass
                finally:
                    cur_alter.close()
        except Exception:
            pass
        date_cond = (
            "vc.sstt_vencimientos_cursos_fecha_ven IS NOT NULL AND "
            "vc.sstt_vencimientos_cursos_fecha_ven NOT IN ('0000-00-00','1900-01-01') AND "
            "vc.sstt_vencimientos_cursos_fecha_ven > '1900-01-01' AND "
            "( DATE(vc.sstt_vencimientos_cursos_fecha_ven) <= CURDATE() OR (DATE(vc.sstt_vencimientos_cursos_fecha_ven) > CURDATE() AND DATEDIFF(vc.sstt_vencimientos_cursos_fecha_ven, CURDATE()) <= 30) )"
        )
        validado_cond = "(vc.sstt_vencimientos_cursos_validado IS NULL OR vc.sstt_vencimientos_cursos_validado = 0)"
        pend_cond = "vc.sstt_vencimientos_cursos_pendiente = 1"
        sql = (
            'SELECT '
            'ro.recurso_operativo_cedula AS cedula, '
            'ro.nombre AS nombre, '
            'vc.sstt_vencimientos_cursos_tipo_curso AS curso, '
            "CASE WHEN vc.sstt_vencimientos_cursos_pendiente = 1 THEN 'pendiente' ELSE DATE(vc.sstt_vencimientos_cursos_fecha_ven) END AS vencimiento "
            'FROM sstt_vencimientos_cursos vc '
            'LEFT JOIN recurso_operativo ro ON vc.recurso_operativo_cedula = ro.recurso_operativo_cedula '
        )
        filter_sql = ''
        if emp_filters:
            filter_sql += '( ' + ' AND '.join(emp_filters) + ' ) AND '
        filter_sql += '( ( ' + date_cond + ' AND ' + validado_cond + ' ) OR ( ' + pend_cond + ' ) )'
        sql += ' WHERE ' + filter_sql
        sql += ' ORDER BY ro.nombre ASC, vc.sstt_vencimientos_cursos_fecha_ven ASC'
        cursor.execute(sql, tuple(params))
        rows = cursor.fetchall() or []
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['cedula','nombre','curso','vencimiento'])
        for r in rows:
            fv = r.get('vencimiento')
            if hasattr(fv, 'strftime'):
                fv_str = fv.strftime('%Y-%m-%d')
            else:
                s = str(fv).strip() if fv else ''
                if s and ' ' in s:
                    s = s.split(' ')[0]
                fv_str = s
            writer.writerow([r.get('cedula') or '', r.get('nombre') or '', r.get('curso') or '', fv_str])
        csv_data = output.getvalue()
        output.close()
        cursor.close(); connection.close()
        filename = f"vencimientos_cursos_export_{get_bogota_datetime().strftime('%Y%m%d')}.csv"
        resp = Response(csv_data, mimetype='text/csv')
        resp.headers['Content-Disposition'] = f'attachment; filename="{filename}"'
        return resp
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/sstt/vencimientos-cursos/export-total', methods=['GET'])
@login_required_api()
def api_sstt_vencimientos_cursos_export_total():
    try:
        connection = get_db_connection()
        if connection is None:
            return Response('Error de conexión a la base de datos', status=500)
        cursor = connection.cursor(dictionary=True)
        sql = (
            'SELECT '
            'ro.recurso_operativo_cedula AS cedula, '
            'ro.nombre AS tecnico, '
            'vc.sstt_vencimientos_cursos_tipo_curso AS tipo_de_examen, '
            'vc.sstt_vencimientos_cursos_fecha AS fecha, '
            'vc.sstt_vencimientos_cursos_fecha_ven AS fecha_vencimiento '
            'FROM sstt_vencimientos_cursos vc '
            'LEFT JOIN recurso_operativo ro ON vc.recurso_operativo_cedula = ro.recurso_operativo_cedula '
            'ORDER BY ro.nombre ASC, vc.sstt_vencimientos_cursos_fecha_ven ASC'
        )
        cursor.execute(sql)
        rows = cursor.fetchall() or []
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['cedula','tecnico','tipo_de_examen','fecha','fecha_vencimiento'])
        for r in rows:
            f1 = r.get('fecha')
            if hasattr(f1, 'strftime'):
                f1_str = f1.strftime('%Y-%m-%d')
            else:
                s1 = str(f1).strip() if f1 else ''
                if s1 and ' ' in s1:
                    s1 = s1.split(' ')[0]
                f1_str = s1
            f2 = r.get('fecha_vencimiento')
            if hasattr(f2, 'strftime'):
                f2_str = f2.strftime('%Y-%m-%d')
            else:
                s2 = str(f2).strip() if f2 else ''
                if s2 and ' ' in s2:
                    s2 = s2.split(' ')[0]
                f2_str = s2
            writer.writerow([
                r.get('cedula') or '',
                r.get('tecnico') or '',
                r.get('tipo_de_examen') or '',
                f1_str,
                f2_str
            ])
        csv_data = output.getvalue()
        output.close()
        cursor.close(); connection.close()
        filename = f"vencimientos_cursos_export_total_{get_bogota_datetime().strftime('%Y%m%d')}.csv"
        resp = Response(csv_data, mimetype='text/csv')
        resp.headers['Content-Disposition'] = f'attachment; filename="{filename}"'
        return resp
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/sstt/vencimientos-cursos/<int:item_id>', methods=['PUT'])
@login_required_api()
def api_sstt_vencimientos_cursos_update(item_id):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        data = request.get_json() or {}
        cedula = (data.get('recurso_operativo_cedula') or '').strip()
        tipo = (data.get('sstt_vencimientos_cursos_tipo_curso') or '').strip()
        fecha = (data.get('sstt_vencimientos_cursos_fecha') or '').strip()
        fecha_ven = (data.get('sstt_vencimientos_cursos_fecha_ven') or '').strip()
        observ = (data.get('sstt_vencimientos_cursos_observacion') or '').strip()
        validado_val = data.get('sstt_vencimientos_cursos_validado')
        pendiente_val = data.get('sstt_vencimientos_cursos_pendiente')
        campos = []
        params = []
        idc = None
        nombre = None
        if cedula:
            cur2 = connection.cursor()
            cur2.execute("SELECT id_codigo_consumidor, nombre FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ru = cur2.fetchone()
            cur2.close()
            if ru:
                idc = ru[0]
                nombre = ru[1]
        if idc is not None:
            campos.append("id_codigo_consumidor = %s")
            params.append(idc)
        if nombre is not None:
            campos.append("sstt_vencimientos_cursos_nombre = %s")
            params.append(nombre)
        if cedula:
            campos.append("recurso_operativo_cedula = %s")
            params.append(cedula)
        if tipo:
            campos.append("sstt_vencimientos_cursos_tipo_curso = %s")
            params.append(tipo)
        if fecha:
            campos.append("sstt_vencimientos_cursos_fecha = %s")
            params.append(fecha)
        if fecha_ven:
            campos.append("sstt_vencimientos_cursos_fecha_ven = %s")
            params.append(fecha_ven)
        campos.append("sstt_vencimientos_cursos_observacion = %s")
        params.append(observ)
        try:
            cur_check3 = connection.cursor()
            cur_check3.execute(
                """
                SELECT COUNT(*) FROM information_schema.columns
                WHERE table_schema = DATABASE()
                  AND table_name = 'sstt_vencimientos_cursos'
                  AND column_name = 'sstt_vencimientos_cursos_pendiente'
                """
            )
            has_pend2 = (cur_check3.fetchone() or [0])[0]
            cur_check3.close()
            if not has_pend2:
                try:
                    cur_alter3 = connection.cursor()
                    cur_alter3.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN sstt_vencimientos_cursos_pendiente TINYINT(1) NOT NULL DEFAULT 0 AFTER sstt_vencimientos_cursos_observacion")
                    connection.commit()
                except Exception:
                    pass
                finally:
                    cur_alter3.close()
        except Exception:
            pass
        if pendiente_val is not None:
            try:
                p2_int = 1 if str(pendiente_val).strip().lower() in ['1','true','t','yes','y'] else 0
            except Exception:
                p2_int = 0
            campos.append("sstt_vencimientos_cursos_pendiente = %s")
            params.append(p2_int)
        if validado_val is not None:
            try:
                v_int = 1 if str(validado_val).strip().lower() in ['1', 'true', 't', 'yes', 'y'] else 0
            except Exception:
                v_int = 0
            try:
                cur_checkv = connection.cursor()
                cur_checkv.execute(
                    """
                    SELECT COUNT(*) FROM information_schema.columns
                    WHERE table_schema = DATABASE() AND table_name = 'sstt_vencimientos_cursos' AND column_name = 'sstt_vencimientos_cursos_validado'
                    """
                )
                has_val = (cur_checkv.fetchone() or [0])[0]
                cur_checkv.close()
                if not has_val:
                    cur_alterv = connection.cursor()
                    try:
                        cur_alterv.execute("ALTER TABLE sstt_vencimientos_cursos ADD COLUMN sstt_vencimientos_cursos_validado TINYINT(1) DEFAULT 0 AFTER sstt_vencimientos_cursos_observacion")
                        connection.commit()
                    except Exception:
                        pass
                    finally:
                        cur_alterv.close()
            except Exception:
                pass
            campos.append("sstt_vencimientos_cursos_validado = %s")
            params.append(v_int)
        if not campos:
            connection.close()
            return jsonify({'success': False, 'message': 'Sin cambios'}), 400
        sql = "UPDATE sstt_vencimientos_cursos SET " + ", ".join(campos) + " WHERE id = %s"
        params.append(item_id)
        cur = connection.cursor()
        cur.execute(sql, tuple(params))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/vencimientos-cursos/<int:item_id>', methods=['DELETE'])
@login_required_api()
def api_sstt_vencimientos_cursos_delete(item_id):
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute("DELETE FROM sstt_vencimientos_cursos WHERE id = %s", (item_id,))
        connection.commit()
        affected = cur.rowcount
        cur.close(); connection.close()
        if affected == 0:
            return jsonify({'success': False, 'message': 'Registro no encontrado'}), 404
        return jsonify({'success': True, 'deleted': affected})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/vencimientos-cursos/encuesta-vto', methods=['PUT'])
@login_required_api()
def api_sstt_vencimientos_cursos_encuesta_vto():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        data = request.get_json() or {}
        cedula = (data.get('cedula') or '').strip()
        usuario_id = data.get('usuario_id')
        encuesta_id = int(data.get('encuesta_id') or 10)
        anio = data.get('anio')
        fecha = (data.get('fecha') or '').strip()
        fecha_vto = (data.get('fecha_vencimiento') or '').strip()
        if not fecha_vto:
            return jsonify({'success': False, 'message': 'Falta fecha_vencimiento'}), 400
        cur = connection.cursor()
        if not usuario_id:
            if not cedula:
                return jsonify({'success': False, 'message': 'Faltan parámetros de usuario'}), 400
            cur.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ru = cur.fetchone()
            if not ru:
                return jsonify({'success': False, 'message': 'Usuario no encontrado'}), 404
            usuario_id = ru[0]
        cur.execute(
            """
            SELECT COUNT(*) FROM information_schema.columns
            WHERE table_schema = DATABASE() AND table_name = 'encuesta_respuestas' AND column_name = 'sstt_vencimientos_cursos_fecha_ven'
            """
        )
        has_col = (cur.fetchone() or [0])[0]
        if not has_col:
            try:
                cur.execute("ALTER TABLE encuesta_respuestas ADD COLUMN sstt_vencimientos_cursos_fecha_ven DATE NULL AFTER fecha_respuesta")
                connection.commit()
            except Exception:
                pass
        params = [fecha_vto, encuesta_id, usuario_id]
        where_extra = ''
        if anio:
            where_extra = ' AND YEAR(fecha_respuesta) = %s'
            params.append(int(anio))
        elif fecha:
            where_extra = ' AND DATE(fecha_respuesta) = %s'
            params.append(fecha)
        cur.execute(
            "UPDATE encuesta_respuestas SET sstt_vencimientos_cursos_fecha_ven = %s WHERE encuesta_id = %s AND usuario_id = %s" + where_extra + " ORDER BY fecha_respuesta DESC LIMIT 1",
            tuple(params)
        )
        connection.commit()
        affected = cur.rowcount
        cur.close(); connection.close()
        if affected == 0:
            return jsonify({'success': False, 'message': 'No se encontró respuesta para actualizar'}), 404
        return jsonify({'success': True, 'updated': affected})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/vencimientos-cursos/upload', methods=['POST'])
@login_required_api()
def api_sstt_vencimientos_cursos_upload():
    connection = None
    cursor = None
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})
        cursor = connection.cursor()
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS sstt_vencimientos_cursos (
                id INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                sstt_vencimientos_cursos_nombre VARCHAR(200),
                recurso_operativo_cedula VARCHAR(20),
                sstt_vencimientos_cursos_tipo_curso VARCHAR(100) NOT NULL,
                sstt_vencimientos_cursos_fecha DATE NOT NULL,
                sstt_vencimientos_cursos_fecha_ven DATE NOT NULL,
                sstt_vencimientos_cursos_observacion TEXT,
                sstt_vencimientos_cursos_pendiente TINYINT(1) NOT NULL DEFAULT 0,
                sstt_vencimientos_cursos_fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX idx_cedula (recurso_operativo_cedula),
                INDEX idx_tipo (sstt_vencimientos_cursos_tipo_curso),
                INDEX idx_fecha_ven (sstt_vencimientos_cursos_fecha_ven)
            )
            """
        )
        cursor.close()
        cursor = None
        if 'archivo' not in request.files:
            return jsonify({'success': False, 'message': 'No se ha seleccionado ningún archivo'})
        archivo = request.files['archivo']
        if archivo.filename == '':
            return jsonify({'success': False, 'message': 'No se ha seleccionado ningún archivo'})
        extension = archivo.filename.lower().split('.')[-1]
        if extension not in ['csv', 'xlsx', 'xls']:
            return jsonify({'success': False, 'message': 'Formato no soportado. Use CSV o Excel'})
        datos = []
        try:
            if extension == 'csv':
                contenido_bytes = archivo.read()
                contenido = None
                for enc in ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']:
                    try:
                        contenido = contenido_bytes.decode(enc)
                        break
                    except Exception:
                        continue
                if contenido is None:
                    return jsonify({'success': False, 'message': 'No se pudo decodificar el archivo CSV'})
                reader = csv.DictReader(io.StringIO(contenido))
                datos = list(reader)
            else:
                df = pd.read_excel(archivo)
                datos = df.to_dict('records')
        except Exception as e:
            return jsonify({'success': False, 'message': f'Error al leer el archivo: {str(e)}'})
        if not datos:
            return jsonify({'success': False, 'message': 'El archivo está vacío o no contiene datos válidos'})
        columnas_requeridas = ['recurso_operativo_cedula','sstt_vencimientos_cursos_tipo_curso','sstt_vencimientos_cursos_fecha','sstt_vencimientos_cursos_fecha_ven']
        columnas_opcionales = ['id_codigo_consumidor','sstt_vencimientos_cursos_nombre','sstt_vencimientos_cursos_observacion']
        columnas_archivo = list(datos[0].keys())
        faltantes = [c for c in columnas_requeridas if c not in columnas_archivo]
        if faltantes:
            return jsonify({'success': False, 'message': 'Faltan columnas: ' + ', '.join(faltantes)})
        cursor = connection.cursor()
        procesados = 0
        insertados = 0
        def norm_fecha(s):
            try:
                if s is None:
                    return None
                txt = str(s).strip()
                if not txt:
                    return None
                fmts = ('%Y-%m-%d','%d/%m/%Y','%Y/%m/%d','%d-%m-%Y','%m/%d/%Y','%Y-%m-%d %H:%M:%S')
                from datetime import datetime
                for fmt in fmts:
                    try:
                        return datetime.strptime(txt, fmt).strftime('%Y-%m-%d')
                    except Exception:
                        pass
                return txt
            except Exception:
                return None
        for fila in datos:
            try:
                cedula = str(fila.get('recurso_operativo_cedula') or '').strip()
                tipo = str(fila.get('sstt_vencimientos_cursos_tipo_curso') or '').strip()
                fecha = norm_fecha(fila.get('sstt_vencimientos_cursos_fecha'))
                fecha_ven = norm_fecha(fila.get('sstt_vencimientos_cursos_fecha_ven'))
                observ = str(fila.get('sstt_vencimientos_cursos_observacion') or '').strip()
                idc = fila.get('id_codigo_consumidor')
                nombre = str(fila.get('sstt_vencimientos_cursos_nombre') or '').strip()
                if not cedula or not tipo or not fecha or not fecha_ven:
                    procesados += 1
                    continue
                if not idc or str(idc).strip() == '':
                    cur2 = connection.cursor()
                    cur2.execute("SELECT id_codigo_consumidor, nombre FROM recurso_operativo WHERE recurso_operativo_cedula=%s", (cedula,))
                    ru = cur2.fetchone()
                    if ru:
                        idc = ru[0]
                        if not nombre:
                            nombre = str(ru[1] or '')
                    cur2.close()
                cursor.execute(
                    """
                    INSERT INTO sstt_vencimientos_cursos (
                        id_codigo_consumidor,
                        sstt_vencimientos_cursos_nombre,
                        recurso_operativo_cedula,
                        sstt_vencimientos_cursos_tipo_curso,
                        sstt_vencimientos_cursos_fecha,
                        sstt_vencimientos_cursos_fecha_ven,
                        sstt_vencimientos_cursos_observacion
                    ) VALUES (%s,%s,%s,%s,%s,%s,%s)
                    """,
                    (idc, nombre, cedula, tipo, fecha, fecha_ven, observ)
                )
                insertados += 1
                procesados += 1
            except Exception:
                procesados += 1
                continue
        connection.commit()
        if cursor:
            cursor.close()
        if connection:
            connection.close()
        return jsonify({'success': True, 'message': 'Carga completada', 'procesados': procesados, 'insertados': insertados})
    except Exception as e:
        if cursor:
            try:
                cursor.close()
            except Exception:
                pass
        if connection:
            try:
                connection.close()
            except Exception:
                pass
        return jsonify({'success': False, 'message': str(e)})
@app.route('/api/sstt/capacitaciones', methods=['GET', 'POST'])
@login_required()
def api_sstt_capacitaciones():
    """API para gestionar capacitaciones"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        if request.method == 'GET':
            cursor.execute("""
                SELECT c.*, ro.nombre as instructor_nombre
                FROM sstt_capacitaciones c
                LEFT JOIN recurso_operativo ro ON c.usuario_creador = ro.id_codigo_consumidor
                ORDER BY c.fecha_programada DESC
            """)
            capacitaciones = cursor.fetchall()
            
            return jsonify({'capacitaciones': capacitaciones})
            
        elif request.method == 'POST':
            data = request.get_json()
            
            cursor.execute("""
                INSERT INTO sstt_capacitaciones 
                (titulo, descripcion, fecha_programada, duracion_horas, 
                 ubicacion, estado, usuario_creador, fecha_creacion)
                VALUES (%s, %s, %s, %s, %s, %s, %s, NOW())
            """, (
                data['titulo'],
                data['descripcion'],
                data['fecha_programada'],
                data['duracion_horas'],
                data['ubicacion'],
                data.get('estado', 'programada'),
                session.get('user_id')
            ))
            
            connection.commit()
            capacitacion_id = cursor.lastrowid
            
            return jsonify({
                'success': True, 
                'message': 'Capacitación creada exitosamente',
                'capacitacion_id': capacitacion_id
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/sstt/tecnicos', methods=['GET'])
@login_required()
def api_sstt_tecnicos():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        q = (request.args.get('q') or '').strip()
        limit_param = request.args.get('limit')
        try:
            limit = int(limit_param) if limit_param else 50
        except Exception:
            limit = 50
        where = ["estado = 'Activo'", "id_roles = 2"]
        params = []
        if q:
            where.append("(recurso_operativo_cedula LIKE %s OR nombre LIKE %s)")
            like = f"%{q}%"
            params.extend([like, like])
        sql = (
            "SELECT id_codigo_consumidor, recurso_operativo_cedula, nombre "
            "FROM recurso_operativo"
        )
        if where:
            sql += " WHERE " + " AND ".join(where)
        sql += " ORDER BY nombre ASC LIMIT %s"
        params.append(limit)
        cursor.execute(sql, tuple(params))
        rows = cursor.fetchall() or []
        data = [{
            'id_codigo_consumidor': r.get('id_codigo_consumidor'),
            'cedula': r.get('recurso_operativo_cedula'),
            'nombre': r.get('nombre')
        } for r in rows]
        cursor.close(); connection.close()
        return jsonify({'success': True, 'data': data, 'total': len(data)})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/preoperacional', methods=['GET'])
@login_required()
def api_sstt_preoperacional():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        tecnico_id = (request.args.get('tecnico_id') or '').strip()
        ultimo = (request.args.get('ultimo') or '').strip().lower()
        if not tecnico_id:
            cursor.close(); connection.close()
            return jsonify({'success': False, 'message': 'Parámetro requerido: tecnico_id'}), 400
        if ultimo in ['1', 'true', 'yes', 'si']:
            cursor.execute(
                """
                SELECT * FROM preoperacional 
                WHERE id_codigo_consumidor = %s
                ORDER BY fecha DESC LIMIT 1
                """,
                (tecnico_id,)
            )
        else:
            fecha = (request.args.get('fecha') or '').strip()
            if not fecha:
                cursor.close(); connection.close()
                return jsonify({'success': False, 'message': 'Parámetros requeridos: tecnico_id y fecha'}), 400
            cursor.execute(
                """
                SELECT * FROM preoperacional 
                WHERE id_codigo_consumidor = %s AND DATE(fecha) = %s
                ORDER BY fecha DESC LIMIT 1
                """,
                (tecnico_id, fecha)
            )
        row = cursor.fetchone()
        if not row:
            cursor.close(); connection.close()
            return jsonify({'success': True, 'data': None})
        for k, v in list(row.items()):
            try:
                if hasattr(v, 'strftime'):
                    row[k] = v.strftime('%Y-%m-%d %H:%M:%S')
            except Exception:
                pass
        cursor.close(); connection.close()
        return jsonify({'success': True, 'data': row})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/tecnicos-con-preoperacional', methods=['GET'])
@login_required()
def api_sstt_tecnicos_con_preoperacional():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        fecha = (request.args.get('fecha') or '').strip()
        ultima = (request.args.get('ultima') or '').strip().lower()
        if not fecha and ultima not in ['1', 'true', 'yes', 'si']:
            from datetime import datetime
            fecha = datetime.now().strftime('%Y-%m-%d')
        else:
            s = fecha
            if s:
                if '/' in s:
                    parts = s.split('/')
                    if len(parts) == 3:
                        d, m, y = parts
                        fecha = f"{y}-{m.zfill(2)}-{d.zfill(2)}"
                elif '-' in s:
                    parts = s.split('-')
                    if len(parts) == 3 and len(parts[0]) == 2:
                        d, m, y = parts
                        fecha = f"{y}-{m.zfill(2)}-{d.zfill(2)}"
        q = (request.args.get('q') or '').strip()
        limit_param = request.args.get('limit')
        try:
            limit = int(limit_param) if limit_param else 500
        except Exception:
            limit = 500
        params = []
        if ultima in ['1', 'true', 'yes', 'si']:
            sql = (
                "SELECT ro.id_codigo_consumidor, ro.recurso_operativo_cedula AS cedula, ro.nombre, "
                "pmax.fecha, pmax.observaciones "
                "FROM (SELECT id_codigo_consumidor, MAX(fecha) AS fecha FROM preoperacional GROUP BY id_codigo_consumidor) pm "
                "JOIN preoperacional pmax ON pmax.id_codigo_consumidor = pm.id_codigo_consumidor AND pmax.fecha = pm.fecha "
                "JOIN recurso_operativo ro ON ro.id_codigo_consumidor = pm.id_codigo_consumidor "
            )
        else:
            sql = (
                "SELECT ro.id_codigo_consumidor, ro.recurso_operativo_cedula AS cedula, ro.nombre, "
                "pmax.fecha, pmax.observaciones "
                "FROM (SELECT id_codigo_consumidor, MAX(fecha) AS fecha FROM preoperacional WHERE DATE(fecha) = %s GROUP BY id_codigo_consumidor) pm "
                "JOIN preoperacional pmax ON pmax.id_codigo_consumidor = pm.id_codigo_consumidor AND pmax.fecha = pm.fecha "
                "JOIN recurso_operativo ro ON ro.id_codigo_consumidor = pm.id_codigo_consumidor "
            )
            params.append(fecha)
        if q:
            like = f"%{q}%"
            sql += "WHERE (ro.recurso_operativo_cedula LIKE %s OR ro.nombre LIKE %s) "
            params.extend([like, like])
        sql += "ORDER BY ro.nombre ASC LIMIT %s"
        params.append(limit)
        cursor.execute(sql, tuple(params))
        rows = cursor.fetchall() or []
        for r in rows:
            f = r.get('fecha')
            if hasattr(f, 'strftime'):
                r['fecha'] = f.strftime('%Y-%m-%d %H:%M:%S')
            try:
                cur2 = connection.cursor(dictionary=True)
                if ultima in ['1', 'true', 'yes', 'si']:
                    cur2.execute(
                        "SELECT observaciones FROM preoperacional WHERE id_codigo_consumidor = %s ORDER BY fecha DESC LIMIT 1",
                        (r.get('id_codigo_consumidor'),)
                    )
                else:
                    cur2.execute(
                        "SELECT observaciones FROM preoperacional WHERE id_codigo_consumidor = %s AND DATE(fecha) = %s ORDER BY fecha DESC LIMIT 1",
                        (r.get('id_codigo_consumidor'), fecha)
                    )
                ob = cur2.fetchone() or {}
                r['observaciones'] = ob.get('observaciones')
                cur2.close()
            except Exception:
                r['observaciones'] = r.get('observaciones')
        cursor.close(); connection.close()
        return jsonify({'success': True, 'data': rows, 'total': len(rows)})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/preoperacional/export', methods=['GET'])
@login_required()
def api_sstt_preoperacional_export():
    try:
        mes = (request.args.get('mes') or '').strip()
        import re as _re
        if not mes or not _re.match(r'^\d{4}-\d{2}$', mes):
            return jsonify({'success': False, 'message': 'Parámetro mes requerido (YYYY-MM)'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute(
            """
            SELECT 
                p.*,
                r.nombre as nombre_tecnico,
                r.cargo as cargo_tecnico,
                r.recurso_operativo_cedula as cedula_tecnico
            FROM preoperacional p
            JOIN recurso_operativo r ON p.id_codigo_consumidor = r.id_codigo_consumidor
            WHERE DATE_FORMAT(p.fecha, '%Y-%m') = %s
            ORDER BY p.fecha ASC
            """,
            (mes,)
        )
        registros = cursor.fetchall()
        cursor.close(); connection.close()
        import io as _io
        import csv as _csv
        output = _io.StringIO()
        writer = _csv.writer(output, delimiter=',', quotechar='"', quoting=_csv.QUOTE_ALL)
        output.write('\ufeff')
        writer.writerow([
            'Fecha', 'Técnico', 'Cédula', 'Cargo', 'Centro de Trabajo', 'Ciudad', 'Supervisor',
            'Vehículo Asistió', 'Tipo Vehículo', 'Placa', 'Modelo', 'Marca',
            'Licencia Conducción', 'Vencimiento Licencia', 'Vencimiento SOAT',
            'Vencimiento Tecnomecánica', 'Estado Espejos', 'Bocina/Pito',
            'Frenos', 'Encendido', 'Batería', 'Amortiguadores', 'Llantas',
            'Kilometraje', 'Luces Altas/Bajas', 'Direccionales',
            'Elementos Prevención Casco', 'Casco Certificado', 'Casco Identificado',
            'Estado Guantes', 'Estado Rodilleras', 'Coderas', 'Impermeable', 'Observaciones'
        ])
        for registro in registros:
            try:
                fecha_lic = registro.get('fecha_vencimiento_licencia')
                fecha_soat = registro.get('fecha_vencimiento_soat')
                fecha_tec = registro.get('fecha_vencimiento_tecnomecanica')
                fl = fecha_lic.strftime('%Y-%m-%d') if hasattr(fecha_lic, 'strftime') else (fecha_lic or '')
                fs = fecha_soat.strftime('%Y-%m-%d') if hasattr(fecha_soat, 'strftime') else (fecha_soat or '')
                ft = fecha_tec.strftime('%Y-%m-%d') if hasattr(fecha_tec, 'strftime') else (fecha_tec or '')
            except Exception:
                fl = fs = ft = ''
            try:
                fdt = registro.get('fecha')
                fecha_str = fdt.strftime('%Y-%m-%d %H:%M:%S') if hasattr(fdt, 'strftime') else (fdt or '')
            except Exception:
                fecha_str = ''
            km = registro.get('kilometraje_actual') if 'kilometraje_actual' in registro else registro.get('kilometraje')
            writer.writerow([
                fecha_str,
                registro.get('nombre_tecnico') or '',
                registro.get('cedula_tecnico') or '',
                registro.get('cargo_tecnico') or '',
                registro.get('centro_de_trabajo') or '',
                registro.get('ciudad') or '',
                registro.get('supervisor') or '',
                registro.get('vehiculo_asistio_operacion') or '',
                registro.get('tipo_vehiculo') or '',
                registro.get('placa_vehiculo') or '',
                registro.get('modelo_vehiculo') or '',
                registro.get('marca_vehiculo') or '',
                registro.get('licencia_conduccion') or '',
                fl,
                fs,
                ft,
                registro.get('estado_espejos') or '',
                registro.get('bocina_pito') or '',
                registro.get('frenos') or '',
                registro.get('encendido') or '',
                registro.get('estado_bateria') or '',
                registro.get('estado_amortiguadores') or '',
                registro.get('estado_llantas') or '',
                km or '',
                registro.get('luces_altas_bajas') or '',
                registro.get('direccionales_delanteras_traseras') or '',
                registro.get('elementos_prevencion_seguridad_vial_casco') or '',
                registro.get('casco_certificado') or '',
                registro.get('casco_identificado') or '',
                registro.get('estado_guantes') or registro.get('elementos_prevencion_seguridad_vial_guantes') or '',
                registro.get('estado_rodilleras') or registro.get('elementos_prevencion_seguridad_vial_rodilleras') or '',
                registro.get('elementos_prevencion_seguridad_vial_coderas') or '',
                registro.get('impermeable') or registro.get('elementos_prevencion_seguridad_vial_impermeable') or '',
                registro.get('observaciones') or ''
            ])
        output.seek(0)
        return send_file(
            _io.BytesIO(output.getvalue().encode('utf-8-sig')),
            mimetype='text/csv; charset=utf-8-sig',
            as_attachment=True,
            download_name=f'preoperacional_{mes}.csv'
        )
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/sstt/incidentes', methods=['GET', 'POST'])
@login_required()
def api_sstt_incidentes():
    """API para gestionar incidentes laborales"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        if request.method == 'GET':
            cursor.execute("""
                SELECT i.*, ro.nombre as reporta_nombre
                FROM sstt_incidentes i
                LEFT JOIN recurso_operativo ro ON i.usuario_reporta = ro.id_codigo_consumidor
                ORDER BY i.fecha_incidente DESC
            """)
            incidentes = cursor.fetchall()
            
            return jsonify({'incidentes': incidentes})
            
        elif request.method == 'POST':
            data = request.get_json()
            
            cursor.execute("""
                INSERT INTO sstt_incidentes 
                (fecha_incidente, ubicacion, descripcion, tipo_incidente, 
                 gravedad, usuario_reporta, fecha_reporte)
                VALUES (%s, %s, %s, %s, %s, %s, NOW())
            """, (
                data['fecha_incidente'],
                data['ubicacion'],
                data['descripcion'],
                data['tipo_incidente'],
                data['gravedad'],
                session.get('user_id')
            ))
            
            connection.commit()
            incidente_id = cursor.lastrowid
            
            return jsonify({
                'success': True, 
                'message': 'Incidente reportado exitosamente',
                'incidente_id': incidente_id
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/sstt/epp', methods=['GET', 'POST'])
@login_required()
def api_sstt_epp():
    """API para control de EPP (Elementos de Protección Personal)"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        if request.method == 'GET':
            cursor.execute("""
                SELECT e.*, ro.nombre as usuario_nombre
                FROM sstt_epp_control e
                LEFT JOIN recurso_operativo ro ON e.usuario_id = ro.id_codigo_consumidor
                ORDER BY e.fecha_entrega DESC
            """)
            epp_registros = cursor.fetchall()
            
            return jsonify({'epp_registros': epp_registros})
            
        elif request.method == 'POST':
            data = request.get_json()
            
            cursor.execute("""
                INSERT INTO sstt_epp_control 
                (usuario_id, tipo_epp, marca, modelo, fecha_entrega, 
                 fecha_vencimiento, estado, observaciones)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                data['usuario_id'],
                data['tipo_epp'],
                data['marca'],
                data['modelo'],
                data['fecha_entrega'],
                data.get('fecha_vencimiento'),
                data.get('estado', 'activo'),
                data.get('observaciones', '')
            ))
            
            connection.commit()
            epp_id = cursor.lastrowid
            
            return jsonify({
                'success': True, 
                'message': 'Registro de EPP creado exitosamente',
                'epp_id': epp_id
            })
            
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/sstt/dashboard-stats', methods=['GET'])
@login_required()
def api_sstt_dashboard_stats():
    """API para estadísticas del dashboard SSTT"""
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        stats = {}
        
        # Estadísticas de inspecciones
        cursor.execute("SELECT COUNT(*) as total FROM sstt_inspecciones")
        stats['total_inspecciones'] = cursor.fetchone()['total']
        
        cursor.execute("SELECT COUNT(*) as pendientes FROM sstt_inspecciones WHERE estado = 'pendiente'")
        stats['inspecciones_pendientes'] = cursor.fetchone()['pendientes']
        
        # Estadísticas de capacitaciones
        cursor.execute("SELECT COUNT(*) as total FROM sstt_capacitaciones")
        stats['total_capacitaciones'] = cursor.fetchone()['total']
        
        cursor.execute("SELECT COUNT(*) as programadas FROM sstt_capacitaciones WHERE estado = 'programada'")
        stats['capacitaciones_programadas'] = cursor.fetchone()['programadas']
        
        # Estadísticas de incidentes
        cursor.execute("SELECT COUNT(*) as total FROM sstt_incidentes")
        stats['total_incidentes'] = cursor.fetchone()['total']
        
        cursor.execute("""
            SELECT COUNT(*) as recientes 
            FROM sstt_incidentes 
            WHERE fecha_incidente >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        """)
        stats['incidentes_mes'] = cursor.fetchone()['recientes']
        
        # Estadísticas de EPP
        cursor.execute("SELECT COUNT(*) as total FROM sstt_epp_control")
        stats['total_epp'] = cursor.fetchone()['total']
        
        cursor.execute("""
            SELECT COUNT(*) as vencidos 
            FROM sstt_epp_control 
            WHERE fecha_vencimiento <= NOW() AND estado = 'activo'
        """)
        stats['epp_vencidos'] = cursor.fetchone()['vencidos']
        
        return jsonify(stats)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/sgis')
@login_required()
def sgis_dashboard():
    if session.get('user_role') not in ['tecnicos', 'operativo', 'administrativo', 'sstt', 'SSTT', 'tecnico', 'Tecnico']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    habilitar_escaleras = False
    tiene_asistencia = False
    ro_info = {}
    try:
        connection = get_db_connection()
        if connection:
            cursor = connection.cursor(dictionary=True)
            cursor.execute("SELECT carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (session.get('user_cedula'),))
            row = cursor.fetchone() or {}
            carpeta = (row.get('carpeta') or '').strip().upper()
            habilitar_escaleras = carpeta == 'APOYO CAMIONETAS'
            cursor.execute("SELECT nombre, cargo, recurso_operativo_cedula, super, cliente, ciudad FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (session.get('user_cedula'),))
            ro_info = cursor.fetchone() or {}
            try:
                cargo_u = (ro_info.get('cargo') or '').strip().upper()
                if cargo_u in ['CONDUCTOR', 'TECNICO CONDUCTOR']:
                    habilitar_escaleras = True
            except Exception:
                pass
            cedula_usuario = session.get('user_cedula')
            if cedula_usuario == '52912112':
                tiene_asistencia = True
            else:
                fecha_hoy = get_bogota_datetime().strftime('%Y-%m-%d')
                cursor.execute(
                    """
                    SELECT COUNT(*) as registros_hoy
                    FROM asistencia 
                    WHERE id_codigo_consumidor = %s AND DATE(fecha_asistencia) = %s AND carpeta_dia != '0'
                    """,
                    (session.get('id_codigo_consumidor'), fecha_hoy)
                )
                reg = cursor.fetchone() or {}
                try:
                    tiene_asistencia = (reg.get('registros_hoy') or 0) > 0
                except Exception:
                    tiene_asistencia = False
            cursor.close()
            connection.close()
    except Exception:
        pass
    return render_template('modulos/sgis/dashboard.html', habilitar_escaleras=habilitar_escaleras, tiene_asistencia=tiene_asistencia, ro_info=ro_info)

@app.route('/sgis/preoperacional-epp')
@login_required()
def sgis_preoperacional_epp_page():
    if session.get('user_role') not in ['tecnicos', 'operativo', 'administrativo', 'sstt', 'SSTT', 'tecnico', 'Tecnico']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    return render_template('modulos/sgis/preoperacional_epp.html')

@app.route('/sgis/preoperacional-escaleras')
@login_required()
def sgis_preoperacional_escaleras_page():
    if session.get('user_role') not in ['tecnicos', 'operativo', 'administrativo', 'sstt', 'SSTT', 'tecnico', 'Tecnico']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    info = {}
    try:
        connection = get_db_connection()
        if connection:
            cursor = connection.cursor(dictionary=True)
            cursor.execute("SELECT nombre, cargo, area FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (session.get('user_cedula'),))
            info = cursor.fetchone() or {}
            cursor.close()
            connection.close()
    except Exception:
        pass
    mes = get_bogota_datetime().strftime('%Y-%m')
    return render_template('modulos/sgis/preoperacional_escaleras.html', info=info, mes=mes)

@app.route('/sgis/reportes')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_page():
    return render_template('modulos/sgis/reportes_menu.html')

@app.route('/sgis/reportes/epp')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_epp_page():
    return render_template('modulos/sgis/reportes.html')

@app.route('/sgis/reportes/escaleras')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_escaleras_page():
    return render_template('modulos/sgis/reportes_escaleras.html')

@app.route('/sgis/reportes/caidas')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_caidas_page():
    return render_template('modulos/sgis/reportes_caidas.html')

@app.route('/sgis/reportes/tsr')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_tsr_page():
    return render_template('modulos/sgis/reportes_tsr.html')

@app.route('/sgis/reportes/permiso-trabajo')
@login_required(role=['administrativo','operativo'])
def sgis_reportes_permiso_trabajo_page():
    return render_template('modulos/sgis/reportes_permiso_trabajo.html')

@app.route('/api/sgis/preoperacional-epp', methods=['POST'])
@login_required_api()
def api_sgis_preoperacional_epp():
    try:
        data = request.get_json() or {}
        items = data.get('items') or {}
        observaciones = (data.get('observaciones') or '').strip()
        def m(val):
            return 'C' if bool(val) else 'NC'
        payload = {
            'casco_estado_general': m(items.get('casco', True)),
            'casco_uso_inf_2_anos': 'C',
            'casco_estado_tafilete': 'C',
            'casco_puntos_anclaje': 'C',
            'barbuquejo_estado_puntos_apoyo': 'C',
            'barbuquejo_estado_sujetador_menton': 'C',
            'barbuquejo_estado_costuras_correas': 'C',
            'guantes_estado_costuras': m(items.get('guantes', True)),
            'guantes_estado_palma': 'C',
            'guantes_estado_general': 'C',
            'monogafas_estado_lentes': m(items.get('gafas', True)),
            'monogafas_estado_patillas': 'C',
            'monogafas_estado_puente_nariz': 'C',
            'observacion': observaciones,
            'firma_base64': data.get('firma_base64') or None
        }
        required_fields = [
            'casco_estado_general','casco_uso_inf_2_anos','casco_estado_tafilete','casco_puntos_anclaje',
            'barbuquejo_estado_puntos_apoyo','barbuquejo_estado_sujetador_menton','barbuquejo_estado_costuras_correas',
            'guantes_estado_costuras','guantes_estado_palma','guantes_estado_general',
            'monogafas_estado_lentes','monogafas_estado_patillas','monogafas_estado_puente_nariz'
        ]
        for f in required_fields:
            v = payload.get(f)
            if v not in ('C','NC','N/A'):
                return jsonify({'success': False, 'error': f'Campo inválido o faltante: {f}'}), 400
        any_nc = any(payload.get(f) == 'NC' for f in required_fields)
        if any_nc and not observaciones:
            return jsonify({'success': False, 'error': 'Observaciones requeridas por hallazgos NC'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        ced = session.get('user_cedula')
        cursor.execute("SELECT nombre FROM recurso_operativo WHERE id_codigo_consumidor = %s", (uid,))
        urow = cursor.fetchone() or {}
        nombre = urow.get('nombre') or session.get('user_name')
        cargo = session.get('user_role')
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        try:
            cursor.execute(
                """
                SELECT COUNT(*) AS c
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE()
                  AND TABLE_NAME = 'sgis_trabajos_seguridad_rutina'
                  AND COLUMN_NAME = 'firma_supervisor'
                """
            )
            col = cursor.fetchone() or {'c': 0}
            if int(col.get('c') or 0) == 0:
                connection.cursor().execute(
                    "ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN firma_supervisor LONGTEXT"
                )
        except Exception:
            pass
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_dia DATE")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'recurso_operativo_cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN recurso_operativo_cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'recurso_operativo_cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN recurso_operativo_cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cargo'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cargo VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'nombre'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN nombre VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha DATETIME")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma_base64'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma_base64 LONGTEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'observacion'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN observacion TEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_registro'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_registro DATETIME")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma LONGTEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'id_codigo_consumidor'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN id_codigo_consumidor INT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'usuario_id'")
        if cur_sys.fetchone():
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET id_codigo_consumidor = usuario_id WHERE id_codigo_consumidor IS NULL")
            connection.commit()
        cur_sys.execute("SHOW INDEX FROM sgis_pre_proteccion_personal WHERE Key_name = 'uq_tecnico_dia'")
        if not cur_sys.fetchone():
            try:
                connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)")
                connection.commit()
            except Exception:
                pass
        fecha = get_bogota_datetime()
        fecha_dia = fecha.date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_personal WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, fecha_dia))
        row = cursor.fetchone()
        if row and row.get('c',0) > 0:
            return jsonify({'success': False, 'error': 'Ya registraste el preoperacional hoy'}), 409
        cursor.execute(
            """
            INSERT INTO sgis_pre_proteccion_personal (
                id_codigo_consumidor, cargo, recurso_operativo_cedula, casco_estado_general,
                casco_uso_inf_2_anos, casco_estado_tafilete, casco_puntos_anclaje,
                barbuquejo_estado_puntos_apoyo, barbuquejo_estado_sujetador_menton, barbuquejo_estado_costuras_correas,
                guantes_estado_costuras, guantes_estado_palma, guantes_estado_general,
                monogafas_estado_lentes, monogafas_estado_patillas, monogafas_estado_puente_nariz,
                observacion, fecha_registro, firma, fecha_dia, cedula, nombre, fecha, firma_base64
            ) VALUES (
                %s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,%s,%s,%s,%s
            )
            """,
            (
                uid, cargo, ced, payload['casco_estado_general'],
                payload['casco_uso_inf_2_anos'], payload['casco_estado_tafilete'], payload['casco_puntos_anclaje'],
                payload['barbuquejo_estado_puntos_apoyo'], payload['barbuquejo_estado_sujetador_menton'], payload['barbuquejo_estado_costuras_correas'],
                payload['guantes_estado_costuras'], payload['guantes_estado_palma'], payload['guantes_estado_general'],
                payload['monogafas_estado_lentes'], payload['monogafas_estado_patillas'], payload['monogafas_estado_puente_nariz'],
                observaciones, fecha, payload['firma_base64'], fecha_dia, ced, nombre, fecha, payload['firma_base64']
            )
        )
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tsr-firmar-supervisor', methods=['POST'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_reportes_tsr_firmar_supervisor():
    try:
        data = request.get_json(force=True) or {}
        cedula = str(data.get('cedula') or '').strip()
        mes = str(data.get('mes') or '').strip()
        dia = data.get('dia')
        fecha_dia = data.get('fecha_dia')
        firma = str(data.get('firma') or data.get('firma_base64') or '').strip()
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if not fecha_dia:
            if not mes or not dia:
                return jsonify({'success': False, 'error': 'Mes y día requeridos'}), 400
            try:
                fecha_dia = datetime.strptime(f"{mes}-{int(dia):02d}", '%Y-%m-%d').date()
            except Exception:
                return jsonify({'success': False, 'error': 'Fecha inválida'}), 400
        else:
            try:
                fecha_dia = datetime.strptime(str(fecha_dia), '%Y-%m-%d').date()
            except Exception:
                return jsonify({'success': False, 'error': 'Fecha inválida'}), 400
        if not firma:
            return jsonify({'success': False, 'error': 'Firma requerida'}), 400
        inicio = fecha_dia.replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() == 'operativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) AS c 
                    FROM recurso_operativo 
                    WHERE recurso_operativo_cedula = %s 
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    """,
                    (cedula, sup_name)
                )
                ro_c = cursor.fetchone() or {}
                supervised = int(ro_c.get('c') or 0) > 0
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                        """,
                        (cedula, sup_name, inicio, fin)
                    )
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        try:
            c2 = connection.cursor()
            c2.execute("SHOW COLUMNS FROM sgis_trabajos_seguridad_rutina LIKE 'firma_supervisor'")
            if not c2.fetchone():
                try:
                    c2.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN firma_supervisor LONGTEXT NULL")
                    connection.commit()
                except Exception:
                    pass
            c2.execute("SHOW COLUMNS FROM sgis_trabajos_seguridad_rutina LIKE 'firma_supervisor_usuario'")
            if not c2.fetchone():
                try:
                    c2.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN firma_supervisor_usuario VARCHAR(128) NULL")
                    connection.commit()
                except Exception:
                    pass
            c2.execute("SHOW COLUMNS FROM sgis_trabajos_seguridad_rutina LIKE 'firma_supervisor_cedula'")
            if not c2.fetchone():
                try:
                    c2.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN firma_supervisor_cedula VARCHAR(20) NULL")
                    connection.commit()
                except Exception:
                    pass
            c2.execute("SHOW COLUMNS FROM sgis_trabajos_seguridad_rutina LIKE 'firma_supervisor_fecha'")
            if not c2.fetchone():
                try:
                    c2.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN firma_supervisor_fecha DATETIME NULL")
                    connection.commit()
                except Exception:
                    pass
            c2.close()
        except Exception:
            pass
        cursor.execute(
            """
            SELECT COUNT(*) AS c 
            FROM sgis_trabajos_seguridad_rutina
            WHERE recurso_operativo_cedula = %s AND fecha_dia = %s AND COALESCE(firma_trabajador,'') <> ''
            """,
            (cedula, fecha_dia)
        )
        row = cursor.fetchone() or {}
        if int(row.get('c') or 0) == 0:
            return jsonify({'success': False, 'error': 'No hay firma de técnico en el día seleccionado'}), 400
        sup_user = (session.get('user_name') or '').strip()
        sup_ced = (session.get('user_cedula') or '').strip()
        cursor.execute(
            """
            UPDATE sgis_trabajos_seguridad_rutina
            SET firma_supervisor = %s,
                firma_supervisor_usuario = %s,
                firma_supervisor_cedula = %s,
                firma_supervisor_fecha = NOW()
            WHERE recurso_operativo_cedula = %s 
              AND fecha_dia = %s 
              AND COALESCE(firma_trabajador,'') <> ''
              AND COALESCE(firma_supervisor,'') = ''
            ORDER BY fecha_registro DESC
            LIMIT 1
            """,
            (firma, sup_user, sup_ced, cedula, fecha_dia)
        )
        connection.commit()
        if cursor.rowcount == 0:
            return jsonify({'success': False, 'error': 'Ya están firmados todos los registros de este día'}), 409
        return jsonify({'success': True, 'fecha_dia': fecha_dia.strftime('%Y-%m-%d')})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes', methods=['GET'])
@login_required_api()
def api_sgis_reportes_tecnicos_mes():
    try:
        mes = request.args.get('mes')
        supervisor = request.args.get('supervisor')
        ur = session.get('user_role')
        if str(ur or '').strip().lower() != 'administrativo':
            supervisor = (session.get('user_name') or '').strip()
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        query = f"""
            SELECT a.cedula, COALESCE(a.tecnico, r.nombre) AS tecnico
            FROM asistencia a
            LEFT JOIN recurso_operativo r ON r.recurso_operativo_cedula = a.cedula
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
        """
        params = [inicio, fin] + allowed_upper + exc_upper
        if supervisor:
            query += " AND TRIM(a.super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci"
            params.append(supervisor)
        query += " GROUP BY a.cedula, tecnico ORDER BY tecnico"
        cursor.execute(query, tuple(params))
        filas = cursor.fetchall()
        if str(ur or '').strip().lower() != 'administrativo' and (not filas or len(filas) == 0):
            try:
                cursor.execute(
                    """
                    SELECT recurso_operativo_cedula AS cedula, nombre AS tecnico
                    FROM recurso_operativo
                    WHERE estado = 'Activo'
                      AND (carpeta IS NULL OR carpeta <> 'SUPERVISORES')
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    ORDER BY nombre
                    """,
                    (supervisor,)
                )
                filas = cursor.fetchall()
                if not filas:
                    sup_prefix = ' '.join(str(supervisor or '').strip().split()[:2])
                    if sup_prefix:
                        cursor.execute(
                            """
                            SELECT recurso_operativo_cedula AS cedula, nombre AS tecnico
                            FROM recurso_operativo
                            WHERE estado = 'Activo'
                              AND (carpeta IS NULL OR carpeta <> 'SUPERVISORES')
                              AND TRIM(super) COLLATE utf8mb4_general_ci LIKE CONCAT('%', TRIM(%s), '%')
                            ORDER BY nombre
                            """,
                            (sup_prefix,)
                        )
                        filas = cursor.fetchall()
            except Exception:
                filas = []
        data = []
        for f in filas:
            ced = f.get('cedula')
            nom = f.get('tecnico')
            total_dias = 0
            completos = 0
            cnt_epp = 0
            cnt_caidas = 0
            cnt_escaleras = 0
            cnt_tsr = 0
            cnt_permiso = 0
            idc = None
            try:
                cursor.execute("SELECT id_codigo_consumidor, UPPER(TRIM(cargo)) AS cargo, UPPER(TRIM(carpeta)) AS carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (ced,))
                ro = cursor.fetchone() or {}
                idc = ro.get('id_codigo_consumidor')
                cargo_u = (ro.get('cargo') or '').strip().upper()
                carpeta_u = (ro.get('carpeta') or '').strip().upper()
            except Exception:
                idc = None
            dias = []
            try:
                sql_dias = f"""
                    SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
                    FROM asistencia a
                    WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
                      AND (
                            EXISTS (
                                SELECT 1 FROM tipificacion_asistencia t
                                WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                                  AND t.valor = '1'
                            )
                         OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
                      )
                      AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
                    ORDER BY dia
                    """
                cursor.execute(sql_dias, (ced, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper))
                dias = [r.get('dia') for r in (cursor.fetchall() or []) if r.get('dia')]
            except Exception:
                dias = []
            total_dias = len(dias)
            if total_dias > 0:
                dias_set = set(dias)
                epp_set = set()
                caidas_set = set()
                escaleras_set = set()
                tsr_set = set()
                permiso_set = set()
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_personal
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_personal
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, inicio, fin)
                        )
                    epp_rows = cursor.fetchall() or []
                    for r in epp_rows:
                        di = r.get('dia')
                        if di:
                            epp_set.add(di)
                except Exception:
                    epp_set = set()
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_caidas
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_caidas
                            WHERE (
                                   (cedula = %s OR recurso_operativo_cedula = %s)
                                OR id_codigo_consumidor IN (
                                     SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                                   )
                              )
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, ced, inicio, fin)
                        )
                    caidas_rows = cursor.fetchall() or []
                    for r in caidas_rows:
                        di = r.get('dia')
                        if di:
                            caidas_set.add(di)
                except Exception:
                    caidas_set = set()
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_escaleras
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_escaleras
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, inicio, fin)
                        )
                    esc_rows = cursor.fetchall() or []
                    for r in esc_rows:
                        di = r.get('dia')
                        if di:
                            escaleras_set.add(di)
                except Exception:
                    escaleras_set = set()
                try:
                    cursor.execute(
                        """
                        SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha_registro)) AS dia
                        FROM sgis_trabajos_seguridad_rutina
                        WHERE (recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                          AND COALESCE(fecha_dia, DATE(fecha_registro)) BETWEEN %s AND %s
                        """,
                        (ced, idc or 0, inicio, fin)
                    )
                    tsr_rows = cursor.fetchall() or []
                    for r in tsr_rows:
                        di = r.get('dia')
                        if di:
                            tsr_set.add(di)
                except Exception:
                    tsr_set = set()
                hist_all = set()
                try:
                    cursor.execute(
                        """
                        SELECT COLUMN_NAME
                        FROM INFORMATION_SCHEMA.COLUMNS
                        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                        """
                    )
                    table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
                    filtro_parts_h = []
                    filtro_params_h = []
                    if 'id_codigo_consumidor' in table_cols and idc:
                        filtro_parts_h.append('p.id_codigo_consumidor = %s')
                        filtro_params_h.append(idc)
                    if 'recurso_operativo_cedula' in table_cols:
                        filtro_parts_h.append('p.recurso_operativo_cedula = %s')
                        filtro_params_h.append(ced)
                    if 'cedula' in table_cols:
                        filtro_parts_h.append('p.cedula = %s')
                        filtro_params_h.append(ced)
                    filtro_usuario_h = ' OR '.join(filtro_parts_h)
                    if filtro_usuario_h:
                        sql_hc = (
                            "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) AS dia "
                            "FROM sgis_permiso_trabajo_historial_semanal_confinado h "
                            "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                            "WHERE DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s "
                            f"AND ({filtro_usuario_h})"
                        )
                        cursor.execute(sql_hc, (inicio, fin) + tuple(filtro_params_h))
                        for r in cursor.fetchall() or []:
                            di = r.get('dia')
                            if di:
                                hist_all.add(di)
                        sql_ha = (
                            "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_altura_fecha) AS dia "
                            "FROM sgis_permiso_trabajo_historial_semanal_altura h "
                            "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                            "WHERE DATE(h.sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s "
                            f"AND ({filtro_usuario_h})"
                        )
                        cursor.execute(sql_ha, (inicio, fin) + tuple(filtro_params_h))
                        for r in cursor.fetchall() or []:
                            di = r.get('dia')
                            if di:
                                hist_all.add(di)
                except Exception:
                    pass
                try:
                    cursor.execute(
                        """
                        SELECT COLUMN_NAME
                        FROM INFORMATION_SCHEMA.COLUMNS
                        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                        """
                    )
                    table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
                    where_parts = []
                    params_p = []
                    if 'id_codigo_consumidor' in table_cols and idc:
                        where_parts.append('p.id_codigo_consumidor = %s')
                        params_p.append(idc)
                    if 'recurso_operativo_cedula' in table_cols:
                        where_parts.append('p.recurso_operativo_cedula = %s')
                        params_p.append(ced)
                    if 'cedula' in table_cols:
                        where_parts.append('p.cedula = %s')
                        params_p.append(ced)
                    filtro_usuario = ' OR '.join(where_parts)
                    if filtro_usuario:
                        params_p.extend([fin, inicio])
                        sql_p = (
                            "SELECT p.sgis_permiso_trabajo_fecha_emision AS emision, p.sgis_permiso_trabajo_fecha_finalizacion AS fin_sem "
                            "FROM sgis_permiso_trabajo p "
                            f"WHERE ({filtro_usuario}) AND p.sgis_permiso_trabajo_fecha_emision <= %s AND p.sgis_permiso_trabajo_fecha_finalizacion >= %s"
                        )
                        cursor.execute(sql_p, tuple(params_p))
                        rows_p = cursor.fetchall() or []
                        permiso_days = set()
                        for rp in rows_p:
                            e = rp.get('emision')
                            f = rp.get('fin_sem')
                            if isinstance(e, datetime):
                                e = e.date()
                            if isinstance(f, datetime):
                                f = f.date()
                            semana_tiene_hist = any((hd and e and f and e <= hd <= f) for hd in hist_all)
                            if semana_tiene_hist:
                                for d in dias_set:
                                    if d and e and f and e <= d <= f:
                                        permiso_days.add(d)
                except Exception:
                    pass
                permiso_set = permiso_days
                if 'AUXILIAR' in carpeta_u:
                    caidas_set = set()
                escaleras_permitido = ('CONDUCTOR' in cargo_u) or (cargo_u == 'TECNICO CONDUCTOR')
                if not escaleras_permitido:
                    escaleras_set = set()
                cnt_epp_all = len(epp_set)
                cnt_epp = min(cnt_epp_all, total_dias)
                cnt_caidas_all = len(caidas_set)
                cnt_caidas = min(cnt_caidas_all, total_dias)
                cnt_escaleras = len(dias_set.intersection(escaleras_set))
                cnt_tsr = len(dias_set.intersection(tsr_set))
                cnt_permiso = len(dias_set.intersection(permiso_set))
                for d in dias:
                    he = d in epp_set
                    hc = d in caidas_set
                    hs = d in escaleras_set
                    ht = d in tsr_set
                    hp = d in permiso_set
                    if he and hc and hs and ht and hp:
                        completos += 1
            pct = int(round((completos * 100.0) / total_dias)) if total_dias > 0 else 0
            pct_epp = int(round((cnt_epp * 100.0) / total_dias)) if total_dias > 0 else 0
            pct_caidas = int(round((cnt_caidas * 100.0) / total_dias)) if total_dias > 0 else 0
            pct_escaleras = int(round((cnt_escaleras * 100.0) / total_dias)) if total_dias > 0 else 0
            pct_tsr = int(round((cnt_tsr * 100.0) / total_dias)) if total_dias > 0 else 0
            pct_permiso = int(round((cnt_permiso * 100.0) / total_dias)) if total_dias > 0 else 0
            data.append({
                'cedula': ced,
                'nombre': nom,
                'porcentaje': pct,
                'asistencia_dias': total_dias,
                'completos': completos,
                'porcentaje_epp': pct_epp,
                'porcentaje_caidas': pct_caidas,
                'porcentaje_escaleras': pct_escaleras,
                'porcentaje_tsr': pct_tsr,
                'porcentaje_permiso': pct_permiso,
                'epp_dias': cnt_epp,
                'caidas_dias': cnt_caidas,
                'escaleras_dias': cnt_escaleras,
                'tsr_dias': cnt_tsr,
                'permiso_dias': cnt_permiso
            })
        return jsonify({'success': True, 'data': data, 'mes': inicio.strftime('%Y-%m')})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/indicadores/supervisores', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_indicadores_supervisores():
    try:
        mes = request.args.get('mes')
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        cursor.execute(
            """
            SELECT DISTINCT TRIM(a.super) AS supervisor
            FROM asistencia a
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN (""" + placeholders_allowed + """)
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN (""" + placeholders_exc + """)
              AND TRIM(a.super) IS NOT NULL AND TRIM(a.super) <> ''
              AND UPPER(TRIM(a.super)) <> 'CORTES CUERVO SANDRA CECILIA'
            ORDER BY supervisor
            """,
            (inicio, fin) + tuple(allowed_upper) + tuple(exc_upper)
        )
        sups = [r.get('supervisor') for r in (cursor.fetchall() or []) if r.get('supervisor')]
        sups = [s for s in sups if (s or '').strip().upper() != 'CORTES CUERVO SANDRA CECILIA']
        try:
            ur = (session.get('user_role') or '').strip().lower()
            if ur != 'administrativo':
                cursor.execute("SELECT nombre, cargo, super FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (session.get('user_cedula'),))
                ro_u = cursor.fetchone() or {}
                cargo_u = (ro_u.get('cargo') or '').strip().upper()
                nombre_u = (ro_u.get('nombre') or '').strip()
                super_u = (ro_u.get('super') or '').strip()
                mi_super = nombre_u if cargo_u == 'SUPERVISORES' else super_u
                if mi_super:
                    sups = [s for s in sups if (s or '').strip().upper() == mi_super.strip().upper()]
        except Exception:
            pass
        resultados = []
        for sup in sups:
            cursor.execute(
                f"""
                SELECT DISTINCT a.cedula
                FROM asistencia a
                WHERE TRIM(a.super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                  AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
                  AND (
                        EXISTS (
                            SELECT 1 FROM tipificacion_asistencia t
                            WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                              AND t.valor = '1'
                        )
                     OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
                  )
                  AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
                ORDER BY a.cedula
                """,
                (sup, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper)
            )
            tecnicos = [r.get('cedula') for r in (cursor.fetchall() or []) if r.get('cedula')]
            tot_dias = 0
            tot_epp = 0
            tot_caidas = 0
            tot_escaleras = 0
            tot_tsr = 0
            tot_permiso = 0
            tot_dias_escaleras = 0
            sum_pct_caidas = 0.0
            n_tecnicos_caidas = 0
            tot_completos = 0
            has_conductor = False
            for ced in tecnicos:
                idc = None
                try:
                    cursor.execute("SELECT id_codigo_consumidor, UPPER(TRIM(cargo)) AS cargo, UPPER(TRIM(carpeta)) AS carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (ced,))
                    ro = cursor.fetchone() or {}
                    idc = ro.get('id_codigo_consumidor')
                    cargo_u = (ro.get('cargo') or '').strip().upper()
                    carpeta_u = (ro.get('carpeta') or '').strip().upper()
                except Exception:
                    idc = None
                    cargo_u = ''
                    carpeta_u = ''
                dias = []
                try:
                    cursor.execute(
                        f"""
                        SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
                        FROM asistencia a
                        WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
                          AND (
                                EXISTS (
                                    SELECT 1 FROM tipificacion_asistencia t
                                    WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                                      AND t.valor = '1'
                                )
                             OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
                          )
                          AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
                        ORDER BY dia
                        """,
                        (ced, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper)
                    )
                    dias = [r.get('dia') for r in (cursor.fetchall() or []) if r.get('dia')]
                except Exception:
                    dias = []
                total_dias = len(dias)
                if total_dias == 0:
                    continue
                dias_set = set(dias)
                epp_set = set()
                caidas_set = set()
                esc_set = set()
                tsr_set = set()
                permiso_set = set()
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_personal
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_personal
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, inicio, fin)
                        )
                    for r in cursor.fetchall() or []:
                        di = r.get('dia')
                        if di:
                            epp_set.add(di)
                except Exception:
                    pass
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_caidas
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_proteccion_caidas
                            WHERE (
                                   (cedula = %s OR recurso_operativo_cedula = %s)
                                OR id_codigo_consumidor IN (
                                     SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                                   )
                              )
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, ced, inicio, fin)
                        )
                    for r in cursor.fetchall() or []:
                        di = r.get('dia')
                        if di:
                            caidas_set.add(di)
                except Exception:
                    pass
                if 'AUXILIAR' in carpeta_u:
                    caidas_set = set()
                try:
                    if idc:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_escaleras
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, idc, inicio, fin)
                        )
                    else:
                        cursor.execute(
                            """
                            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                            FROM sgis_pre_escaleras
                            WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                            """,
                            (ced, ced, inicio, fin)
                        )
                    for r in cursor.fetchall() or []:
                        di = r.get('dia')
                        if di:
                            esc_set.add(di)
                except Exception:
                    pass
                escaleras_permitido = ('CONDUCTOR' in cargo_u) or (cargo_u == 'TECNICO CONDUCTOR')
                if not escaleras_permitido:
                    esc_set = set()
                else:
                    has_conductor = True
                try:
                    cursor.execute(
                        """
                        SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha_registro)) AS dia
                        FROM sgis_trabajos_seguridad_rutina
                        WHERE (recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                          AND COALESCE(fecha_dia, DATE(fecha_registro)) BETWEEN %s AND %s
                        """,
                        (ced, idc or 0, inicio, fin)
                    )
                    for r in cursor.fetchall() or []:
                        di = r.get('dia')
                        if di:
                            tsr_set.add(di)
                except Exception:
                    pass
                try:
                    cursor.execute(
                        """
                        SELECT COLUMN_NAME
                        FROM INFORMATION_SCHEMA.COLUMNS
                        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                        """
                    )
                    table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
                    filtro_parts = []
                    filtro_params = []
                    if 'id_codigo_consumidor' in table_cols and idc:
                        filtro_parts.append('p.id_codigo_consumidor = %s')
                        filtro_params.append(idc)
                    if 'recurso_operativo_cedula' in table_cols:
                        filtro_parts.append('p.recurso_operativo_cedula = %s')
                        filtro_params.append(ced)
                    if 'cedula' in table_cols:
                        filtro_parts.append('p.cedula = %s')
                        filtro_params.append(ced)
                    filtro_usuario = ' OR '.join(filtro_parts)
                    if filtro_usuario:
                        hist_all = set()
                        sql_hc = (
                            "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) AS dia "
                            "FROM sgis_permiso_trabajo_historial_semanal_confinado h "
                            "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                            "WHERE DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s "
                            f"AND ({filtro_usuario})"
                        )
                        cursor.execute(sql_hc, (inicio, fin) + tuple(filtro_params))
                        for r in cursor.fetchall() or []:
                            di = r.get('dia')
                            if di:
                                hist_all.add(di)
                        sql_ha = (
                            "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_altura_fecha) AS dia "
                            "FROM sgis_permiso_trabajo_historial_semanal_altura h "
                            "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                            "WHERE DATE(h.sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s "
                            f"AND ({filtro_usuario})"
                        )
                        cursor.execute(sql_ha, (inicio, fin) + tuple(filtro_params))
                        for r in cursor.fetchall() or []:
                            di = r.get('dia')
                            if di:
                                hist_all.add(di)
                        sql_p = (
                            "SELECT p.sgis_permiso_trabajo_fecha_emision AS emision, p.sgis_permiso_trabajo_fecha_finalizacion AS fin_sem "
                            "FROM sgis_permiso_trabajo p "
                            f"WHERE ({filtro_usuario}) AND p.sgis_permiso_trabajo_fecha_emision <= %s AND p.sgis_permiso_trabajo_fecha_finalizacion >= %s"
                        )
                        cursor.execute(sql_p, tuple(filtro_params) + (fin, inicio))
                        rows_p = cursor.fetchall() or []
                        for rp in rows_p:
                            e = rp.get('emision')
                            f = rp.get('fin_sem')
                            if isinstance(e, datetime):
                                e = e.date()
                            if isinstance(f, datetime):
                                f = f.date()
                            semana_tiene_hist = any((hd and e and f and e <= hd <= f) for hd in hist_all)
                            if semana_tiene_hist:
                                for d in dias_set:
                                    if d and e and f and e <= d <= f:
                                        permiso_set.add(d)
                except Exception:
                    pass
                tot_dias += total_dias
                tot_epp += len(dias_set.intersection(epp_set))
                tot_caidas += len(dias_set.intersection(caidas_set))
                tot_escaleras += len(dias_set.intersection(esc_set))
                tot_tsr += len(dias_set.intersection(tsr_set))
                tot_permiso += len(dias_set.intersection(permiso_set))
                if ('CONDUCTOR' in cargo_u) or (cargo_u == 'TECNICO CONDUCTOR'):
                    tot_dias_escaleras += total_dias
                if total_dias > 0 and ('AUXILIAR' not in carpeta_u):
                    pct_c = min(len(caidas_set), total_dias) / float(total_dias)
                    sum_pct_caidas += pct_c
                    n_tecnicos_caidas += 1
                comp = 0
                for d in dias:
                    he = d in epp_set
                    hc = d in caidas_set
                    hs = d in esc_set
                    ht = d in tsr_set
                    hp = d in permiso_set
                    if he and hc and hs and ht and hp:
                        comp += 1
                tot_completos += comp
            if tot_dias == 0:
                continue
            metricas_aplicables = 5 if has_conductor else 4
            suma_metricas_dias = tot_epp + tot_caidas + (tot_escaleras if has_conductor else 0) + tot_tsr + tot_permiso
            pct_general = int(round((suma_metricas_dias * 100.0) / (tot_dias * metricas_aplicables)))
            pct_tsr = int(round((tot_tsr * 100.0) / (tot_dias if tot_dias > 0 else 1)))
            pct_permiso = int(round((tot_permiso * 100.0) / (tot_dias if tot_dias > 0 else 1)))
            pct_caidas = int(round(((sum_pct_caidas * 100.0) / (n_tecnicos_caidas if n_tecnicos_caidas > 0 else 1))))
            pct_epp = int(round((tot_epp * 100.0) / (tot_dias if tot_dias > 0 else 1)))
            pct_escaleras = int(round((tot_escaleras * 100.0) / (tot_dias_escaleras if tot_dias_escaleras > 0 else 1))) if has_conductor else None
            if has_conductor:
                promedio_metricas = int(round((pct_tsr + pct_permiso + pct_caidas + pct_epp + (pct_escaleras or 0)) / 5.0))
            else:
                promedio_metricas = int(round((pct_tsr + pct_permiso + pct_caidas + pct_epp) / 4.0))
            res = {
                'supervisor': sup,
                'mes': inicio.strftime('%Y-%m'),
                'total_dias': tot_dias,
                'porcentaje_general': pct_general,
                'porcentaje_tsr': pct_tsr,
                'porcentaje_permiso': pct_permiso,
                'porcentaje_caidas': pct_caidas,
                'porcentaje_epp': pct_epp,
                'porcentaje_escaleras': pct_escaleras,
                'porcentaje_promedio_metricas': promedio_metricas,
                'escaleras_aplica': has_conductor
            }
            resultados.append(res)
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'supervisores': resultados})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/indicadores/supervisores/debug', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_indicadores_supervisores_debug():
    try:
        mes = request.args.get('mes')
        supervisor = request.args.get('supervisor')
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        if not supervisor:
            ur = (session.get('user_role') or '').strip().lower()
            if ur != 'administrativo':
                cursor.execute("SELECT nombre, cargo, super FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (session.get('user_cedula'),))
                ro_u = cursor.fetchone() or {}
                cargo_u = (ro_u.get('cargo') or '').strip().upper()
                nombre_u = (ro_u.get('nombre') or '').strip()
                super_u = (ro_u.get('super') or '').strip()
                supervisor = nombre_u if cargo_u == 'SUPERVISORES' else super_u
        cursor.execute(
            f"""
            SELECT DISTINCT a.cedula
            FROM asistencia a
            WHERE TRIM(a.super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
              AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
            ORDER BY a.cedula
            """,
            (supervisor, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper)
        )
        tecnicos = [r.get('cedula') for r in (cursor.fetchall() or []) if r.get('cedula')]
        tot_dias = 0
        tot_epp = 0
        tot_caidas_inter = 0
        tot_escaleras_inter = 0
        tot_tsr = 0
        tot_permiso = 0
        tot_dias_escaleras = 0
        sum_pct_caidas = 0.0
        n_tecnicos_caidas = 0
        for ced in tecnicos:
            cursor.execute("SELECT id_codigo_consumidor, UPPER(TRIM(cargo)) AS cargo, UPPER(TRIM(carpeta)) AS carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (ced,))
            ro = cursor.fetchone() or {}
            idc = ro.get('id_codigo_consumidor')
            cargo_u = (ro.get('cargo') or '').strip().upper()
            carpeta_u = (ro.get('carpeta') or '').strip().upper()
            cursor.execute(
                f"""
                SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
                FROM asistencia a
                WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
                  AND (
                        EXISTS (
                            SELECT 1 FROM tipificacion_asistencia t
                            WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                              AND t.valor = '1'
                        )
                     OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
                  )
                  AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
                ORDER BY dia
                """,
                (ced, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper)
            )
            dias = [r.get('dia') for r in (cursor.fetchall() or []) if r.get('dia')]
            total_dias = len(dias)
            if total_dias == 0:
                continue
            dias_set = set(dias)
            epp_set = set()
            caidas_set = set()
            esc_set = set()
            tsr_set = set()
            permiso_set = set()
            if idc:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_proteccion_personal
                    WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, idc, inicio, fin)
                )
            else:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_proteccion_personal
                    WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, inicio, fin)
                )
            for r in cursor.fetchall() or []:
                di = r.get('dia')
                if di:
                    epp_set.add(di)
            if idc:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_proteccion_caidas
                    WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, idc, inicio, fin)
                )
            else:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_proteccion_caidas
                    WHERE (
                           (cedula = %s OR recurso_operativo_cedula = %s)
                        OR id_codigo_consumidor IN (
                             SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                           )
                      )
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, ced, inicio, fin)
                )
            for r in cursor.fetchall() or []:
                di = r.get('dia')
                if di:
                    caidas_set.add(di)
            if 'AUXILIAR' in carpeta_u:
                caidas_set = set()
            if idc:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_escaleras
                    WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, idc, inicio, fin)
                )
            else:
                cursor.execute(
                    """
                    SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
                    FROM sgis_pre_escaleras
                    WHERE (cedula = %s OR recurso_operativo_cedula = %s)
                      AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
                    """,
                    (ced, ced, inicio, fin)
                )
            for r in cursor.fetchall() or []:
                di = r.get('dia')
                if di:
                    esc_set.add(di)
            cursor.execute(
                """
                SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha_registro)) AS dia
                FROM sgis_trabajos_seguridad_rutina
                WHERE (recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
                  AND COALESCE(fecha_dia, DATE(fecha_registro)) BETWEEN %s AND %s
                """,
                (ced, idc or 0, inicio, fin)
            )
            for r in cursor.fetchall() or []:
                di = r.get('dia')
                if di:
                    tsr_set.add(di)
            tot_dias += total_dias
            tot_epp += len(dias_set.intersection(epp_set))
            tot_caidas_inter += len(dias_set.intersection(caidas_set))
            tot_escaleras_inter += len(dias_set.intersection(esc_set))
            tot_tsr += len(dias_set.intersection(tsr_set))
            if ('CONDUCTOR' in cargo_u) or (cargo_u == 'TECNICO CONDUCTOR'):
                tot_dias_escaleras += total_dias
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            filtro_parts = []
            filtro_params = []
            if 'id_codigo_consumidor' in table_cols and idc:
                filtro_parts.append('p.id_codigo_consumidor = %s')
                filtro_params.append(idc)
            if 'recurso_operativo_cedula' in table_cols:
                filtro_parts.append('p.recurso_operativo_cedula = %s')
                filtro_params.append(ced)
            if 'cedula' in table_cols:
                filtro_parts.append('p.cedula = %s')
                filtro_params.append(ced)
            filtro_usuario = ' OR '.join(filtro_parts)
            if filtro_usuario:
                hist_all = set()
                sql_hc = (
                    "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) AS dia "
                    "FROM sgis_permiso_trabajo_historial_semanal_confinado h "
                    "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                    "WHERE DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s "
                    f"AND ({filtro_usuario})"
                )
                cursor.execute(sql_hc, (inicio, fin) + tuple(filtro_params))
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        hist_all.add(di)
                sql_ha = (
                    "SELECT DISTINCT DATE(h.sgis_permiso_trabajo_historial_altura_fecha) AS dia "
                    "FROM sgis_permiso_trabajo_historial_semanal_altura h "
                    "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                    "WHERE DATE(h.sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s "
                    f"AND ({filtro_usuario})"
                )
                cursor.execute(sql_ha, (inicio, fin) + tuple(filtro_params))
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        hist_all.add(di)
                for d in dias_set:
                    if d in hist_all:
                        tot_permiso += 1
            if total_dias > 0 and ('AUXILIAR' not in carpeta_u):
                pct_c = min(len(caidas_set), total_dias) / float(total_dias)
                sum_pct_caidas += pct_c
                n_tecnicos_caidas += 1
        pct_general = int(round(((tot_epp + tot_caidas_inter + tot_escaleras_inter + tot_tsr + tot_permiso) * 100.0) / (tot_dias * 5 if tot_dias > 0 else 1)))
        pct_escaleras = int(round((tot_escaleras_inter * 100.0) / (tot_dias_escaleras if tot_dias_escaleras > 0 else 1)))
        pct_epp = int(round((tot_epp * 100.0) / (tot_dias if tot_dias > 0 else 1)))
        pct_tsr = int(round((tot_tsr * 100.0) / (tot_dias if tot_dias > 0 else 1)))
        pct_permiso = int(round((tot_permiso * 100.0) / (tot_dias if tot_dias > 0 else 1)))
        pct_caidas_avg = int(round(((sum_pct_caidas * 100.0) / (n_tecnicos_caidas if n_tecnicos_caidas > 0 else 1))))
        promedio_metricas = int(round((pct_epp + pct_caidas_avg + pct_escaleras + pct_tsr + pct_permiso) / 5.0))
        return jsonify({
            'success': True,
            'mes': inicio.strftime('%Y-%m'),
            'supervisor': supervisor,
            'totales': {
                'tot_dias': tot_dias,
                'tot_epp': tot_epp,
                'tot_caidas_inter': tot_caidas_inter,
                'tot_escaleras_inter': tot_escaleras_inter,
                'tot_dias_escaleras': tot_dias_escaleras,
                'tot_tsr': tot_tsr,
                'tot_permiso': tot_permiso
            },
            'porcentajes': {
                'general_badge': pct_general,
                'epp': pct_epp,
                'caidas_avg_tecnico': pct_caidas_avg,
                'escaleras': pct_escaleras,
                'tsr': pct_tsr,
                'permiso': pct_permiso,
                'promedio_metricas': promedio_metricas
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/preop-detalle', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_preop_detalle():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor.execute(
            """
            SELECT fecha_dia, casco_estado_general, casco_uso_inf_2_anos, casco_estado_tafilete, casco_puntos_anclaje,
                   barbuquejo_estado_puntos_apoyo, barbuquejo_estado_sujetador_menton, barbuquejo_estado_costuras_correas,
                   guantes_estado_costuras, guantes_estado_palma, guantes_estado_general,
                   monogafas_estado_lentes, monogafas_estado_patillas, monogafas_estado_puente_nariz
            FROM sgis_pre_proteccion_personal
            WHERE cedula = %s AND fecha_dia BETWEEN %s AND %s
            ORDER BY fecha_dia
            """,
            (cedula, inicio, fin)
        )
        rows = cursor.fetchall()
        dia_estado = {}
        for row in rows:
            estados = [
                row.get('casco_estado_general'),
                row.get('casco_uso_inf_2_anos'),
                row.get('casco_estado_tafilete'),
                row.get('casco_puntos_anclaje'),
                row.get('barbuquejo_estado_puntos_apoyo'),
                row.get('barbuquejo_estado_sujetador_menton'),
                row.get('barbuquejo_estado_costuras_correas'),
                row.get('guantes_estado_costuras'),
                row.get('guantes_estado_palma'),
                row.get('guantes_estado_general'),
                row.get('monogafas_estado_lentes'),
                row.get('monogafas_estado_patillas'),
                row.get('monogafas_estado_puente_nariz')
            ]
            e = 'C'
            if any(s == 'NC' for s in estados if s):
                e = 'NC'
            elif all(s == 'N/A' for s in estados if s):
                e = 'N/A'
            fecha = row['fecha_dia']
            d = fecha.day
            dia_estado[d] = e
        dias = []
        ultimo_dia = fin.day
        for d in range(1, 32):
            if d <= ultimo_dia:
                dias.append(dia_estado.get(d, ''))
            else:
                dias.append('')
        return jsonify({'success': True, 'cedula': cedula, 'mes': inicio.strftime('%Y-%m'), 'dias': dias})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes/debug-dias', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_tecnicos_mes_debug_dias():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        r = cursor.fetchone() or {}
        idc = r.get('id_codigo_consumidor')
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        sql_asist = f"""
            SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
            FROM asistencia a
            WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
            ORDER BY dia
            """
        cursor.execute(sql_asist, (cedula, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper))
        dias_asistencia = [row.get('dia') for row in (cursor.fetchall() or []) if row.get('dia')]
        dias_set = set(dias_asistencia)
        epp_set = set()
        cursor.execute(
            """
            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
            FROM sgis_pre_proteccion_personal
            WHERE (cedula = %s OR recurso_operativo_cedula = %s OR id_codigo_consumidor = %s)
              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
            ORDER BY dia
            """,
            (cedula, cedula, idc, inicio, fin)
        )
        for r in cursor.fetchall() or []:
            di = r.get('dia')
            if di:
                epp_set.add(di)
        inter = sorted(list(dias_set.intersection(epp_set)))
        miss_epp = sorted(list(dias_set.difference(epp_set)))
        extra_epp = sorted(list(epp_set.difference(dias_set)))
        fmt = lambda arr: [d.strftime('%Y-%m-%d') for d in arr]
        return jsonify({'success': True, 'cedula': cedula, 'mes': inicio.strftime('%Y-%m'), 'dias_asistencia': fmt(dias_asistencia), 'dias_epp': fmt(list(epp_set)), 'interseccion': fmt(inter), 'asistencia_sin_epp': fmt(miss_epp), 'epp_fuera_asistencia': fmt(extra_epp)})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes/debug-caidas', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_tecnicos_mes_debug_caidas():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        # Días de asistencia
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        sql_asist = f"""
            SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
            FROM asistencia a
            WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
            ORDER BY dia
            """
        cursor.execute(sql_asist, (cedula, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper))
        dias_asistencia = [row.get('dia') for row in (cursor.fetchall() or []) if row.get('dia')]
        dias_set = set(dias_asistencia)
        # Días de caídas con fallback por id_codigo_consumidor derivado de la cédula
        cursor.execute(
            """
            SELECT DISTINCT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS dia
            FROM sgis_pre_proteccion_caidas
            WHERE (
                   (cedula = %s OR recurso_operativo_cedula = %s)
                OR id_codigo_consumidor IN (
                     SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                   )
              )
              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
            ORDER BY dia
            """,
            (cedula, cedula, cedula, inicio, fin)
        )
        caidas_set = set([row.get('dia') for row in (cursor.fetchall() or []) if row.get('dia')])
        inter = sorted(list(dias_set.intersection(caidas_set)))
        miss = sorted(list(dias_set.difference(caidas_set)))
        extra = sorted(list(caidas_set.difference(dias_set)))
        fmt = lambda arr: [d.strftime('%Y-%m-%d') for d in arr]
        return jsonify({'success': True, 'cedula': cedula, 'mes': inicio.strftime('%Y-%m'), 'dias_asistencia': fmt(dias_asistencia), 'dias_caidas': fmt(list(caidas_set)), 'interseccion': fmt(inter), 'asistencia_sin_caidas': fmt(miss), 'caidas_fuera_asistencia': fmt(extra)})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes/debug-permiso', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_tecnicos_mes_debug_permiso():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        excluded_carpeta = ['0','I.ARL','D/F','LM','LL','SUS','PER','VAC','DFAM','RM','RN','I.MED']
        exc_upper = [str(s or '').upper().strip() for s in excluded_carpeta]
        placeholders_exc = ','.join(['%s'] * len(exc_upper))
        sql_asist = f"""
            SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
            FROM asistencia a
            WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
              AND UPPER(TRIM(COALESCE(a.carpeta_dia,''))) NOT IN ({placeholders_exc})
            ORDER BY dia
            """
        cursor.execute(sql_asist, (cedula, inicio, fin) + tuple(allowed_upper) + tuple(exc_upper))
        dias_asistencia = [row.get('dia') for row in (cursor.fetchall() or []) if row.get('dia')]
        dias_set = set(dias_asistencia)
        try:
            cursor.execute(
                """
                SELECT id_sgis_permiso_trabajo
                FROM sgis_permiso_trabajo
                WHERE (recurso_operativo_cedula = %s OR cedula = %s)
                """,
                (cedula, cedula)
            )
            permiso_ids = [r.get('id_sgis_permiso_trabajo') for r in (cursor.fetchall() or []) if r.get('id_sgis_permiso_trabajo')]
        except Exception:
            permiso_ids = []
        permiso_set = set()
        if permiso_ids:
            placeholders = ','.join(['%s'] * len(permiso_ids))
            try:
                sql_c = f"""
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_confinado_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_confinado
                    WHERE id_sgis_permiso_trabajo IN ({placeholders})
                      AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                """
                params_c = tuple(permiso_ids) + (inicio, fin)
                cursor.execute(sql_c, params_c)
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
            except Exception:
                pass
            try:
                sql_a = f"""
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_altura_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_altura
                    WHERE id_sgis_permiso_trabajo IN ({placeholders})
                      AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                """
                params_a = tuple(permiso_ids) + (inicio, fin)
                cursor.execute(sql_a, params_a)
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
            except Exception:
                pass
        try:
            cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ro = cursor.fetchone() or {}
            idc = ro.get('id_codigo_consumidor')
            if idc:
                cursor.execute(
                    """
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_confinado_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_confinado
                    WHERE id_codigo_consumidor = %s
                      AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                    """,
                    (idc, inicio, fin)
                )
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
                cursor.execute(
                    """
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_altura_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_altura
                    WHERE id_codigo_consumidor = %s
                      AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                    """,
                    (idc, inicio, fin)
                )
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
            else:
                cursor.execute(
                    """
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_confinado_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_confinado
                    WHERE id_codigo_consumidor IN (
                            SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                          )
                      AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                    """,
                    (cedula, inicio, fin)
                )
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
                cursor.execute(
                    """
                    SELECT DISTINCT DATE(sgis_permiso_trabajo_historial_altura_fecha) AS dia
                    FROM sgis_permiso_trabajo_historial_semanal_altura
                    WHERE id_codigo_consumidor IN (
                            SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                          )
                      AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                    """,
                    (cedula, inicio, fin)
                )
                for r in cursor.fetchall() or []:
                    di = r.get('dia')
                    if di:
                        permiso_set.add(di)
        except Exception:
            pass
        permiso_rango = set()
        try:
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            filtro_parts = []
            params_p = []
            cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ro = cursor.fetchone() or {}
            idc = ro.get('id_codigo_consumidor')
            if 'id_codigo_consumidor' in table_cols and idc:
                filtro_parts.append('p.id_codigo_consumidor = %s')
                params_p.append(idc)
            if 'recurso_operativo_cedula' in table_cols:
                filtro_parts.append('p.recurso_operativo_cedula = %s')
                params_p.append(cedula)
            if 'cedula' in table_cols:
                filtro_parts.append('p.cedula = %s')
                params_p.append(cedula)
            filtro_usuario = ' OR '.join(filtro_parts)
            if filtro_usuario:
                params_p.extend([fin, inicio])
                sql_p = (
                    "SELECT p.sgis_permiso_trabajo_fecha_emision AS emision, p.sgis_permiso_trabajo_fecha_finalizacion AS fin_sem "
                    "FROM sgis_permiso_trabajo p "
                    f"WHERE ({filtro_usuario}) AND p.sgis_permiso_trabajo_fecha_emision <= %s AND p.sgis_permiso_trabajo_fecha_finalizacion >= %s"
                )
                cursor.execute(sql_p, tuple(params_p))
                rows_p = cursor.fetchall() or []
                for rp in rows_p:
                    e = rp.get('emision')
                    f = rp.get('fin_sem')
                    if isinstance(e, datetime):
                        e = e.date()
                    if isinstance(f, datetime):
                        f = f.date()
                    for d in dias_set:
                        if d and e and f and e <= d <= f:
                            permiso_rango.add(d)
        except Exception:
            pass
        permiso_total = set(permiso_set).union(permiso_rango)
        contables = set()
        try:
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            table_cols = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            filtro_parts = []
            params_p = []
            cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
            ro2 = cursor.fetchone() or {}
            idc2 = ro2.get('id_codigo_consumidor')
            if 'id_codigo_consumidor' in table_cols and idc2:
                filtro_parts.append('p.id_codigo_consumidor = %s')
                params_p.append(idc2)
            if 'recurso_operativo_cedula' in table_cols:
                filtro_parts.append('p.recurso_operativo_cedula = %s')
                params_p.append(cedula)
            if 'cedula' in table_cols:
                filtro_parts.append('p.cedula = %s')
                params_p.append(cedula)
            filtro_usuario = ' OR '.join(filtro_parts)
            rows_px = []
            if filtro_usuario:
                params_p.extend([fin, inicio])
                sql_px = (
                    "SELECT p.sgis_permiso_trabajo_fecha_emision AS emision, p.sgis_permiso_trabajo_fecha_finalizacion AS fin_sem "
                    "FROM sgis_permiso_trabajo p "
                    f"WHERE ({filtro_usuario}) AND p.sgis_permiso_trabajo_fecha_emision <= %s AND p.sgis_permiso_trabajo_fecha_finalizacion >= %s"
                )
                cursor.execute(sql_px, tuple(params_p))
                rows_px = cursor.fetchall() or []
            for rp in rows_px:
                e = rp.get('emision'); f = rp.get('fin_sem')
                if isinstance(e, datetime): e = e.date()
                if isinstance(f, datetime): f = f.date()
                semana_tiene_hist = any((hd and e and f and e <= hd <= f) for hd in permiso_set)
                if semana_tiene_hist:
                    for d in dias_set:
                        if d and e and f and e <= d <= f:
                            contables.add(d)
        except Exception:
            pass
        inter = sorted(list(dias_set.intersection(permiso_total)))
        miss = sorted(list(dias_set.difference(permiso_total)))
        extra = sorted(list(permiso_total.difference(dias_set)))
        fmt = lambda arr: [d.strftime('%Y-%m-%d') for d in arr]
        return jsonify({
            'success': True,
            'cedula': cedula,
            'mes': inicio.strftime('%Y-%m'),
            'dias_asistencia': fmt(dias_asistencia),
            'dias_permiso': fmt(list(permiso_set)),
            'dias_permiso_rango': fmt(list(permiso_rango)),
            'dias_permiso_contables': fmt(list(contables)),
            'dias_permiso_total': fmt(list(permiso_total)),
            'interseccion': fmt(inter),
            'asistencia_sin_permiso': fmt(miss),
            'permiso_fuera_asistencia': fmt(extra)
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes/debug-permiso-rows', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_tecnicos_mes_debug_permiso_rows():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        r = cursor.fetchone() or {}
        idc = r.get('id_codigo_consumidor')
        allowed_carpeta = [
            'ABACK','APOCAMIONETA','ARGHFC','AUX','AUXCAM','AUXMOTO',
            'BACK ARGHFC','BACK AUX','BACK BROW','BACK FTTHI','BACK HFCI','BACK MTFTTH',
            'BROW','DX','FTTHI','FTTHPOST','HFCI','MTFTTH','POST'
        ]
        allowed_upper = [str(s or '').upper().strip() for s in allowed_carpeta]
        placeholders_allowed = ','.join(['%s'] * len(allowed_upper))
        sql_asist = f"""
            SELECT DISTINCT DATE(a.fecha_asistencia) AS dia
            FROM asistencia a
            WHERE a.cedula = %s AND DATE(a.fecha_asistencia) BETWEEN %s AND %s
              AND (
                    EXISTS (
                        SELECT 1 FROM tipificacion_asistencia t
                        WHERE TRIM(UPPER(t.codigo_tipificacion)) = TRIM(UPPER(COALESCE(a.carpeta_dia,'')))
                          AND t.valor = '1'
                    )
                 OR UPPER(TRIM(COALESCE(a.carpeta_dia,''))) IN ({placeholders_allowed})
              )
            ORDER BY dia
            """
        cursor.execute(sql_asist, (cedula, inicio, fin) + tuple(allowed_upper))
        dias_asistencia = [row.get('dia') for row in (cursor.fetchall() or []) if row.get('dia')]
        confinado_rows = []
        altura_rows = []
        try:
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo_historial_semanal_confinado'
                """
            )
            cols_conf = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo_historial_semanal_altura'
                """
            )
            cols_alt = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            cursor.execute(
                """
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'sgis_permiso_trabajo'
                """
            )
            cols_perm = {r['COLUMN_NAME'] if isinstance(r, dict) else r[0] for r in cursor.fetchall() or []}
            filtro_parts = []
            filtro_params = []
            if 'id_codigo_consumidor' in cols_perm and idc:
                filtro_parts.append('p.id_codigo_consumidor = %s')
                filtro_params.append(idc)
            if 'recurso_operativo_cedula' in cols_perm:
                filtro_parts.append('p.recurso_operativo_cedula = %s')
                filtro_params.append(cedula)
            if 'cedula' in cols_perm:
                filtro_parts.append('p.cedula = %s')
                filtro_params.append(cedula)
            filtro_usuario = ' OR '.join(filtro_parts)
            if 'id_codigo_consumidor' in cols_conf and idc:
                cursor.execute(
                    """
                    SELECT DATE(sgis_permiso_trabajo_historial_confinado_fecha) AS dia,
                           id_sgis_permiso_trabajo_historial_semanal_confinado AS id,
                           id_sgis_permiso_trabajo AS permiso_id
                    FROM sgis_permiso_trabajo_historial_semanal_confinado
                    WHERE id_codigo_consumidor = %s AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                    ORDER BY dia
                    """,
                    (idc, inicio, fin)
                )
                confinado_rows = cursor.fetchall() or []
            elif filtro_usuario:
                sql_conf_join = (
                    "SELECT DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) AS dia, "
                    "       h.id_sgis_permiso_trabajo_historial_semanal_confinado AS id, "
                    "       h.id_sgis_permiso_trabajo AS permiso_id "
                    "FROM sgis_permiso_trabajo_historial_semanal_confinado h "
                    "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                    "WHERE DATE(h.sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s "
                    f"  AND ({filtro_usuario}) ORDER BY dia"
                )
                cursor.execute(sql_conf_join, (inicio, fin) + tuple(filtro_params))
                confinado_rows = cursor.fetchall() or []
            if 'id_codigo_consumidor' in cols_alt and idc:
                cursor.execute(
                    """
                    SELECT DATE(sgis_permiso_trabajo_historial_altura_fecha) AS dia,
                           id_sgis_permiso_trabajo AS permiso_id
                    FROM sgis_permiso_trabajo_historial_semanal_altura
                    WHERE id_codigo_consumidor = %s AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                    ORDER BY dia
                    """,
                    (idc, inicio, fin)
                )
                altura_rows = cursor.fetchall() or []
            elif filtro_usuario:
                sql_alt_join = (
                    "SELECT DATE(h.sgis_permiso_trabajo_historial_altura_fecha) AS dia, "
                    "       h.id_sgis_permiso_trabajo AS permiso_id "
                    "FROM sgis_permiso_trabajo_historial_semanal_altura h "
                    "JOIN sgis_permiso_trabajo p ON p.id_sgis_permiso_trabajo = h.id_sgis_permiso_trabajo "
                    "WHERE DATE(h.sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s "
                    f"  AND ({filtro_usuario}) ORDER BY dia"
                )
                cursor.execute(sql_alt_join, (inicio, fin) + tuple(filtro_params))
                altura_rows = cursor.fetchall() or []
        except Exception:
            confinado_rows = confinado_rows or []
            altura_rows = altura_rows or []
        fmt = lambda arr: [d.strftime('%Y-%m-%d') for d in arr]
        dias_asistencia_fmt = fmt(dias_asistencia)
        dias_confinado = fmt([r.get('dia') for r in confinado_rows if r.get('dia')])
        dias_altura = fmt([r.get('dia') for r in altura_rows if r.get('dia')])
        return jsonify({
            'success': True,
            'cedula': cedula,
            'id_codigo_consumidor': idc,
            'mes': inicio.strftime('%Y-%m'),
            'dias_asistencia': dias_asistencia_fmt,
            'confinado': {
                'count': len(dias_confinado),
                'dias': dias_confinado,
                'rows': confinado_rows
            },
            'altura': {
                'count': len(dias_altura),
                'dias': dias_altura,
                'rows': altura_rows
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tecnicos-mes/debug-supervisor', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_reportes_tecnicos_mes_debug_supervisor():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT nombre, super FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        ro = cursor.fetchone() or {}
        sup_ro = (ro.get('super') or '').strip()
        cursor.execute(
            """
            SELECT TRIM(super) AS super
            FROM asistencia
            WHERE cedula = %s AND DATE(fecha_asistencia) BETWEEN %s AND %s
            ORDER BY fecha_asistencia DESC
            LIMIT 1
            """,
            (cedula, inicio, fin)
        )
        a = cursor.fetchone() or {}
        sup_asist = (a.get('super') or '').strip()
        ok = bool(sup_ro) and (sup_ro.upper() == sup_asist.upper())
        return jsonify({'success': True, 'cedula': cedula, 'mes': inicio.strftime('%Y-%m'), 'supervisor_recurso_operativo': sup_ro, 'supervisor_asistencia_mes': sup_asist, 'coincide': ok})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/preop-matriz', methods=['GET'])
@login_required_api()
def api_sgis_reportes_preop_matriz():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() != 'administrativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute("SELECT super FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
                ro = cursor.fetchone() or {}
                import unicodedata
                def _norm(s):
                    return ''.join(c for c in unicodedata.normalize('NFD', s or '') if unicodedata.category(c) != 'Mn').lower().strip()
                if _norm(str(ro.get('super') or '')) == _norm(sup_name):
                    supervised = True
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute("""
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                    """, (cedula, sup_name, inicio, fin))
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c
                        FROM recurso_operativo
                        WHERE recurso_operativo_cedula = %s
                          AND estado = 'Activo'
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                        """,
                        (cedula, sup_name)
                    )
                    c2 = cursor.fetchone() or {}
                    supervised = int(c2.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor.execute(
            """
            SELECT fecha_dia,
                   casco_estado_general, casco_uso_inf_2_anos, casco_estado_tafilete, casco_puntos_anclaje,
                   barbuquejo_estado_puntos_apoyo, barbuquejo_estado_sujetador_menton, barbuquejo_estado_costuras_correas,
                   guantes_estado_costuras, guantes_estado_palma, guantes_estado_general,
                   monogafas_estado_lentes, monogafas_estado_patillas, monogafas_estado_puente_nariz,
                   observacion,
                   firma_base64,
                   firma
            FROM sgis_pre_proteccion_personal
            WHERE cedula = %s AND fecha_dia BETWEEN %s AND %s
            ORDER BY fecha_dia
            """,
            (cedula, inicio, fin)
        )
        rows = cursor.fetchall()
        ultimo_dia = fin.day
        def arr():
            return ['' for _ in range(31)]
        matriz = {
            'casco': {
                'estado_general': arr(),
                'uso_inferior_2_anios': arr(),
                'estado_talifete': arr(),
                'puntos_anclaje_barbuquejo': arr()
            },
            'barbuquejo': {
                'puntos_apoyo': arr(),
                'sujetador_menton': arr(),
                'costuras_correas': arr()
            },
            'guantes': {
                'costuras': arr(),
                'refuerzo_palma': arr(),
                'estado_general': arr()
            },
            'monogafas': {
                'lentes_sin_rayones': arr(),
                'patillas': arr(),
                'puente_nariz': arr()
            }
        }
        observaciones = arr()
        firmas = arr()
        for row in rows:
            d = row['fecha_dia'].day
            idx = d - 1
            if 0 <= idx < 31:
                matriz['casco']['estado_general'][idx] = row.get('casco_estado_general') or ''
                matriz['casco']['uso_inferior_2_anios'][idx] = row.get('casco_uso_inf_2_anos') or ''
                matriz['casco']['estado_talifete'][idx] = row.get('casco_estado_tafilete') or ''
                matriz['casco']['puntos_anclaje_barbuquejo'][idx] = row.get('casco_puntos_anclaje') or ''
                matriz['barbuquejo']['puntos_apoyo'][idx] = row.get('barbuquejo_estado_puntos_apoyo') or ''
                matriz['barbuquejo']['sujetador_menton'][idx] = row.get('barbuquejo_estado_sujetador_menton') or ''
                matriz['barbuquejo']['costuras_correas'][idx] = row.get('barbuquejo_estado_costuras_correas') or ''
                matriz['guantes']['costuras'][idx] = row.get('guantes_estado_costuras') or ''
                matriz['guantes']['refuerzo_palma'][idx] = row.get('guantes_estado_palma') or ''
                matriz['guantes']['estado_general'][idx] = row.get('guantes_estado_general') or ''
                matriz['monogafas']['lentes_sin_rayones'][idx] = row.get('monogafas_estado_lentes') or ''
                matriz['monogafas']['patillas'][idx] = row.get('monogafas_estado_patillas') or ''
                matriz['monogafas']['puente_nariz'][idx] = row.get('monogafas_estado_puente_nariz') or ''
                observaciones[idx] = (row.get('observacion') or '').strip()
                firmas[idx] = (row.get('firma_base64') or row.get('firma') or '')
        cursor.execute("SELECT nombre, cargo, carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        u = cursor.fetchone() or {}
        info = {
            'nombre': u.get('nombre') or '',
            'cedula': cedula,
            'cargo': u.get('cargo') or '',
            'area': u.get('carpeta') or ''
        }
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'ultimo_dia': ultimo_dia, 'info': info, 'matriz': matriz, 'observaciones': observaciones, 'firmas': firmas})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/tsr-matriz', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_reportes_tsr_matriz():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() == 'operativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) AS c 
                    FROM recurso_operativo 
                    WHERE recurso_operativo_cedula = %s 
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    """,
                    (cedula, sup_name)
                )
                ro_c = cursor.fetchone() or {}
                supervised = int(ro_c.get('c') or 0) > 0
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                        """,
                        (cedula, sup_name, inicio, fin)
                    )
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_trabajos_seguridad_rutina (
                id_sgis_trabajo_seguridad_rutina INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                cargo VARCHAR(128) NULL,
                ciudad VARCHAR(128) NULL,
                placa VARCHAR(32) NULL,
                actividad_asociada VARCHAR(64) NULL,
                descripcion_tareas TEXT,
                observaciones TEXT,
                respuesta_1 VARCHAR(4),
                respuesta_2 VARCHAR(4),
                respuesta_3 VARCHAR(4),
                respuesta_4 VARCHAR(4),
                respuesta_5 VARCHAR(4),
                respuesta_6 VARCHAR(4),
                respuesta_7 VARCHAR(4),
                respuesta_8 VARCHAR(4),
                respuesta_9 VARCHAR(4),
                respuesta_10 VARCHAR(4),
                respuesta_11 VARCHAR(4),
                respuesta_12 VARCHAR(4),
                respuesta_13 VARCHAR(4),
                respuesta_14 VARCHAR(4),
                respuesta_15 VARCHAR(4),
                respuesta_16 VARCHAR(4),
                respuesta_17 VARCHAR(4),
                riesgo VARCHAR(128) NULL,
                peligro VARCHAR(128) NULL,
                consecuencia TEXT,
                control_propuesto TEXT,
                firma_trabajador LONGTEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor.execute(
            """
            SELECT fecha_dia, fecha_registro,
                   respuesta_1, respuesta_2, respuesta_3, respuesta_4, respuesta_5, respuesta_6, respuesta_7,
                   respuesta_8, respuesta_9, respuesta_10, respuesta_11, respuesta_12, respuesta_13, respuesta_14,
                   respuesta_15, respuesta_16, respuesta_17,
                   riesgo, peligro, consecuencia, control_propuesto,
                   observaciones, firma_trabajador, firma_supervisor
            FROM sgis_trabajos_seguridad_rutina
            WHERE recurso_operativo_cedula = %s AND fecha_dia BETWEEN %s AND %s
            ORDER BY fecha_dia DESC, fecha_registro DESC
            """,
            (cedula, inicio, fin)
        )
        rows = cursor.fetchall()
        ultimo_dia = fin.day
        def arr():
            return ['' for _ in range(31)]
        def arr_visitas():
            return [[] for _ in range(31)]
        evals = { 'res1': arr_visitas(), 'res2': arr_visitas(), 'res3': arr_visitas(), 'res4': arr_visitas(), 'res5': arr_visitas(), 'res6': arr_visitas(), 'res7': arr_visitas(), 'res8': arr_visitas(), 'res9': arr_visitas(), 'res10': arr_visitas(), 'res11': arr_visitas(), 'res12': arr_visitas(), 'res13': arr_visitas(), 'res14': arr_visitas(), 'res15': arr_visitas(), 'res16': arr_visitas(), 'res17': arr_visitas() }
        riesgos = { 'riesgo': arr(), 'peligro': arr(), 'consecuencia': arr(), 'control': arr() }
        observaciones = arr()
        firmas = arr()
        firmas_supervisor = arr()
        pendientes_supervisor = arr()
        visitas_programadas = ['0' for _ in range(31)]
        by_day = {}
        for row in rows:
            d = row['fecha_dia'].day
            by_day.setdefault(d, []).append(row)
        for d, day_rows in by_day.items():
            idx = d - 1
            if 0 <= idx < 31:
                res_list = ['respuesta_1','respuesta_2','respuesta_3','respuesta_4','respuesta_5','respuesta_6','respuesta_7','respuesta_8','respuesta_9','respuesta_10','respuesta_11','respuesta_12','respuesta_13','respuesta_14','respuesta_15','respuesta_16','respuesta_17']
                for i, key in enumerate(['res1','res2','res3','res4','res5','res6','res7','res8','res9','res10','res11','res12','res13','res14','res15','res16','res17']):
                    vals = []
                    for r in day_rows:
                        v = r.get(res_list[i]) or ''
                        vals.append(v)
                        if len(vals) >= 7:
                            break
                    evals[key][idx] = vals
                top = day_rows[0]
                riesgos['riesgo'][idx] = (top.get('riesgo') or '').strip()
                riesgos['peligro'][idx] = (top.get('peligro') or '').strip()
                riesgos['consecuencia'][idx] = (top.get('consecuencia') or '').strip()
                riesgos['control'][idx] = (top.get('control_propuesto') or '').strip()
                obs_vals = []
                for r in day_rows:
                    t = (r.get('observaciones') or '').strip()
                    if t:
                        obs_vals.append(t)
                observaciones[idx] = ' | '.join(obs_vals)
                firmas[idx] = top.get('firma_trabajador') or ''
                firmas_supervisor[idx] = top.get('firma_supervisor') or ''
                pend = 0
                for r in day_rows:
                    ft = (r.get('firma_trabajador') or '').strip()
                    fs = (r.get('firma_supervisor') or '').strip()
                    if ft and not fs:
                        pend += 1
                pendientes_supervisor[idx] = str(pend)
        cursor.execute("SELECT nombre, cargo, carpeta, id_codigo_consumidor, super, cliente, ciudad FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        u = cursor.fetchone() or {}
        info = { 'nombre': u.get('nombre') or '', 'cedula': cedula, 'cargo': u.get('cargo') or '', 'area': u.get('carpeta') or '', 'id': u.get('id_codigo_consumidor'), 'super': u.get('super') or '', 'cliente': u.get('cliente') or '', 'ciudad': u.get('ciudad') or '' }
        try:
            dbn = connection.database
            c2 = connection.cursor()
            c2.execute(
                """
                SELECT COLUMN_NAME 
                FROM information_schema.columns 
                WHERE table_schema=%s AND table_name='operaciones_actividades_diarias'
                ORDER BY ORDINAL_POSITION
                """,
                (dbn,)
            )
            cols = [r[0] for r in c2.fetchall()]
            lc = {c.lower(): c for c in cols}
            def pick(cands):
                for n in cands:
                    if n.lower() in lc:
                        return lc[n.lower()]
                for c in cols:
                    for n in cands:
                        if n.lower() in c.lower():
                            return c
                return None
            col_fecha = pick(['fecha_actividad','fecha','fecha_asignacion','fecha_orden'])
            col_estado = pick(['estado','estado_actividad','estado_operacion','tipificacion','status'])
            col_id = pick(['recurso_operativo_cedula','cedula','id_tecnico','id_codigo_consumidor','external_id'])
            col_ot = pick(['orden_de_trabajo','ot','orden_trabajo','orden','orden_de_servicio'])
            col_cuenta = pick(['numero_de_cuenta','cuenta','nro_cuenta','num_cuenta'])
            col_pk = pick(['id','id_operacion','id_actividad','id_registro','id_orden'])
            if col_fecha and col_estado and col_id:
                id_val = cedula
                if col_id.lower() == 'id_codigo_consumidor':
                    id_val = info.get('id') or cedula
                c3 = connection.cursor(dictionary=True)
                distinct_expr = None
                if col_ot:
                    distinct_expr = f"`{col_ot}`"
                elif col_cuenta:
                    distinct_expr = f"`{col_cuenta}`"
                elif col_pk:
                    distinct_expr = f"`{col_pk}`"
                count_expr = f"COUNT(DISTINCT {distinct_expr})" if distinct_expr else "COUNT(*)"
                status_list = ['completado','completada']
                placeholders = ','.join(['%s'] * len(status_list))
                ot_required = f" AND `{col_ot}` IS NOT NULL AND TRIM(CAST(`{col_ot}` AS CHAR)) <> ''" if col_ot else ''
                q = f"SELECT DATE(`{col_fecha}`) AS d, {count_expr} AS c FROM operaciones_actividades_diarias WHERE DATE(`{col_fecha}`) BETWEEN %s AND %s AND LOWER(REPLACE(TRIM(CAST(`{col_estado}` AS CHAR)),'_',' ')) IN ({placeholders}){ot_required} AND CAST(`{col_id}` AS CHAR) = %s GROUP BY DATE(`{col_fecha}`)"
                params = (inicio, fin, *status_list, str(id_val))
                c3.execute(q, params)
                for r in c3.fetchall():
                    try:
                        day = r['d'].day if hasattr(r['d'], 'day') else datetime.strptime(str(r['d']), '%Y-%m-%d').date().day
                        idx = day - 1
                        if 0 <= idx < 31:
                            visitas_programadas[idx] = str(int(r.get('c') or 0))
                    except Exception:
                        pass
                c3.close()
            c2.close()
        except Exception:
            pass
        matriz = { 'evaluacion': evals, 'riesgos_controles': riesgos }
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'ultimo_dia': ultimo_dia, 'info': info, 'matriz': matriz, 'observaciones': observaciones, 'firmas': firmas, 'firmas_supervisor': firmas_supervisor, 'pendientes_supervisor': pendientes_supervisor, 'visitas_programadas': visitas_programadas})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/permiso-trabajo-matriz', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_reportes_permiso_trabajo_matriz():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() == 'operativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) AS c 
                    FROM recurso_operativo 
                    WHERE recurso_operativo_cedula = %s 
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    """,
                    (cedula, sup_name)
                )
                ro_c = cursor.fetchone() or {}
                supervised = int(ro_c.get('c') or 0) > 0
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                        """,
                        (cedula, sup_name, inicio, fin)
                    )
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        cursor.execute("SELECT nombre, cargo, carpeta, id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        u = cursor.fetchone() or {}
        info = { 'nombre': u.get('nombre') or '', 'cedula': cedula, 'cargo': u.get('cargo') or '', 'area': u.get('carpeta') or '', 'id': u.get('id_codigo_consumidor') }
        semanas = []
        try:
            cursor.execute(
                """
                SELECT *
                FROM sgis_permiso_trabajo
                WHERE (recurso_operativo_cedula = %s OR cedula = %s)
                  AND (
                        DATE(sgis_permiso_trabajo_fecha_emision) BETWEEN %s AND %s
                     OR DATE(sgis_permiso_trabajo_fecha_finalizacion) BETWEEN %s AND %s
                  )
                ORDER BY sgis_permiso_trabajo_fecha_emision
                """,
                (cedula, cedula, inicio, fin, inicio, fin)
            )
            rows = cursor.fetchall() or []
            for row in rows:
                fi = row.get('sgis_permiso_trabajo_fecha_emision')
                ff = row.get('sgis_permiso_trabajo_fecha_finalizacion')
                try:
                    fi_str = fi.strftime('%Y-%m-%d') if fi else ''
                except Exception:
                    fi_str = str(fi or '')
                try:
                    ff_str = ff.strftime('%Y-%m-%d') if ff else ''
                except Exception:
                    ff_str = str(ff or '')
                respuestas = {}
                exclude = {
                    'sgis_permiso_trabajo_fecha_emision','sgis_permiso_trabajo_fecha_finalizacion','sgis_permiso_trabajo_trabajadores',
                    'sgis_permiso_trabajo_emitido_por','sgis_permiso_trabajo_proyecto','sgis_permiso_trabajo_ciudad',
                    'sgis_permiso_trabajo_responsable_trabajo','sgis_permiso_trabajo_cargo','id_codigo_consumidor',
                    'nombre','cargo','cedula','recurso_operativo_cedula','sgis_permiso_trabajo_confinado_aplica','sgis_permiso_trabajo_altura_aplica'
                }
                for k, v in row.items():
                    if k.startswith('sgis_permiso_trabajo_') and k not in exclude:
                        respuestas[k] = v
                semanas.append({'id': row.get('id_sgis_permiso_trabajo'), 'fecha_emision': fi_str, 'fecha_finalizacion': ff_str, 'respuestas': respuestas})
        except Exception:
            semanas = []
        permiso_ids = []
        try:
            permiso_ids = [r.get('id_sgis_permiso_trabajo') for r in rows if r.get('id_sgis_permiso_trabajo')]
        except Exception:
            permiso_ids = []
        ultimo_dia = fin.day
        def arr(n=31):
            return ['' for _ in range(n)]
        matriz_conf_items = {str(i): arr() for i in range(1, 12)}
        firmas_conf_tecnico = arr()
        firmas_conf_supervisor = arr()
        try:
            rows_c = []
            if permiso_ids:
                placeholders = ','.join(['%s'] * len(permiso_ids))
                sql_c = f"""
                SELECT sgis_permiso_trabajo_historial_confinado_fecha,
                       sgis_permiso_trabajo_historial_confinado_1,
                       sgis_permiso_trabajo_historial_confinado_2,
                       sgis_permiso_trabajo_historial_confinado_3,
                       sgis_permiso_trabajo_historial_confinado_4,
                       sgis_permiso_trabajo_historial_confinado_5,
                       sgis_permiso_trabajo_historial_confinado_6,
                       sgis_permiso_trabajo_historial_confinado_7,
                       sgis_permiso_trabajo_historial_confinado_8,
                       sgis_permiso_trabajo_historial_confinado_9,
                       sgis_permiso_trabajo_historial_confinado_10,
                       sgis_permiso_trabajo_historial_confinado_11,
                       sgis_permiso_trabajo_historial_confinado_firma_tecnico,
                       sgis_permiso_trabajo_historial_confinado_firma_supervisor
                FROM sgis_permiso_trabajo_historial_semanal_confinado
                WHERE id_sgis_permiso_trabajo IN ({placeholders})
                  AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                ORDER BY sgis_permiso_trabajo_historial_confinado_fecha
                """
                params_c = tuple(permiso_ids) + (inicio, fin)
                cursor.execute(sql_c, params_c)
                rows_c = cursor.fetchall() or []
            else:
                cursor.execute(
                    """
                    SELECT sgis_permiso_trabajo_historial_confinado_fecha,
                           sgis_permiso_trabajo_historial_confinado_1,
                           sgis_permiso_trabajo_historial_confinado_2,
                           sgis_permiso_trabajo_historial_confinado_3,
                           sgis_permiso_trabajo_historial_confinado_4,
                           sgis_permiso_trabajo_historial_confinado_5,
                           sgis_permiso_trabajo_historial_confinado_6,
                           sgis_permiso_trabajo_historial_confinado_7,
                           sgis_permiso_trabajo_historial_confinado_8,
                           sgis_permiso_trabajo_historial_confinado_9,
                           sgis_permiso_trabajo_historial_confinado_10,
                           sgis_permiso_trabajo_historial_confinado_11,
                           sgis_permiso_trabajo_historial_confinado_firma_tecnico,
                           sgis_permiso_trabajo_historial_confinado_firma_supervisor
                    FROM sgis_permiso_trabajo_historial_semanal_confinado
                    WHERE id_codigo_consumidor = %s AND DATE(sgis_permiso_trabajo_historial_confinado_fecha) BETWEEN %s AND %s
                    ORDER BY sgis_permiso_trabajo_historial_confinado_fecha
                    """,
                    (info.get('id'), inicio, fin)
                )
                rows_c = cursor.fetchall() or []
            for r in rows_c:
                try:
                    d = r.get('sgis_permiso_trabajo_historial_confinado_fecha')
                    day = d.day if hasattr(d, 'day') else datetime.strptime(str(d), '%Y-%m-%d').day
                    idx = day - 1
                    if 0 <= idx < 31:
                        for i in range(1, 12):
                            key = f'sgis_permiso_trabajo_historial_confinado_{i}'
                            matriz_conf_items[str(i)][idx] = r.get(key) or ''
                        firmas_conf_tecnico[idx] = (r.get('sgis_permiso_trabajo_historial_confinado_firma_tecnico') or '').strip()
                        firmas_conf_supervisor[idx] = (r.get('sgis_permiso_trabajo_historial_confinado_firma_supervisor') or '').strip()
                except Exception:
                    pass
        except Exception:
            pass
        matriz_alt_items = {str(i): arr() for i in range(1, 25)}
        firmas_alt_tecnico = arr()
        firmas_alt_supervisor = arr()
        try:
            rows_a = []
            if permiso_ids:
                placeholders = ','.join(['%s'] * len(permiso_ids))
                sql_a = f"""
                SELECT sgis_permiso_trabajo_historial_altura_fecha,
                       sgis_permiso_trabajo_historial_altura_1,
                       sgis_permiso_trabajo_historial_altura_2,
                       sgis_permiso_trabajo_historial_altura_3,
                       sgis_permiso_trabajo_historial_altura_4,
                       sgis_permiso_trabajo_historial_altura_5,
                       sgis_permiso_trabajo_historial_altura_6,
                       sgis_permiso_trabajo_historial_altura_7,
                       sgis_permiso_trabajo_historial_altura_8,
                       sgis_permiso_trabajo_historial_altura_9,
                       sgis_permiso_trabajo_historial_altura_10,
                       sgis_permiso_trabajo_historial_altura_11,
                       sgis_permiso_trabajo_historial_altura_12,
                       sgis_permiso_trabajo_historial_altura_13,
                       sgis_permiso_trabajo_historial_altura_14,
                       sgis_permiso_trabajo_historial_altura_15,
                       sgis_permiso_trabajo_historial_altura_16,
                       sgis_permiso_trabajo_historial_altura_17,
                       sgis_permiso_trabajo_historial_altura_18,
                       sgis_permiso_trabajo_historial_altura_19,
                       sgis_permiso_trabajo_historial_altura_20,
                       sgis_permiso_trabajo_historial_altura_21,
                       sgis_permiso_trabajo_historial_altura_22,
                       sgis_permiso_trabajo_historial_altura_23,
                       sgis_permiso_trabajo_historial_altura_24,
                       sgis_permiso_trabajo_historial_semanal_altura_firma_tecnico,
                       sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor
                FROM sgis_permiso_trabajo_historial_semanal_altura
                WHERE id_sgis_permiso_trabajo IN ({placeholders})
                  AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                ORDER BY sgis_permiso_trabajo_historial_altura_fecha
                """
                params_a = tuple(permiso_ids) + (inicio, fin)
                cursor.execute(sql_a, params_a)
                rows_a = cursor.fetchall() or []
            else:
                cursor.execute(
                    """
                    SELECT sgis_permiso_trabajo_historial_altura_fecha,
                           sgis_permiso_trabajo_historial_altura_1,
                           sgis_permiso_trabajo_historial_altura_2,
                           sgis_permiso_trabajo_historial_altura_3,
                           sgis_permiso_trabajo_historial_altura_4,
                           sgis_permiso_trabajo_historial_altura_5,
                           sgis_permiso_trabajo_historial_altura_6,
                           sgis_permiso_trabajo_historial_altura_7,
                           sgis_permiso_trabajo_historial_altura_8,
                           sgis_permiso_trabajo_historial_altura_9,
                           sgis_permiso_trabajo_historial_altura_10,
                           sgis_permiso_trabajo_historial_altura_11,
                           sgis_permiso_trabajo_historial_altura_12,
                           sgis_permiso_trabajo_historial_altura_13,
                           sgis_permiso_trabajo_historial_altura_14,
                           sgis_permiso_trabajo_historial_altura_15,
                           sgis_permiso_trabajo_historial_altura_16,
                           sgis_permiso_trabajo_historial_altura_17,
                           sgis_permiso_trabajo_historial_altura_18,
                           sgis_permiso_trabajo_historial_altura_19,
                           sgis_permiso_trabajo_historial_altura_20,
                           sgis_permiso_trabajo_historial_altura_21,
                           sgis_permiso_trabajo_historial_altura_22,
                           sgis_permiso_trabajo_historial_altura_23,
                           sgis_permiso_trabajo_historial_altura_24,
                           sgis_permiso_trabajo_historial_semanal_altura_firma_tecnico,
                           sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor
                    FROM sgis_permiso_trabajo_historial_semanal_altura
                    WHERE id_codigo_consumidor = %s AND DATE(sgis_permiso_trabajo_historial_altura_fecha) BETWEEN %s AND %s
                    ORDER BY sgis_permiso_trabajo_historial_altura_fecha
                    """,
                    (info.get('id'), inicio, fin)
                )
                rows_a = cursor.fetchall() or []
            for r in rows_a:
                try:
                    d = r.get('sgis_permiso_trabajo_historial_altura_fecha')
                    day = d.day if hasattr(d, 'day') else datetime.strptime(str(d), '%Y-%m-%d').day
                    idx = day - 1
                    if 0 <= idx < 31:
                        for i in range(1, 25):
                            key = f'sgis_permiso_trabajo_historial_altura_{i}'
                            matriz_alt_items[str(i)][idx] = r.get(key) or ''
                        firmas_alt_tecnico[idx] = (r.get('sgis_permiso_trabajo_historial_semanal_altura_firma_tecnico') or '').strip()
                        firmas_alt_supervisor[idx] = (r.get('sgis_permiso_trabajo_historial_semanal_altura_firma_supervisor') or '').strip()
                except Exception:
                    pass
        except Exception:
            pass
        mat_conf = { 'items': matriz_conf_items }
        mat_alt = { 'items': matriz_alt_items }
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'ultimo_dia': ultimo_dia, 'info': info, 'permiso': {'semanas': semanas}, 'matriz_confinado': mat_conf, 'matriz_altura': mat_alt, 'firmas_confinado_tecnico': firmas_conf_tecnico, 'firmas_confinado_supervisor': firmas_conf_supervisor, 'firmas_altura_tecnico': firmas_alt_tecnico, 'firmas_altura_supervisor': firmas_alt_supervisor})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/preop-matriz-escaleras', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_reportes_preop_matriz_escaleras():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() == 'operativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) AS c 
                    FROM recurso_operativo 
                    WHERE recurso_operativo_cedula = %s 
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    """,
                    (cedula, sup_name)
                )
                ro_c = cursor.fetchone() or {}
                supervised = int(ro_c.get('c') or 0) > 0
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                        """,
                        (cedula, sup_name, inicio, fin)
                    )
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_escaleras (
                id_sgis_pre_escaleras INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                sgis_pre_escaleras_larguero VARCHAR(4),
                sgis_pre_escaleras_peldanos VARCHAR(4),
                sgis_pre_escaleras_union VARCHAR(4),
                sgis_pre_escaleras_zapatas VARCHAR(4),
                sgis_pre_escaleras_base_apoyo VARCHAR(4),
                sgis_pre_escaleras_piezas_ajuste VARCHAR(4),
                sgis_pre_escaleras_ganchos VARCHAR(4),
                sgis_pre_escaleras_cuerda_polea VARCHAR(4),
                sgis_pre_escaleras_guias_externas VARCHAR(4),
                sgis_pre_escaleras_senal_seguridad VARCHAR(4),
                sgis_pre_escaleras_aseo_escalera VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor.execute(
            """
            SELECT fecha_dia,
                   sgis_pre_escaleras_larguero,
                   sgis_pre_escaleras_peldanos,
                   sgis_pre_escaleras_union,
                   sgis_pre_escaleras_zapatas,
                   sgis_pre_escaleras_base_apoyo,
                   sgis_pre_escaleras_piezas_ajuste,
                   sgis_pre_escaleras_ganchos,
                   sgis_pre_escaleras_cuerda_polea,
                   sgis_pre_escaleras_guias_externas,
                   sgis_pre_escaleras_senal_seguridad,
                   sgis_pre_escaleras_aseo_escalera,
                   observacion,
                   firma_base64,
                   firma
            FROM sgis_pre_escaleras
            WHERE cedula = %s AND fecha_dia BETWEEN %s AND %s
            ORDER BY fecha_dia
            """,
            (cedula, inicio, fin)
        )
        rows = cursor.fetchall()
        ultimo_dia = fin.day
        def arr():
            return ['' for _ in range(31)]
        gen = {
            'larguero': arr(),
            'peldanos': arr(),
            'union': arr(),
            'zapatas': arr(),
            'base_apoyo': arr(),
            'piezas_ajuste': arr(),
            'ganchos': arr(),
            'cuerda_polea': arr(),
            'guias_externas': arr(),
            'senal_seguridad': arr(),
            'aseo_escalera': arr()
        }
        observaciones = arr()
        firmas = arr()
        for row in rows:
            d = row['fecha_dia'].day
            idx = d - 1
            if 0 <= idx < 31:
                gen['larguero'][idx] = row.get('sgis_pre_escaleras_larguero') or ''
                gen['peldanos'][idx] = row.get('sgis_pre_escaleras_peldanos') or ''
                gen['union'][idx] = row.get('sgis_pre_escaleras_union') or ''
                gen['zapatas'][idx] = row.get('sgis_pre_escaleras_zapatas') or ''
                gen['base_apoyo'][idx] = row.get('sgis_pre_escaleras_base_apoyo') or ''
                gen['piezas_ajuste'][idx] = row.get('sgis_pre_escaleras_piezas_ajuste') or ''
                gen['ganchos'][idx] = row.get('sgis_pre_escaleras_ganchos') or ''
                gen['cuerda_polea'][idx] = row.get('sgis_pre_escaleras_cuerda_polea') or ''
                gen['guias_externas'][idx] = row.get('sgis_pre_escaleras_guias_externas') or ''
                gen['senal_seguridad'][idx] = row.get('sgis_pre_escaleras_senal_seguridad') or ''
                gen['aseo_escalera'][idx] = row.get('sgis_pre_escaleras_aseo_escalera') or ''
                observaciones[idx] = (row.get('observacion') or '').strip()
                firmas[idx] = (row.get('firma_base64') or row.get('firma') or '')
        cursor.execute("SELECT nombre, cargo, carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        u = cursor.fetchone() or {}
        info = {
            'nombre': u.get('nombre') or '',
            'cedula': cedula,
            'cargo': u.get('cargo') or '',
            'area': u.get('carpeta') or ''
        }
        matriz = { 'generalidades': gen }
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'ultimo_dia': ultimo_dia, 'info': info, 'matriz': matriz, 'observaciones': observaciones, 'firmas': firmas})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/reportes/preop-matriz-caidas', methods=['GET'])
@login_required_api(role=['administrativo','operativo'])
def api_sgis_reportes_preop_matriz_caidas():
    try:
        cedula = request.args.get('cedula')
        mes = request.args.get('mes')
        if not cedula:
            return jsonify({'success': False, 'error': 'Cédula requerida'}), 400
        if mes:
            try:
                inicio = datetime.strptime(mes + '-01', '%Y-%m-%d').date()
            except ValueError:
                inicio = get_bogota_datetime().date().replace(day=1)
        else:
            inicio = get_bogota_datetime().date().replace(day=1)
        if inicio.month == 12:
            fin = inicio.replace(year=inicio.year + 1, month=1, day=1) - timedelta(days=1)
        else:
            fin = inicio.replace(month=inicio.month + 1, day=1) - timedelta(days=1)
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        ur = session.get('user_role')
        if str(ur or '').strip().lower() == 'operativo':
            sup_name = (session.get('user_name') or '').strip()
            supervised = False
            try:
                cursor.execute(
                    """
                    SELECT COUNT(*) AS c 
                    FROM recurso_operativo 
                    WHERE recurso_operativo_cedula = %s 
                      AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci
                    """,
                    (cedula, sup_name)
                )
                ro_c = cursor.fetchone() or {}
                supervised = int(ro_c.get('c') or 0) > 0
            except Exception:
                supervised = False
            if not supervised:
                try:
                    cursor.execute(
                        """
                        SELECT COUNT(*) AS c 
                        FROM asistencia 
                        WHERE cedula = %s 
                          AND TRIM(super) COLLATE utf8mb4_general_ci = TRIM(%s) COLLATE utf8mb4_general_ci 
                          AND DATE(fecha_asistencia) BETWEEN %s AND %s
                        """,
                        (cedula, sup_name, inicio, fin)
                    )
                    c = cursor.fetchone() or {}
                    supervised = int(c.get('c') or 0) > 0
                except Exception:
                    supervised = False
            if not supervised:
                return jsonify({'success': False, 'error': 'Permisos insuficientes para este técnico'}), 403
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_caidas (
                id_sgis_pre_proteccion_caidas INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                cargo VARCHAR(128) NULL,
                sgis_pre_proteccion_caidas_arnes_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_arnes_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_eslinga_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_anclaje_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_linea_vida_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_mosqueton_fisural VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_pretales_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_manchas VARCHAR(4),
                sgis_pre_proteccion_caidascol VARCHAR(45),
                observacion TEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                firma LONGTEXT,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor.execute(
            """
            SELECT COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) AS fecha_dia,
                   sgis_pre_proteccion_caidas_arnes_marca,
                   sgis_pre_proteccion_caidas_arnes_modelo,
                   sgis_pre_proteccion_caidas_arnes_serie,
                   sgis_pre_proteccion_caidas_arnes_lote,
                   sgis_pre_proteccion_caidas_arnes_fecha_fabri,
                   sgis_pre_proteccion_caidas_arnes_fisura,
                   sgis_pre_proteccion_caidas_arnes_fibra_rota,
                   sgis_pre_proteccion_caidas_arnes_deterioro,
                   sgis_pre_proteccion_caidas_arnes_manchas,
                   sgis_pre_proteccion_caidas_arnes_impacto,
                   sgis_pre_proteccion_caidas_eslinga_marca,
                   sgis_pre_proteccion_caidas_eslinga_modelo,
                   sgis_pre_proteccion_caidas_eslinga_serie,
                   sgis_pre_proteccion_caidas_eslinga_lote,
                   sgis_pre_proteccion_caidas_eslinga_fecha_fabri,
                   sgis_pre_proteccion_caidas_eslinga_fisura,
                   sgis_pre_proteccion_caidas_eslinga_fibra_rota,
                   sgis_pre_proteccion_caidas_eslinga_deterioro,
                   sgis_pre_proteccion_caidas_eslinga_manchas,
                   sgis_pre_proteccion_caidas_eslinga_impacto,
                   sgis_pre_proteccion_caidas_anclaje_marca,
                   sgis_pre_proteccion_caidas_anclaje_modelo,
                   sgis_pre_proteccion_caidas_anclaje_serie,
                   sgis_pre_proteccion_caidas_anclaje_lote,
                   sgis_pre_proteccion_caidas_anclaje_fecha_fabri,
                   sgis_pre_proteccion_caidas_anclaje_fisura,
                   sgis_pre_proteccion_caidas_anclaje_fibra_rota,
                   sgis_pre_proteccion_caidas_anclaje_deterioro,
                   sgis_pre_proteccion_caidas_anclaje_manchas,
                   sgis_pre_proteccion_caidas_anclaje_impacto,
                   sgis_pre_proteccion_caidas_linea_vida_marca,
                   sgis_pre_proteccion_caidas_linea_vida_modelo,
                   sgis_pre_proteccion_caidas_linea_vida_serie,
                   sgis_pre_proteccion_caidas_linea_vida_lote,
                   sgis_pre_proteccion_caidas_linea_vida_fecha_fabri,
                   sgis_pre_proteccion_caidas_linea_vida_fisura,
                   sgis_pre_proteccion_caidas_linea_vida_fibra_rota,
                   sgis_pre_proteccion_caidas_linea_vida_deterioro,
                   sgis_pre_proteccion_caidas_linea_vida_manchas,
                   sgis_pre_proteccion_caidas_linea_vida_impacto,
                   sgis_pre_proteccion_caidas_mosqueton_marca,
                   sgis_pre_proteccion_caidas_mosqueton_modelo,
                   sgis_pre_proteccion_caidas_mosqueton_serie,
                   sgis_pre_proteccion_caidas_mosqueton_lote,
                   sgis_pre_proteccion_caidas_mosqueton_fecha_fabri,
                   sgis_pre_proteccion_caidas_mosqueton_fisural,
                   sgis_pre_proteccion_caidas_mosqueton_deterioro,
                   sgis_pre_proteccion_caidas_mosqueton_manchas,
                   sgis_pre_proteccion_caidas_pretales_marca,
                   sgis_pre_proteccion_caidas_pretales_modelo,
                   sgis_pre_proteccion_caidas_pretales_serie,
                   sgis_pre_proteccion_caidas_pretales_lote,
                   sgis_pre_proteccion_caidas_pretales_fecha_fabri,
                   sgis_pre_proteccion_caidas_pretales_fisura,
                   sgis_pre_proteccion_caidas_pretales_deterioro,
                   sgis_pre_proteccion_caidas_pretales_manchas,
                   observacion,
                   firma_base64,
                   firma
            FROM sgis_pre_proteccion_caidas
            WHERE (
                   (cedula = %s OR recurso_operativo_cedula = %s)
                OR id_codigo_consumidor IN (
                     SELECT id_codigo_consumidor FROM recurso_operativo WHERE recurso_operativo_cedula = %s
                   )
              )
              AND COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro)) BETWEEN %s AND %s
            ORDER BY COALESCE(fecha_dia, DATE(fecha), DATE(fecha_registro))
            """,
            (cedula, cedula, cedula, inicio, fin)
        )
        rows = cursor.fetchall()
        ultimo_dia = fin.day
        def arr():
            return ['' for _ in range(31)]
        matriz = {
            'arnes': { 'fisura': arr(), 'fibra_rota': arr(), 'deterioro': arr(), 'manchas': arr(), 'impacto': arr() },
            'eslinga': { 'fisura': arr(), 'fibra_rota': arr(), 'deterioro': arr(), 'manchas': arr(), 'impacto': arr() },
            'anclaje': { 'fisura': arr(), 'fibra_rota': arr(), 'deterioro': arr(), 'manchas': arr(), 'impacto': arr() },
            'linea_vida': { 'fisura': arr(), 'fibra_rota': arr(), 'deterioro': arr(), 'manchas': arr(), 'impacto': arr() },
            'mosqueton': { 'fisural': arr(), 'deterioro': arr(), 'manchas': arr() },
            'pretales': { 'fisura': arr(), 'deterioro': arr(), 'manchas': arr() }
        }
        observaciones = arr()
        firmas = arr()
        meta = {
            'arnes': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''},
            'eslinga': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''},
            'anclaje': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''},
            'linea_vida': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''},
            'mosqueton': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''},
            'pretales': {'marca':'','modelo':'','serie':'','lote':'','fecha_fabri':''}
        }
        for row in rows:
            d = row['fecha_dia'].day
            idx = d - 1
            if 0 <= idx < 31:
                matriz['arnes']['fisura'][idx] = row.get('sgis_pre_proteccion_caidas_arnes_fisura') or ''
                matriz['arnes']['fibra_rota'][idx] = row.get('sgis_pre_proteccion_caidas_arnes_fibra_rota') or ''
                matriz['arnes']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_arnes_deterioro') or ''
                matriz['arnes']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_arnes_manchas') or ''
                matriz['arnes']['impacto'][idx] = row.get('sgis_pre_proteccion_caidas_arnes_impacto') or ''
                matriz['eslinga']['fisura'][idx] = row.get('sgis_pre_proteccion_caidas_eslinga_fisura') or ''
                matriz['eslinga']['fibra_rota'][idx] = row.get('sgis_pre_proteccion_caidas_eslinga_fibra_rota') or ''
                matriz['eslinga']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_eslinga_deterioro') or ''
                matriz['eslinga']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_eslinga_manchas') or ''
                matriz['eslinga']['impacto'][idx] = row.get('sgis_pre_proteccion_caidas_eslinga_impacto') or ''
                matriz['anclaje']['fisura'][idx] = row.get('sgis_pre_proteccion_caidas_anclaje_fisura') or ''
                matriz['anclaje']['fibra_rota'][idx] = row.get('sgis_pre_proteccion_caidas_anclaje_fibra_rota') or ''
                matriz['anclaje']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_anclaje_deterioro') or ''
                matriz['anclaje']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_anclaje_manchas') or ''
                matriz['anclaje']['impacto'][idx] = row.get('sgis_pre_proteccion_caidas_anclaje_impacto') or ''
                matriz['linea_vida']['fisura'][idx] = row.get('sgis_pre_proteccion_caidas_linea_vida_fisura') or ''
                matriz['linea_vida']['fibra_rota'][idx] = row.get('sgis_pre_proteccion_caidas_linea_vida_fibra_rota') or ''
                matriz['linea_vida']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_linea_vida_deterioro') or ''
                matriz['linea_vida']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_linea_vida_manchas') or ''
                matriz['linea_vida']['impacto'][idx] = row.get('sgis_pre_proteccion_caidas_linea_vida_impacto') or ''
                matriz['mosqueton']['fisural'][idx] = row.get('sgis_pre_proteccion_caidas_mosqueton_fisural') or ''
                matriz['mosqueton']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_mosqueton_deterioro') or ''
                matriz['mosqueton']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_mosqueton_manchas') or ''
                matriz['pretales']['fisura'][idx] = row.get('sgis_pre_proteccion_caidas_pretales_fisura') or ''
                matriz['pretales']['deterioro'][idx] = row.get('sgis_pre_proteccion_caidas_pretales_deterioro') or ''
                matriz['pretales']['manchas'][idx] = row.get('sgis_pre_proteccion_caidas_pretales_manchas') or ''
                observaciones[idx] = (row.get('observacion') or '').strip()
                firmas[idx] = (row.get('firma_base64') or row.get('firma') or '')
                def set_meta(sec, pref):
                    v_marca = (row.get(f'{pref}_marca') or '').strip()
                    v_modelo = (row.get(f'{pref}_modelo') or '').strip()
                    v_serie = (row.get(f'{pref}_serie') or '').strip()
                    v_lote = (row.get(f'{pref}_lote') or '').strip()
                    v_fecha = row.get(f'{pref}_fecha_fabri')
                    if v_marca: meta[sec]['marca'] = v_marca
                    if v_modelo: meta[sec]['modelo'] = v_modelo
                    if v_serie: meta[sec]['serie'] = v_serie
                    if v_lote: meta[sec]['lote'] = v_lote
                    if v_fecha: meta[sec]['fecha_fabri'] = v_fecha.strftime('%Y-%m-%d') if hasattr(v_fecha, 'strftime') else str(v_fecha)
                set_meta('arnes', 'sgis_pre_proteccion_caidas_arnes')
                set_meta('eslinga', 'sgis_pre_proteccion_caidas_eslinga')
                set_meta('anclaje', 'sgis_pre_proteccion_caidas_anclaje')
                set_meta('linea_vida', 'sgis_pre_proteccion_caidas_linea_vida')
                set_meta('mosqueton', 'sgis_pre_proteccion_caidas_mosqueton')
                set_meta('pretales', 'sgis_pre_proteccion_caidas_pretales')
        cursor.execute("SELECT nombre, cargo, carpeta FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
        u = cursor.fetchone() or {}
        info = { 'nombre': u.get('nombre') or '', 'cedula': cedula, 'cargo': u.get('cargo') or '', 'area': u.get('carpeta') or '' }
        return jsonify({'success': True, 'mes': inicio.strftime('%Y-%m'), 'ultimo_dia': ultimo_dia, 'info': info, 'matriz': matriz, 'meta': meta, 'observaciones': observaciones, 'firmas': firmas})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/dashboard-stats', methods=['GET'])
@login_required_api(role='administrativo')
def api_sgis_dashboard_stats():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_dia DATE")
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET fecha_dia = DATE(fecha) WHERE fecha_dia IS NULL")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cargo'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cargo VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'nombre'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN nombre VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha DATETIME")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma_base64'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma_base64 LONGTEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma LONGTEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'observacion'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN observacion TEXT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_registro'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_registro DATETIME")
            connection.commit()
        # Asegurar columna id_codigo_consumidor y migrar datos desde usuario_id si existe
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'id_codigo_consumidor'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN id_codigo_consumidor INT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'usuario_id'")
        if cur_sys.fetchone():
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET id_codigo_consumidor = usuario_id WHERE id_codigo_consumidor IS NULL")
            connection.commit()
        # Asegurar índice único por técnico y día
        cur_sys.execute("SHOW INDEX FROM sgis_pre_proteccion_personal WHERE Key_name = 'uq_tecnico_dia'")
        exists_idx = cur_sys.fetchone()
        if not exists_idx:
            try:
                connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)")
                connection.commit()
            except Exception:
                pass
        cursor = connection.cursor(dictionary=True)
        hoy = get_bogota_datetime().date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_personal WHERE fecha_dia = %s", (hoy,))
        total_preop = cursor.fetchone()['c']
        cursor.execute(
            """
            SELECT COUNT(*) AS c
            FROM sgis_pre_proteccion_personal
            WHERE fecha_dia = %s
              AND (
                COALESCE(casco_estado_general, 'C') <> 'NC' AND
                COALESCE(casco_uso_inf_2_anos, 'C') <> 'NC' AND
                COALESCE(casco_estado_tafilete, 'C') <> 'NC' AND
                COALESCE(casco_puntos_anclaje, 'C') <> 'NC' AND
                COALESCE(barbuquejo_estado_puntos_apoyo, 'C') <> 'NC' AND
                COALESCE(barbuquejo_estado_sujetador_menton, 'C') <> 'NC' AND
                COALESCE(barbuquejo_estado_costuras_correas, 'C') <> 'NC' AND
                COALESCE(guantes_estado_costuras, 'C') <> 'NC' AND
                COALESCE(guantes_estado_palma, 'C') <> 'NC' AND
                COALESCE(guantes_estado_general, 'C') <> 'NC' AND
                COALESCE(monogafas_estado_lentes, 'C') <> 'NC' AND
                COALESCE(monogafas_estado_patillas, 'C') <> 'NC' AND
                COALESCE(monogafas_estado_puente_nariz, 'C') <> 'NC'
              )
            """,
            (hoy,)
        )
        epp_ok = cursor.fetchone()['c']
        cursor.execute(
            """
            SELECT COUNT(*) AS c
            FROM sgis_pre_proteccion_personal
            WHERE fecha_dia = %s
              AND (
                casco_estado_general = 'NC' OR
                casco_uso_inf_2_anos = 'NC' OR
                casco_estado_tafilete = 'NC' OR
                casco_puntos_anclaje = 'NC' OR
                barbuquejo_estado_puntos_apoyo = 'NC' OR
                barbuquejo_estado_sujetador_menton = 'NC' OR
                barbuquejo_estado_costuras_correas = 'NC' OR
                guantes_estado_costuras = 'NC' OR
                guantes_estado_palma = 'NC' OR
                guantes_estado_general = 'NC' OR
                monogafas_estado_lentes = 'NC' OR
                monogafas_estado_patillas = 'NC' OR
                monogafas_estado_puente_nariz = 'NC'
              )
            """,
            (hoy,)
        )
        epp_alertas = cursor.fetchone()['c']
        return jsonify({'success': True, 'data': {'total_preop': total_preop, 'epp_ok': epp_ok, 'epp_alertas': epp_alertas, 'reportes': 0}})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/cleanup', methods=['POST'])
@login_required_api(role='administrativo')
def api_sgis_cleanup():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute("DROP TABLE IF EXISTS sgis_preoperacional_epp")
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cur' in locals():
            try:
                cur.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-proteccion-personal/status', methods=['GET'])
@login_required_api()
def api_sgis_pre_proteccion_status():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_dia DATE")
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET fecha_dia = DATE(fecha) WHERE fecha_dia IS NULL")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cargo'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cargo VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'nombre'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN nombre VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha DATETIME")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma_base64'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma_base64 LONGTEXT")
            connection.commit()
        # Asegurar columna id_codigo_consumidor y migrar datos desde usuario_id si existe
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'id_codigo_consumidor'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN id_codigo_consumidor INT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'usuario_id'")
        if cur_sys.fetchone():
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET id_codigo_consumidor = usuario_id WHERE id_codigo_consumidor IS NULL")
            connection.commit()
        # Asegurar índice único por técnico y día
        cur_sys.execute("SHOW INDEX FROM sgis_pre_proteccion_personal WHERE Key_name = 'uq_tecnico_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)")
            connection.commit()
        cursor = connection.cursor(dictionary=True)
        hoy = get_bogota_datetime().date()
        uid = session.get('id_codigo_consumidor')
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_personal WHERE id_codigo_consumidor = %s AND fecha_dia = %s", (uid, hoy))
        row = cursor.fetchone()
        return jsonify({'success': True, 'already_today': (row and row.get('c',0) > 0)})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-proteccion-personal', methods=['POST'])
@login_required_api()
def api_sgis_pre_proteccion_save():
    try:
        data = request.get_json() or {}
        mapa = {
            'casco_uso_menor_2_anios': 'casco_uso_inf_2_anos',
            'casco_estado_talifete': 'casco_estado_tafilete',
            'casco_puntos_anclaje_barbuquejo': 'casco_puntos_anclaje',
            'barbuquejo_puntos_apoyo': 'barbuquejo_estado_puntos_apoyo',
            'barbuquejo_sujetador_menton': 'barbuquejo_estado_sujetador_menton',
            'barbuquejo_costuras_correas': 'barbuquejo_estado_costuras_correas',
            'guantes_costuras': 'guantes_estado_costuras',
            'guantes_refuerzo_palma': 'guantes_estado_palma',
            'guantes_estado_general': 'guantes_estado_general',
            'monogafas_lentes': 'monogafas_estado_lentes',
            'monogafas_patillas_ajustables': 'monogafas_estado_patillas',
            'monogafas_puente_nariz': 'monogafas_estado_puente_nariz'
        }
        nuevos = [
            'casco_estado_general','casco_uso_inf_2_anos','casco_estado_tafilete','casco_puntos_anclaje',
            'barbuquejo_estado_puntos_apoyo','barbuquejo_estado_sujetador_menton','barbuquejo_estado_costuras_correas',
            'guantes_estado_costuras','guantes_estado_palma','guantes_estado_general',
            'monogafas_estado_lentes','monogafas_estado_patillas','monogafas_estado_puente_nariz'
        ]
        vals = {}
        for nk in nuevos:
            ok = None
            for k,v in mapa.items():
                if v == nk and k in data:
                    ok = data.get(k)
                    break
            if ok is None:
                ok = data.get(nk)
            if ok not in ('C','NC','N/A'):
                return jsonify({'success': False, 'error': f'Campo inválido o faltante: {nk}'}), 400
            vals[nk] = ok
        any_nc = any(vals.get(f) == 'NC' for f in nuevos)
        obs_txt = (data.get('observacion') or data.get('observaciones') or '').strip()
        if any_nc and not obs_txt:
            return jsonify({'success': False, 'error': 'Observaciones requeridas por hallazgos NC'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        # Obtener datos del usuario
        uid = session.get('id_codigo_consumidor')
        ced = session.get('user_cedula')
        cursor.execute("SELECT nombre FROM recurso_operativo WHERE id_codigo_consumidor = %s", (uid,))
        urow = cursor.fetchone() or {}
        nombre = urow.get('nombre') or session.get('user_name')
        cargo = session.get('user_role')
        # Crear tabla si no existe
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_personal (
                id_sgis_pre_proteccion_personal INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                casco_estado_general VARCHAR(4),
                casco_uso_inf_2_anos VARCHAR(4),
                casco_estado_tafilete VARCHAR(4),
                casco_puntos_anclaje VARCHAR(4),
                barbuquejo_estado_puntos_apoyo VARCHAR(4),
                barbuquejo_estado_sujetador_menton VARCHAR(4),
                barbuquejo_estado_costuras_correas VARCHAR(4),
                guantes_estado_costuras VARCHAR(4),
                guantes_estado_palma VARCHAR(4),
                guantes_estado_general VARCHAR(4),
                monogafas_estado_lentes VARCHAR(4),
                monogafas_estado_patillas VARCHAR(4),
                monogafas_estado_puente_nariz VARCHAR(4),
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha_dia DATE")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cedula'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cedula VARCHAR(20)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'cargo'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN cargo VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'nombre'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN nombre VARCHAR(128)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'fecha'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN fecha DATETIME")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma_base64'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma_base64 LONGTEXT")
            connection.commit()
        # Asegurar columna id_codigo_consumidor y migrar datos desde usuario_id si existe
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'id_codigo_consumidor'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN id_codigo_consumidor INT")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'usuario_id'")
        if cur_sys.fetchone():
            connection.cursor().execute("UPDATE sgis_pre_proteccion_personal SET id_codigo_consumidor = usuario_id WHERE id_codigo_consumidor IS NULL")
            connection.commit()
        # Asegurar índice único por técnico y día
        cur_sys.execute("SHOW INDEX FROM sgis_pre_proteccion_personal WHERE Key_name = 'uq_tecnico_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)")
            connection.commit()
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_proteccion_personal LIKE 'firma'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_proteccion_personal ADD COLUMN firma LONGTEXT")
            connection.commit()
        fecha = get_bogota_datetime()
        fecha_dia = fecha.date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_personal WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, fecha_dia))
        row = cursor.fetchone()
        if row and row.get('c',0) > 0:
            return jsonify({'success': False, 'error': 'Ya registraste el preoperacional hoy'}), 409
        firma_base64 = data.get('firma_base64') or None
        observaciones = obs_txt
        cursor.execute(
            """
            INSERT INTO sgis_pre_proteccion_personal (
                id_codigo_consumidor, cargo, recurso_operativo_cedula, casco_estado_general,
                casco_uso_inf_2_anos, casco_estado_tafilete, casco_puntos_anclaje,
                barbuquejo_estado_puntos_apoyo, barbuquejo_estado_sujetador_menton, barbuquejo_estado_costuras_correas,
                guantes_estado_costuras, guantes_estado_palma, guantes_estado_general,
                monogafas_estado_lentes, monogafas_estado_patillas, monogafas_estado_puente_nariz,
                observacion, fecha_registro, firma, fecha_dia, cedula, nombre, fecha, firma_base64
            ) VALUES (
                %s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,%s,%s,%s,%s
            )
        """,
        (
            uid, cargo, ced, vals['casco_estado_general'],
            vals['casco_uso_inf_2_anos'], vals['casco_estado_tafilete'], vals['casco_puntos_anclaje'],
            vals['barbuquejo_estado_puntos_apoyo'], vals['barbuquejo_estado_sujetador_menton'], vals['barbuquejo_estado_costuras_correas'],
            vals['guantes_estado_costuras'], vals['guantes_estado_palma'], vals['guantes_estado_general'],
            vals['monogafas_estado_lentes'], vals['monogafas_estado_patillas'], vals['monogafas_estado_puente_nariz'],
            observaciones, fecha, firma_base64, fecha_dia, ced, nombre, fecha, firma_base64
        )
        )
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-escaleras/status', methods=['GET'])
@login_required_api()
def api_sgis_pre_escaleras_status():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_escaleras (
                id_sgis_pre_escaleras INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                sgis_pre_escaleras_larguero VARCHAR(4),
                sgis_pre_escaleras_peldanos VARCHAR(4),
                sgis_pre_escaleras_union VARCHAR(4),
                sgis_pre_escaleras_zapatas VARCHAR(4),
                sgis_pre_escaleras_base_apoyo VARCHAR(4),
                sgis_pre_escaleras_piezas_ajuste VARCHAR(4),
                sgis_pre_escaleras_ganchos VARCHAR(4),
                sgis_pre_escaleras_cuerda_polea VARCHAR(4),
                sgis_pre_escaleras_guias_externas VARCHAR(4),
                sgis_pre_escaleras_senal_seguridad VARCHAR(4),
                sgis_pre_escaleras_aseo_escalera VARCHAR(4),
                sgis_pre_escaleras_marca VARCHAR(128),
                sgis_pre_escaleras_cant_peldano INT,
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_escaleras LIKE 'fecha_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_escaleras ADD COLUMN fecha_dia DATE")
            connection.commit()
        cur_sys.execute("SHOW INDEX FROM sgis_pre_escaleras WHERE Key_name = 'uq_tecnico_dia'")
        if not cur_sys.fetchone():
            connection.cursor().execute("ALTER TABLE sgis_pre_escaleras ADD UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)")
            connection.commit()
        uid = session.get('id_codigo_consumidor')
        hoy = get_bogota_datetime().date()
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_escaleras WHERE id_codigo_consumidor = %s AND fecha_dia = %s", (uid, hoy))
        row = cursor.fetchone()
        return jsonify({'success': True, 'already_today': (row and row.get('c',0) > 0)})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-escaleras', methods=['POST'])
@login_required_api()
def api_sgis_pre_escaleras_save():
    try:
        data = request.get_json() or {}
        campos = ['larguero','peldanos','union','zapatas','base_apoyo','piezas_ajuste','ganchos','cuerda_polea','guias_externas','senal_seguridad','aseo_escalera']
        for k in campos:
            v = (data.get(k) or '').strip()
            if v not in ('C','NC','N/A'):
                return jsonify({'success': False, 'error': f'Campo inválido o faltante: {k}'}), 400
        any_nc = any((data.get(k) or '').strip() == 'NC' for k in campos)
        obs_txt = (data.get('observacion') or '').strip()
        if any_nc and not obs_txt:
            return jsonify({'success': False, 'error': 'Observaciones requeridas por hallazgos NC'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_escaleras (
                id_sgis_pre_escaleras INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                cargo VARCHAR(128) NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                sgis_pre_escaleras_larguero VARCHAR(4),
                sgis_pre_escaleras_peldanos VARCHAR(4),
                sgis_pre_escaleras_union VARCHAR(4),
                sgis_pre_escaleras_zapatas VARCHAR(4),
                sgis_pre_escaleras_base_apoyo VARCHAR(4),
                sgis_pre_escaleras_piezas_ajuste VARCHAR(4),
                sgis_pre_escaleras_ganchos VARCHAR(4),
                sgis_pre_escaleras_cuerda_polea VARCHAR(4),
                sgis_pre_escaleras_guias_externas VARCHAR(4),
                sgis_pre_escaleras_senal_seguridad VARCHAR(4),
                sgis_pre_escaleras_aseo_escalera VARCHAR(4),
                sgis_pre_escaleras_marca VARCHAR(128),
                sgis_pre_escaleras_cant_peldano INT,
                observacion TEXT,
                fecha_registro DATETIME,
                firma LONGTEXT,
                fecha_dia DATE,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cur_sys = connection.cursor(buffered=True)
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_escaleras LIKE 'sgis_pre_escaleras_seÃ±al_seguridad'")
        senal_alt = bool(cur_sys.fetchone())
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_escaleras LIKE 'sgis_pre_escaleras_senal_seguridad'")
        senal_std = bool(cur_sys.fetchone())
        if not senal_alt and not senal_std:
            connection.cursor().execute("ALTER TABLE sgis_pre_escaleras ADD COLUMN sgis_pre_escaleras_senal_seguridad VARCHAR(4)")
            connection.commit()
            senal_std = True
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_escaleras LIKE 'sgis_pre_escaleras_cant_peldaño'")
        peld_alt = bool(cur_sys.fetchone())
        cur_sys.execute("SHOW COLUMNS FROM sgis_pre_escaleras LIKE 'sgis_pre_escaleras_cant_peldano'")
        peld_std = bool(cur_sys.fetchone())
        if not peld_alt and not peld_std:
            connection.cursor().execute("ALTER TABLE sgis_pre_escaleras ADD COLUMN sgis_pre_escaleras_cant_peldano INT")
            connection.commit()
            peld_std = True
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        ced = session.get('user_cedula')
        cursor.execute("SELECT nombre, cargo FROM recurso_operativo WHERE id_codigo_consumidor = %s", (uid,))
        urow = cursor.fetchone() or {}
        nombre = urow.get('nombre') or session.get('user_name')
        cargo = urow.get('cargo') or session.get('user_role')
        fecha = get_bogota_datetime()
        fecha_dia = fecha.date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_escaleras WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, fecha_dia))
        row = cursor.fetchone()
        if row and row.get('c',0) > 0:
            return jsonify({'success': False, 'error': 'Ya registraste el preoperacional hoy'}), 409
        firma_base64 = data.get('firma_base64') or None
        marca = (data.get('marca') or '').strip()
        cant = int(str(data.get('cant_peldano') or '0') or '0')
        col_senal = 'sgis_pre_escaleras_seÃ±al_seguridad' if senal_alt else 'sgis_pre_escaleras_senal_seguridad'
        col_peld = 'sgis_pre_escaleras_cant_peldaño' if peld_alt else 'sgis_pre_escaleras_cant_peldano'
        sql = (
            f"""
            INSERT INTO sgis_pre_escaleras (
                id_codigo_consumidor, cargo, recurso_operativo_cedula,
                sgis_pre_escaleras_larguero, sgis_pre_escaleras_peldanos, sgis_pre_escaleras_union,
                sgis_pre_escaleras_zapatas, sgis_pre_escaleras_base_apoyo, sgis_pre_escaleras_piezas_ajuste,
                sgis_pre_escaleras_ganchos, sgis_pre_escaleras_cuerda_polea, sgis_pre_escaleras_guias_externas,
                {col_senal}, sgis_pre_escaleras_aseo_escalera,
                sgis_pre_escaleras_marca, {col_peld}, observacion,
                fecha_registro, firma, fecha_dia, cedula, nombre, fecha, firma_base64
            ) VALUES (
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,
                %s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,%s,%s,%s
            )
            """
        )
        params = (
            uid, cargo, ced,
            data['larguero'], data['peldanos'], data['union'],
            data['zapatas'], data['base_apoyo'], data['piezas_ajuste'],
            data['ganchos'], data['cuerda_polea'], data['guias_externas'],
            data['senal_seguridad'], data['aseo_escalera'],
            marca, cant, obs_txt,
            fecha, firma_base64, fecha_dia, ced, nombre, fecha, firma_base64
        )
        cursor.execute(sql, params)
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-caidas/status', methods=['GET'])
@login_required_api()
def api_sgis_pre_caidas_status():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_caidas (
                id_sgis_pre_proteccion_caidas INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                cargo VARCHAR(128) NULL,
                sgis_pre_proteccion_caidas_arnes_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_arnes_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_eslinga_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_anclaje_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_linea_vida_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_mosqueton_fisural VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_pretales_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_manchas VARCHAR(4),
                sgis_pre_proteccion_caidascol VARCHAR(45),
                observacion TEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                firma LONGTEXT,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        hoy = get_bogota_datetime().date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_caidas WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, hoy))
        row = cursor.fetchone()
        return jsonify({'success': True, 'already_today': (row and row.get('c',0) > 0)})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-caidas/current', methods=['GET'])
@login_required_api()
def api_sgis_pre_caidas_current():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        cursor.execute(
            """
            SELECT *
            FROM sgis_pre_proteccion_caidas
            WHERE id_codigo_consumidor = %s
            ORDER BY id_sgis_pre_proteccion_caidas DESC
            LIMIT 1
            """,
            (uid,)
        )
        row = cursor.fetchone()
        if not row:
            return jsonify({'success': True, 'data': None})
        fields = {
            'sgis_pre_proteccion_caidas_arnes_marca': row.get('sgis_pre_proteccion_caidas_arnes_marca'),
            'sgis_pre_proteccion_caidas_arnes_modelo': row.get('sgis_pre_proteccion_caidas_arnes_modelo'),
            'sgis_pre_proteccion_caidas_arnes_serie': row.get('sgis_pre_proteccion_caidas_arnes_serie'),
            'sgis_pre_proteccion_caidas_arnes_lote': row.get('sgis_pre_proteccion_caidas_arnes_lote'),
            'sgis_pre_proteccion_caidas_arnes_fecha_fabri': row.get('sgis_pre_proteccion_caidas_arnes_fecha_fabri'),
            'sgis_pre_proteccion_caidas_eslinga_marca': row.get('sgis_pre_proteccion_caidas_eslinga_marca'),
            'sgis_pre_proteccion_caidas_eslinga_modelo': row.get('sgis_pre_proteccion_caidas_eslinga_modelo'),
            'sgis_pre_proteccion_caidas_eslinga_serie': row.get('sgis_pre_proteccion_caidas_eslinga_serie'),
            'sgis_pre_proteccion_caidas_eslinga_lote': row.get('sgis_pre_proteccion_caidas_eslinga_lote'),
            'sgis_pre_proteccion_caidas_eslinga_fecha_fabri': row.get('sgis_pre_proteccion_caidas_eslinga_fecha_fabri'),
            'sgis_pre_proteccion_caidas_anclaje_marca': row.get('sgis_pre_proteccion_caidas_anclaje_marca'),
            'sgis_pre_proteccion_caidas_anclaje_modelo': row.get('sgis_pre_proteccion_caidas_anclaje_modelo'),
            'sgis_pre_proteccion_caidas_anclaje_serie': row.get('sgis_pre_proteccion_caidas_anclaje_serie'),
            'sgis_pre_proteccion_caidas_anclaje_lote': row.get('sgis_pre_proteccion_caidas_anclaje_lote'),
            'sgis_pre_proteccion_caidas_anclaje_fecha_fabri': row.get('sgis_pre_proteccion_caidas_anclaje_fecha_fabri'),
            'sgis_pre_proteccion_caidas_linea_vida_marca': row.get('sgis_pre_proteccion_caidas_linea_vida_marca'),
            'sgis_pre_proteccion_caidas_linea_vida_modelo': row.get('sgis_pre_proteccion_caidas_linea_vida_modelo'),
            'sgis_pre_proteccion_caidas_linea_vida_serie': row.get('sgis_pre_proteccion_caidas_linea_vida_serie'),
            'sgis_pre_proteccion_caidas_linea_vida_lote': row.get('sgis_pre_proteccion_caidas_linea_vida_lote'),
            'sgis_pre_proteccion_caidas_linea_vida_fecha_fabri': row.get('sgis_pre_proteccion_caidas_linea_vida_fecha_fabri'),
            'sgis_pre_proteccion_caidas_mosqueton_marca': row.get('sgis_pre_proteccion_caidas_mosqueton_marca'),
            'sgis_pre_proteccion_caidas_mosqueton_modelo': row.get('sgis_pre_proteccion_caidas_mosqueton_modelo'),
            'sgis_pre_proteccion_caidas_mosqueton_serie': row.get('sgis_pre_proteccion_caidas_mosqueton_serie'),
            'sgis_pre_proteccion_caidas_mosqueton_lote': row.get('sgis_pre_proteccion_caidas_mosqueton_lote'),
            'sgis_pre_proteccion_caidas_mosqueton_fecha_fabri': row.get('sgis_pre_proteccion_caidas_mosqueton_fecha_fabri'),
            'sgis_pre_proteccion_caidas_pretales_marca': row.get('sgis_pre_proteccion_caidas_pretales_marca'),
            'sgis_pre_proteccion_caidas_pretales_modelo': row.get('sgis_pre_proteccion_caidas_pretales_modelo'),
            'sgis_pre_proteccion_caidas_pretales_serie': row.get('sgis_pre_proteccion_caidas_pretales_serie'),
            'sgis_pre_proteccion_caidas_pretales_lote': row.get('sgis_pre_proteccion_caidas_pretales_lote'),
            'sgis_pre_proteccion_caidas_pretales_fecha_fabri': row.get('sgis_pre_proteccion_caidas_pretales_fecha_fabri')
        }
        for k in list(fields.keys()):
            v = fields[k]
            try:
                if hasattr(v, 'strftime'):
                    fields[k] = v.strftime('%Y-%m-%d')
            except Exception:
                pass
        return jsonify({'success': True, 'data': fields})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/pre-caidas', methods=['POST'])
@login_required_api()
def api_sgis_pre_caidas_save():
    try:
        data = request.get_json() or {}
        grupos = {
            'arnes': ['fisura','fibra_rota','deterioro','manchas','impacto'],
            'eslinga': ['fisura','fibra_rota','deterioro','manchas','impacto'],
            'anclaje': ['fisura','fibra_rota','deterioro','manchas','impacto'],
            'linea_vida': ['fisura','fibra_rota','deterioro','manchas','impacto'],
            'mosqueton': ['fisural','deterioro','manchas'],
            'pretales': ['fisura','deterioro','manchas']
        }
        for g, checks in grupos.items():
            for ckey in checks:
                k = f"sgis_pre_proteccion_caidas_{g}_{ckey}"
                v = (data.get(k) or '').strip()
                if v not in ('C','NC','N/A'):
                    return jsonify({'success': False, 'error': f'Campo inválido o faltante: {k}'}), 400
        any_nc = any(((data.get(f"sgis_pre_proteccion_caidas_{g}_{ckey}") or '').strip() == 'NC') for g, checks in grupos.items() for ckey in checks)
        obs_txt = (data.get('observacion') or '').strip()
        if any_nc and not obs_txt:
            return jsonify({'success': False, 'error': 'Observaciones requeridas por hallazgos NC'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_pre_proteccion_caidas (
                id_sgis_pre_proteccion_caidas INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                cargo VARCHAR(128) NULL,
                sgis_pre_proteccion_caidas_arnes_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_arnes_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_arnes_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_arnes_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_eslinga_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_eslinga_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_eslinga_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_anclaje_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_anclaje_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_anclaje_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_linea_vida_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_linea_vida_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_fibra_rota VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_linea_vida_impacto VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_mosqueton_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_mosqueton_fisural VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_mosqueton_manchas VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_marca VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_modelo VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_serie VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_lote VARCHAR(128),
                sgis_pre_proteccion_caidas_pretales_fecha_fabri DATE,
                sgis_pre_proteccion_caidas_pretales_fisura VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_deterioro VARCHAR(4),
                sgis_pre_proteccion_caidas_pretales_manchas VARCHAR(4),
                sgis_pre_proteccion_caidascol VARCHAR(45),
                observacion TEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                firma LONGTEXT,
                cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                fecha DATETIME,
                firma_base64 LONGTEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE KEY uq_tecnico_dia (id_codigo_consumidor, fecha_dia)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        connection.cursor().execute(ddl)
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        ced = session.get('user_cedula')
        cursor.execute("SELECT nombre, cargo FROM recurso_operativo WHERE id_codigo_consumidor = %s", (uid,))
        urow = cursor.fetchone() or {}
        nombre = urow.get('nombre') or session.get('user_name')
        cargo = urow.get('cargo') or session.get('user_role')
        fecha = get_bogota_datetime()
        fecha_dia = fecha.date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_pre_proteccion_caidas WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, fecha_dia))
        row = cursor.fetchone()
        if row and row.get('c',0) > 0:
            return jsonify({'success': False, 'error': 'Ya registraste el preoperacional hoy'}), 409
        firma_base64 = data.get('firma_base64') or None
        def gstr(prefix, name):
            return (data.get(f"sgis_pre_proteccion_caidas_{prefix}_{name}") or '').strip()
        params = (
            uid, ced, cargo,
            gstr('arnes','marca'), gstr('arnes','modelo'), gstr('arnes','serie'), gstr('arnes','lote'), data.get('sgis_pre_proteccion_caidas_arnes_fecha_fabri') or None,
            gstr('arnes','fisura'), gstr('arnes','fibra_rota'), gstr('arnes','deterioro'), gstr('arnes','manchas'), gstr('arnes','impacto'),
            gstr('eslinga','marca'), gstr('eslinga','modelo'), gstr('eslinga','serie'), gstr('eslinga','lote'), data.get('sgis_pre_proteccion_caidas_eslinga_fecha_fabri') or None,
            gstr('eslinga','fisura'), gstr('eslinga','fibra_rota'), gstr('eslinga','deterioro'), gstr('eslinga','manchas'), gstr('eslinga','impacto'),
            gstr('anclaje','marca'), gstr('anclaje','modelo'), gstr('anclaje','serie'), gstr('anclaje','lote'), data.get('sgis_pre_proteccion_caidas_anclaje_fecha_fabri') or None,
            gstr('anclaje','fisura'), gstr('anclaje','fibra_rota'), gstr('anclaje','deterioro'), gstr('anclaje','manchas'), gstr('anclaje','impacto'),
            gstr('linea_vida','marca'), gstr('linea_vida','modelo'), gstr('linea_vida','serie'), gstr('linea_vida','lote'), data.get('sgis_pre_proteccion_caidas_linea_vida_fecha_fabri') or None,
            gstr('linea_vida','fisura'), gstr('linea_vida','fibra_rota'), gstr('linea_vida','deterioro'), gstr('linea_vida','manchas'), gstr('linea_vida','impacto'),
            gstr('mosqueton','marca'), gstr('mosqueton','modelo'), gstr('mosqueton','serie'), gstr('mosqueton','lote'), data.get('sgis_pre_proteccion_caidas_mosqueton_fecha_fabri') or None,
            gstr('mosqueton','fisural'), gstr('mosqueton','deterioro'), gstr('mosqueton','manchas'),
            gstr('pretales','marca'), gstr('pretales','modelo'), gstr('pretales','serie'), gstr('pretales','lote'), data.get('sgis_pre_proteccion_caidas_pretales_fecha_fabri') or None,
            gstr('pretales','fisura'), gstr('pretales','deterioro'), gstr('pretales','manchas'),
            (data.get('sgis_pre_proteccion_caidascol') or '').strip(),
            obs_txt,
            fecha,
            fecha_dia,
            firma_base64,
            ced,
            nombre,
            fecha,
            firma_base64
        )
        sql = (
            """
            INSERT INTO sgis_pre_proteccion_caidas (
                id_codigo_consumidor, recurso_operativo_cedula, cargo,
                sgis_pre_proteccion_caidas_arnes_marca, sgis_pre_proteccion_caidas_arnes_modelo, sgis_pre_proteccion_caidas_arnes_serie, sgis_pre_proteccion_caidas_arnes_lote, sgis_pre_proteccion_caidas_arnes_fecha_fabri,
                sgis_pre_proteccion_caidas_arnes_fisura, sgis_pre_proteccion_caidas_arnes_fibra_rota, sgis_pre_proteccion_caidas_arnes_deterioro, sgis_pre_proteccion_caidas_arnes_manchas, sgis_pre_proteccion_caidas_arnes_impacto,
                sgis_pre_proteccion_caidas_eslinga_marca, sgis_pre_proteccion_caidas_eslinga_modelo, sgis_pre_proteccion_caidas_eslinga_serie, sgis_pre_proteccion_caidas_eslinga_lote, sgis_pre_proteccion_caidas_eslinga_fecha_fabri,
                sgis_pre_proteccion_caidas_eslinga_fisura, sgis_pre_proteccion_caidas_eslinga_fibra_rota, sgis_pre_proteccion_caidas_eslinga_deterioro, sgis_pre_proteccion_caidas_eslinga_manchas, sgis_pre_proteccion_caidas_eslinga_impacto,
                sgis_pre_proteccion_caidas_anclaje_marca, sgis_pre_proteccion_caidas_anclaje_modelo, sgis_pre_proteccion_caidas_anclaje_serie, sgis_pre_proteccion_caidas_anclaje_lote, sgis_pre_proteccion_caidas_anclaje_fecha_fabri,
                sgis_pre_proteccion_caidas_anclaje_fisura, sgis_pre_proteccion_caidas_anclaje_fibra_rota, sgis_pre_proteccion_caidas_anclaje_deterioro, sgis_pre_proteccion_caidas_anclaje_manchas, sgis_pre_proteccion_caidas_anclaje_impacto,
                sgis_pre_proteccion_caidas_linea_vida_marca, sgis_pre_proteccion_caidas_linea_vida_modelo, sgis_pre_proteccion_caidas_linea_vida_serie, sgis_pre_proteccion_caidas_linea_vida_lote, sgis_pre_proteccion_caidas_linea_vida_fecha_fabri,
                sgis_pre_proteccion_caidas_linea_vida_fisura, sgis_pre_proteccion_caidas_linea_vida_fibra_rota, sgis_pre_proteccion_caidas_linea_vida_deterioro, sgis_pre_proteccion_caidas_linea_vida_manchas, sgis_pre_proteccion_caidas_linea_vida_impacto,
                sgis_pre_proteccion_caidas_mosqueton_marca, sgis_pre_proteccion_caidas_mosqueton_modelo, sgis_pre_proteccion_caidas_mosqueton_serie, sgis_pre_proteccion_caidas_mosqueton_lote, sgis_pre_proteccion_caidas_mosqueton_fecha_fabri,
                sgis_pre_proteccion_caidas_mosqueton_fisural, sgis_pre_proteccion_caidas_mosqueton_deterioro, sgis_pre_proteccion_caidas_mosqueton_manchas,
                sgis_pre_proteccion_caidas_pretales_marca, sgis_pre_proteccion_caidas_pretales_modelo, sgis_pre_proteccion_caidas_pretales_serie, sgis_pre_proteccion_caidas_pretales_lote, sgis_pre_proteccion_caidas_pretales_fecha_fabri,
                sgis_pre_proteccion_caidas_pretales_fisura, sgis_pre_proteccion_caidas_pretales_deterioro, sgis_pre_proteccion_caidas_pretales_manchas,
                sgis_pre_proteccion_caidascol,
                observacion, fecha_registro, fecha_dia, firma, cedula, nombre, fecha, firma_base64
            ) VALUES (
                %s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,
                %s,
                %s,%s,%s,%s,%s,%s,%s,%s
            )
            """
        )
        cursor.execute(sql, params)
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass
# ============================================================================
# ENDPOINTS PARA INICIO DE OPERACIÓN - NUEVOS CAMPOS DE ASISTENCIA
# ============================================================================

@app.route('/api/asistencia/actualizar-campo', methods=['POST'])
@login_required_api()
def actualizar_campo_asistencia():
    """Actualizar un campo específico de asistencia para inicio de operación"""
    try:
        data = request.get_json()
        
        # Validar campos requeridos
        required_fields = ['cedula', 'campo', 'valor']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False, 
                    'message': f'Campo requerido faltante: {field}'
                }), 400
        
        cedula = data['cedula']
        campo = data['campo']
        valor = data['valor']
        fecha_filtro = data.get('fecha')  # Obtener fecha del frontend
        
        # Validar que el campo sea uno de los permitidos
        campos_permitidos = ['hora_inicio', 'estado', 'novedad']
        if campo not in campos_permitidos:
            return jsonify({
                'success': False,
                'message': f'Campo no permitido: {campo}. Campos válidos: {campos_permitidos}'
            }), 400
        
        # Validar valores específicos para el campo 'estado'
        if campo == 'estado':
            estados_validos = ['CUMPLE', 'NO CUMPLE', 'NOVEDAD', 'NO APLICA']
            if valor and valor not in estados_validos:
                return jsonify({
                    'success': False,
                    'message': f'Estado no válido: {valor}. Estados válidos: {estados_validos}'
                }), 400
        
        # Validar formato de hora para 'hora_inicio'
        if campo == 'hora_inicio' and valor:
            try:
                # Validar formato HH:MM
                datetime.strptime(valor, '%H:%M')
            except ValueError:
                return jsonify({
                    'success': False,
                    'message': 'Formato de hora inválido. Use HH:MM (ej: 08:30)'
                }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False, 
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Determinar fecha a usar para la búsqueda
        bogota_tz = pytz.timezone('America/Bogota')
        if fecha_filtro:
            # Usar la fecha enviada desde el frontend
            try:
                fecha_busqueda = datetime.strptime(fecha_filtro, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({
                    'success': False,
                    'message': 'Formato de fecha inválido. Use YYYY-MM-DD'
                }), 400
        else:
            # Si no se envía fecha, usar la fecha actual
            fecha_busqueda = datetime.now(bogota_tz).date()
        
        # Buscar registro de asistencia para la fecha especificada y esta cédula
        cursor.execute("""
            SELECT id_asistencia, DATE(fecha_asistencia) as fecha_registro
            FROM asistencia 
            WHERE cedula = %s AND DATE(fecha_asistencia) = %s
            ORDER BY fecha_asistencia DESC
            LIMIT 1
        """, (cedula, fecha_busqueda))
        
        resultado = cursor.fetchone()
        
        if not resultado:
            # No existe registro para la fecha especificada, crear uno nuevo
            try:
                # Obtener información del técnico desde la tabla recurso_operativo
                cursor.execute("SELECT nombre FROM recurso_operativo WHERE recurso_operativo_cedula = %s", (cedula,))
                usuario = cursor.fetchone()
                
                if not usuario:
                    # Si no está en recurso_operativo, usar la cédula como nombre por defecto
                    nombre_tecnico = f"Técnico {cedula}"
                else:
                    nombre_tecnico = usuario['nombre'] or f"Técnico {cedula}"
                
                # Crear nuevo registro de asistencia para la fecha especificada
                fecha_completa = datetime.combine(fecha_busqueda, datetime.now(bogota_tz).time())
                cursor.execute("""
                    INSERT INTO asistencia (cedula, tecnico, carpeta_dia, carpeta, super, fecha_asistencia, estado, novedad)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (cedula, nombre_tecnico, '', '', '', fecha_completa, None, None))
                
                id_asistencia = cursor.lastrowid
                
                app.logger.info(f"Creado nuevo registro de asistencia para cédula {cedula} con ID {id_asistencia}")
                
            except Exception as e:
                app.logger.error(f"Error creando registro de asistencia: {str(e)}")
                return jsonify({
                    'success': False,
                    'message': f'Error creando registro de asistencia: {str(e)}'
                }), 500
        else:
            id_asistencia = resultado['id_asistencia']
            app.logger.info(f"Registro encontrado - ID: {id_asistencia}, Fecha: {resultado['fecha_registro']}")
        
        # Verificar que el registro aún existe antes de actualizar
        cursor.execute("SELECT id_asistencia, estado, hora_inicio FROM asistencia WHERE id_asistencia = %s", (id_asistencia,))
        verificacion = cursor.fetchone()
        if not verificacion:
            app.logger.error(f"CRÍTICO: El registro {id_asistencia} ya no existe en la base de datos")
            return jsonify({
                'success': False,
                'message': f'El registro {id_asistencia} no existe'
            }), 500
        
        app.logger.info(f"Verificación antes de UPDATE - ID: {id_asistencia}, Estado actual: {verificacion.get('estado')}, Hora actual: {verificacion.get('hora_inicio')}")
        
        # Actualizar el campo específico
        app.logger.info(f"Preparando actualización - ID: {id_asistencia}, Campo: {campo}, Valor: {valor}")
        query = f"UPDATE asistencia SET {campo} = %s WHERE id_asistencia = %s"
        app.logger.info(f"Ejecutando query: {query} con valores: ({valor}, {id_asistencia})")
        cursor.execute(query, (valor if valor else None, id_asistencia))
        
        app.logger.info(f"Filas afectadas: {cursor.rowcount}")
        
        # Verificar si la actualización fue exitosa o si el valor ya era el mismo
        if cursor.rowcount > 0:
            connection.commit()
            app.logger.info(f"Campo {campo} actualizado exitosamente para cédula {cedula}")
            return jsonify({
                'success': True,
                'message': f'Campo {campo} actualizado correctamente para cédula {cedula}'
            })
        else:
            # Verificar si el valor ya era el mismo (no es un error)
            cursor.execute(f"SELECT {campo} FROM asistencia WHERE id_asistencia = %s", (id_asistencia,))
            valor_actual = cursor.fetchone()
            
            # Comparar valores considerando diferentes formatos
            valores_iguales = False
            if valor_actual:
                val_actual = valor_actual[campo]
                if campo == 'hora_inicio':
                    # Para hora_inicio, comparar considerando formatos diferentes
                    # Convertir ambos a formato HH:MM para comparar
                    try:
                        if val_actual:
                            # Convertir 8:30:00 a 08:30 para comparar
                            hora_actual = str(val_actual).split(':')[:2]  # Tomar solo HH:MM
                            hora_actual_fmt = f"{hora_actual[0].zfill(2)}:{hora_actual[1]}"
                            hora_nueva_fmt = str(valor)
                            if ':' not in hora_nueva_fmt and len(hora_nueva_fmt) == 4:
                                # Convertir 0830 a 08:30
                                hora_nueva_fmt = f"{hora_nueva_fmt[:2]}:{hora_nueva_fmt[2:]}"
                            valores_iguales = hora_actual_fmt == hora_nueva_fmt
                            app.logger.info(f"Comparación hora - Actual: {hora_actual_fmt}, Nueva: {hora_nueva_fmt}, Iguales: {valores_iguales}")
                    except Exception as e:
                        app.logger.error(f"Error comparando horas: {e}")
                        valores_iguales = str(val_actual) == str(valor)
                else:
                    # Para otros campos, comparación directa
                    valores_iguales = str(val_actual) == str(valor)
            
            if valores_iguales:
                app.logger.info(f"Campo {campo} ya tenía el valor {valor} para cédula {cedula} - no requiere actualización")
                connection.commit()  # Commit por si acaso
                return jsonify({
                    'success': True,
                    'message': f'Campo {campo} ya tenía el valor correcto para cédula {cedula}'
                })
            else:
                app.logger.error(f"No se pudo actualizar el registro. ID: {id_asistencia}, Campo: {campo}, Valor: {valor}")
                return jsonify({
                    'success': False,
                    'message': 'No se pudo actualizar el registro'
                }), 500
        
    except Exception as e:
        return jsonify({
            'success': False, 
            'message': f'Error: {str(e)}'
        }), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/obtener-datos', methods=['GET'])
@login_required_api()
def obtener_datos_asistencia():
    """Obtener datos existentes de asistencia para una cédula específica"""
    try:
        cedula = request.args.get('cedula')
        
        if not cedula:
            return jsonify({
                'success': False,
                'message': 'Cédula requerida'
            }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False, 
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener fecha actual en zona horaria de Bogotá
        bogota_tz = pytz.timezone('America/Bogota')
        fecha_actual = datetime.now(bogota_tz).date()
        
        # Buscar registro de asistencia para hoy y esta cédula
        cursor.execute("""
            SELECT 
                id_asistencia,
                cedula,
                tecnico,
                hora_inicio,
                estado,
                novedad,
                fecha_asistencia
            FROM asistencia 
            WHERE cedula = %s AND DATE(fecha_asistencia) = %s
            ORDER BY fecha_asistencia DESC
            LIMIT 1
        """, (cedula, fecha_actual))
        
        resultado = cursor.fetchone()
        
        if resultado:
            # Formatear hora_inicio si existe
            if resultado['hora_inicio']:
                # El campo time se devuelve como timedelta desde MySQL
                if hasattr(resultado['hora_inicio'], 'total_seconds'):
                    # Es un timedelta
                    total_seconds = int(resultado['hora_inicio'].total_seconds())
                    hours = total_seconds // 3600
                    minutes = (total_seconds % 3600) // 60
                    resultado['hora_inicio'] = f"{hours:02d}:{minutes:02d}"
                else:
                    # Es un string o datetime.time
                    resultado['hora_inicio'] = str(resultado['hora_inicio'])[:5]  # HH:MM
            
            return jsonify({
                'success': True,
                'data': resultado,
                'exists': True
            })
        else:
            return jsonify({
                'success': True,
                'data': {
                    'cedula': cedula,
                    'hora_inicio': '',
                    'estado': '',
                    'novedad': ''
                },
                'exists': False
            })
        
    except Exception as e:
        return jsonify({
            'success': False, 
            'message': f'Error: {str(e)}'
        }), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/actualizar-masivo', methods=['POST'])
@login_required_api()
def actualizar_masivo_asistencia():
    """Actualizar múltiples registros de asistencia para inicio de operación"""
    try:
        data = request.get_json()
        
        # Validar que se envíen datos
        if not data.get('asistencias'):
            return jsonify({
                'success': False,
                'message': 'No se enviaron datos de asistencias'
            }), 400
        
        asistencias = data['asistencias']
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Obtener fecha actual en zona horaria de Bogotá
        bogota_tz = pytz.timezone('America/Bogota')
        fecha_actual = datetime.now(bogota_tz).date()
        
        actualizaciones_exitosas = 0
        errores = []
        
        for asistencia in asistencias:
            try:
                cedula = asistencia.get('cedula')
                hora_inicio = asistencia.get('hora_inicio')
                estado = asistencia.get('estado')
                novedad = asistencia.get('novedad')
                
                if not cedula:
                    errores.append(f'Cédula faltante en uno de los registros')
                    continue
                
                # Validar estado si se proporciona
                if estado:
                    estados_validos = ['CUMPLE', 'NO CUMPLE', 'NOVEDAD', 'NO APLICA']
                    if estado not in estados_validos:
                        errores.append(f'Estado inválido para cédula {cedula}: {estado}')
                        continue
                
                # Validar formato de hora si se proporciona
                if hora_inicio:
                    try:
                        datetime.strptime(hora_inicio, '%H:%M')
                    except ValueError:
                        errores.append(f'Formato de hora inválido para cédula {cedula}: {hora_inicio}')
                        continue
                
                # Buscar registro de asistencia para hoy y esta cédula
                cursor.execute("""
                    SELECT id_asistencia
                    FROM asistencia 
                    WHERE cedula = %s AND DATE(fecha_asistencia) = %s
                    ORDER BY fecha_asistencia DESC
                    LIMIT 1
                """, (cedula, fecha_actual))
                
                resultado = cursor.fetchone()
                
                if not resultado:
                    errores.append(f'No se encontró registro de asistencia para cédula {cedula}')
                    continue
                
                id_asistencia = resultado[0]
                
                # Actualizar los campos
                cursor.execute("""
                    UPDATE asistencia 
                    SET hora_inicio = %s, estado = %s, novedad = %s
                    WHERE id_asistencia = %s
                """, (
                    hora_inicio if hora_inicio else None,
                    estado if estado else None,
                    novedad if novedad else None,
                    id_asistencia
                ))
                
                if cursor.rowcount > 0:
                    actualizaciones_exitosas += 1
                else:
                    errores.append(f'No se pudo actualizar el registro para cédula {cedula}')
                    
            except Exception as e:
                errores.append(f'Error procesando cédula {cedula}: {str(e)}')
                continue
        
        # Confirmar cambios si hubo actualizaciones exitosas
        if actualizaciones_exitosas > 0:
            connection.commit()
        
        # Preparar respuesta
        response_data = {
            'success': actualizaciones_exitosas > 0,
            'actualizaciones_exitosas': actualizaciones_exitosas,
            'total_procesados': len(asistencias)
        }
        
        if errores:
            response_data['errores'] = errores
            response_data['message'] = f'Se actualizaron {actualizaciones_exitosas} de {len(asistencias)} registros. {len(errores)} errores encontrados.'
        else:
            response_data['message'] = f'Se actualizaron {actualizaciones_exitosas} registros exitosamente'
        
        return jsonify(response_data)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Error: {str(e)}'
        }), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/obtener-campos-inicio', methods=['GET'])
@login_required(role='administrativo')
def obtener_campos_inicio_operacion():
    """Obtener los campos de inicio de operación para una fecha específica"""
    try:
        # Obtener parámetros
        fecha = request.args.get('fecha')
        supervisor = request.args.get('supervisor')
        
        # Si no se proporciona fecha, usar la fecha actual
        if not fecha:
            bogota_tz = pytz.timezone('America/Bogota')
            fecha = datetime.now(bogota_tz).date().strftime('%Y-%m-%d')
        
        try:
            fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'message': 'Formato de fecha inválido. Use YYYY-MM-DD'
            }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({
                'success': False,
                'message': 'Error de conexión a la base de datos'
            }), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Construir consulta base
        query = """
            SELECT 
                a.cedula,
                a.tecnico,
                a.carpeta,
                a.super as supervisor,
                a.carpeta_dia,
                a.hora_inicio,
                a.estado,
                a.novedad,
                a.fecha_asistencia
            FROM asistencia a
            WHERE DATE(a.fecha_asistencia) = %s
        """
        
        params = [fecha_obj]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor:
            query += " AND a.super = %s"
            params.append(supervisor)
        
        query += " ORDER BY a.tecnico"
        
        cursor.execute(query, params)
        registros = cursor.fetchall()
        
        # Formatear los datos para el frontend
        datos_formateados = []
        for registro in registros:
            datos_formateados.append({
                'cedula': registro['cedula'],
                'tecnico': registro['tecnico'],
                'carpeta': registro['carpeta'],
                'supervisor': registro['supervisor'],
                'carpeta_dia': registro['carpeta_dia'],
                'hora_inicio': registro['hora_inicio'].strftime('%H:%M') if registro['hora_inicio'] else '',
                'estado': registro['estado'] or '',
                'novedad': registro['novedad'] or '',
                'fecha_asistencia': registro['fecha_asistencia'].strftime('%Y-%m-%d %H:%M:%S')
            })
        
        return jsonify({
            'success': True,
            'data': datos_formateados,
            'fecha': fecha,
            'total_registros': len(datos_formateados)
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Error: {str(e)}'
        }), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/graficas/operacion-recurso', methods=['GET'])
@login_required_api(role='administrativo')
def obtener_datos_grafica_operacion_recurso():
    """Obtener datos temporales para la gráfica de Operación x Recurso Operativo"""
    try:
        # Obtener parámetros
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor_filtro = request.args.get('supervisor')
        tipo_agrupacion = request.args.get('agrupacion', 'mes')  # 'mes' o 'dia'
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            return jsonify({
                'success': False,
                'message': 'Se requieren fecha_inicio y fecha_fin'
            }), 400
        
        try:
            fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
            fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'message': 'Formato de fecha inválido. Use YYYY-MM-DD'
            }), 400
        
        # Validar rango de fechas
        if fecha_inicio > fecha_fin:
            return jsonify({
                'success': False,
                'message': 'La fecha de inicio no puede ser mayor que la fecha de fin'
            }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Determinar el formato de agrupación temporal
        if tipo_agrupacion == 'mes':
            formato_fecha = "DATE_FORMAT(a.fecha_asistencia, '%Y-%m')"
            formato_orden = "DATE_FORMAT(a.fecha_asistencia, '%Y-%m')"
        else:  # dia
            formato_fecha = "DATE(a.fecha_asistencia)"
            formato_orden = "DATE(a.fecha_asistencia)"
        
        # Consulta para obtener datos agrupados por tiempo y grupo (sin tabla tipificacion_asistencia)
        query = f"""
            SELECT 
                {formato_fecha} as periodo,
                CASE 
                    WHEN a.carpeta IN ('ARREGLOS HFC', 'MANTENIMIENTO FTTH','DX') THEN 'ARREGLOS'
                    WHEN a.carpeta IN ('BROWNFIELD', 'FTTH INSTALACIONES', 'INSTALACIONES DOBLES') THEN 'INSTALACIONES'
                    WHEN a.carpeta IN ('POSTVENTA', 'POSTVENTA FTTH') THEN 'POSTVENTA'
                    ELSE 'OTROS'
                END as grupo,
                COUNT(DISTINCT a.id_codigo_consumidor) as total_tecnicos
            FROM asistencia a
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND a.carpeta IS NOT NULL
                AND a.carpeta != ''
                AND a.carpeta IN ('DX','ARREGLOS HFC', 'MANTENIMIENTO FTTH', 'BROWNFIELD', 'FTTH INSTALACIONES', 'INSTALACIONES DOBLES', 'POSTVENTA', 'POSTVENTA FTTH')
        """
        
        params = [fecha_inicio, fecha_fin]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor_filtro:
            query += " AND a.super = %s"
            params.append(supervisor_filtro)
        
        query += f"""
            GROUP BY {formato_fecha}, CASE 
                WHEN a.carpeta IN ('ARREGLOS HFC', 'MANTENIMIENTO FTTH','DX') THEN 'ARREGLOS'
                WHEN a.carpeta IN ('BROWNFIELD', 'FTTH INSTALACIONES', 'INSTALACIONES DOBLES') THEN 'INSTALACIONES'
                WHEN a.carpeta IN ('POSTVENTA', 'POSTVENTA FTTH') THEN 'POSTVENTA'
                ELSE 'OTROS'
            END
            ORDER BY {formato_orden}, grupo
        """
        
        # Log the SQL query for debugging
        logging.info(f"Executing SQL query for operacion-recurso: {query}")
        logging.info(f"Query parameters: {params}")
        
        try:
            cursor.execute(query, tuple(params))
            resultados = cursor.fetchall()
            logging.info(f"Query executed successfully, returned {len(resultados)} rows")
        except Exception as sql_error:
            logging.error(f"SQL execution error in operacion-recurso endpoint: {str(sql_error)}")
            logging.error(f"Failed query: {query}")
            logging.error(f"Query parameters: {params}")
            logging.error(f"tipo_agrupacion: {tipo_agrupacion}")
            raise sql_error
        
        # Organizar datos para la gráfica
        datos_grafica = {}
        periodos = set()
        grupos = ['ARREGLOS', 'INSTALACIONES', 'POSTVENTA']
        
        # Inicializar estructura de datos
        for grupo in grupos:
            datos_grafica[grupo] = {}
        
        # Procesar resultados
        for resultado in resultados:
            periodo = str(resultado['periodo'])
            grupo = resultado['grupo']
            total = resultado['total_tecnicos']
            
            periodos.add(periodo)
            if grupo in datos_grafica:
                datos_grafica[grupo][periodo] = total
        
        # Convertir a lista ordenada de períodos
        periodos_ordenados = sorted(list(periodos))
        
        # Preparar datos finales para Chart.js
        datasets = []
        colores = {
            'ARREGLOS': '#FF6384',
            'INSTALACIONES': '#36A2EB', 
            'POSTVENTA': '#FFCE56'
        }
        
        for grupo in grupos:
            data = []
            for periodo in periodos_ordenados:
                data.append(datos_grafica[grupo].get(periodo, 0))
            
            datasets.append({
                'label': grupo,
                'data': data,
                'borderColor': colores[grupo],
                'backgroundColor': colores[grupo] + '20',
                'fill': False,
                'tension': 0.1
            })
        
        return jsonify({
            'success': True,
            'datos': datasets,
            'labels': periodos_ordenados,
            'agrupacion': tipo_agrupacion,
            'fecha_inicio': fecha_inicio.strftime('%Y-%m-%d'),
            'fecha_fin': fecha_fin.strftime('%Y-%m-%d'),
            'supervisor_filtro': supervisor_filtro
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/api/asistencia/graficas/carpeta-dia', methods=['GET'])
@login_required_api(role='administrativo')
def obtener_datos_grafica_carpeta_dia():
    """Obtener datos temporales para la gráfica de Operación x Carpeta Día"""
    try:
        # Obtener parámetros
        fecha_inicio = request.args.get('fecha_inicio')
        fecha_fin = request.args.get('fecha_fin')
        supervisor_filtro = request.args.get('supervisor')
        tipo_agrupacion = request.args.get('agrupacion', 'mes')  # 'mes' o 'dia'
        
        # Validar fechas
        if not fecha_inicio or not fecha_fin:
            return jsonify({
                'success': False,
                'message': 'Se requieren fecha_inicio y fecha_fin'
            }), 400
        
        try:
            fecha_inicio = datetime.strptime(fecha_inicio, '%Y-%m-%d').date()
            fecha_fin = datetime.strptime(fecha_fin, '%Y-%m-%d').date()
        except ValueError:
            return jsonify({
                'success': False,
                'message': 'Formato de fecha inválido. Use YYYY-MM-DD'
            }), 400
        
        # Validar rango de fechas
        if fecha_inicio > fecha_fin:
            return jsonify({
                'success': False,
                'message': 'La fecha de inicio no puede ser mayor que la fecha de fin'
            }), 400
        
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Determinar el formato de agrupación temporal
        if tipo_agrupacion == 'mes':
            formato_fecha = "DATE_FORMAT(a.fecha_asistencia, '%Y-%m')"
            formato_orden = "DATE_FORMAT(a.fecha_asistencia, '%Y-%m')"
        else:  # dia
            formato_fecha = "DATE(a.fecha_asistencia)"
            formato_orden = "DATE(a.fecha_asistencia)"
        
        # Consulta para obtener datos agrupados por tiempo y grupo (basado en carpeta_dia)
        query = f"""
            SELECT 
                {formato_fecha} as periodo,
                CASE 
                    WHEN a.carpeta_dia IN ('ARGHFC', 'MTFTTH') THEN 'ARREGLOS'
                    WHEN a.carpeta_dia IN ('BROW', 'FTTHI', 'HFCI') THEN 'INSTALACIONES'
                    WHEN a.carpeta_dia IN ('POST', 'FTTHPOST') THEN 'POSTVENTA'
                    ELSE 'OTROS'
                END as grupo,
                COUNT(DISTINCT a.id_codigo_consumidor) as total_tecnicos
            FROM asistencia a
            WHERE DATE(a.fecha_asistencia) BETWEEN %s AND %s
                AND a.carpeta_dia IS NOT NULL 
                AND a.carpeta_dia != ''
                AND a.carpeta_dia IN ('ARGHFC', 'MTFTTH', 'BROW', 'FTTHI', 'HFCI', 'POST', 'FTTHPOST')
        """
        
        params = [fecha_inicio, fecha_fin]
        
        # Agregar filtro por supervisor si se proporciona
        if supervisor_filtro:
            query += " AND a.super = %s"
            params.append(supervisor_filtro)
        
        query += f"""
            GROUP BY {formato_fecha}, CASE 
                WHEN a.carpeta_dia IN ('ARGHFC', 'MTFTTH') THEN 'ARREGLOS'
                WHEN a.carpeta_dia IN ('BROW', 'FTTHI', 'HFCI') THEN 'INSTALACIONES'
                WHEN a.carpeta_dia IN ('POST', 'FTTHPOST') THEN 'POSTVENTA'
                ELSE 'OTROS'
            END
            ORDER BY {formato_orden}, grupo
        """
        
        # Log the SQL query for debugging
        logging.info(f"Executing SQL query for carpeta-dia: {query}")
        logging.info(f"Query parameters: {params}")
        
        try:
            cursor.execute(query, tuple(params))
            resultados = cursor.fetchall()
            logging.info(f"Query executed successfully, returned {len(resultados)} rows")
        except Exception as sql_error:
            logging.error(f"SQL execution error in carpeta-dia endpoint: {str(sql_error)}")
            logging.error(f"Failed query: {query}")
            logging.error(f"Query parameters: {params}")
            logging.error(f"tipo_agrupacion: {tipo_agrupacion}")
            raise sql_error
        
        # Organizar datos para la gráfica
        datos_grafica = {}
        periodos = set()
        grupos = ['ARREGLOS', 'INSTALACIONES', 'POSTVENTA']
        
        # Inicializar estructura de datos
        for grupo in grupos:
            datos_grafica[grupo] = {}
        
        # Procesar resultados
        for resultado in resultados:
            periodo = str(resultado['periodo'])
            grupo = resultado['grupo']
            total = resultado['total_tecnicos']
            
            periodos.add(periodo)
            if grupo in datos_grafica:
                datos_grafica[grupo][periodo] = total
        
        # Convertir a lista ordenada de períodos
        periodos_ordenados = sorted(list(periodos))
        
        # Preparar datos finales para Chart.js
        datasets = []
        colores = {
            'ARREGLOS': '#FF6384',
            'INSTALACIONES': '#36A2EB', 
            'POSTVENTA': '#FFCE56'
        }
        
        for grupo in grupos:
            data = []
            for periodo in periodos_ordenados:
                data.append(datos_grafica[grupo].get(periodo, 0))
            
            datasets.append({
                'label': grupo,
                'data': data,
                'borderColor': colores[grupo],
                'backgroundColor': colores[grupo] + '20',
                'fill': False,
                'tension': 0.1
            })
        
        return jsonify({
            'success': True,
            'datos': datasets,
            'labels': periodos_ordenados,
            'agrupacion': tipo_agrupacion,
            'fecha_inicio': fecha_inicio.strftime('%Y-%m-%d'),
            'fecha_fin': fecha_fin.strftime('%Y-%m-%d'),
            'supervisor_filtro': supervisor_filtro
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# ===== RUTAS VENCIMIENTOS =====

@app.route('/mpa/vencimientos')
def mpa_vencimientos():
    """Módulo de gestión de vencimientos consolidados"""
    # Temporalmente sin autenticación para pruebas
    # if not current_user.has_role('administrativo'):
    #     flash('No tienes permisos para acceder a este módulo.', 'error')
    #     return redirect(url_for('mpa_dashboard'))
    
    return render_template('modulos/mpa/vencimientos.html')

# ===== APIs VENCIMIENTOS =====

# API consolidada para obtener todos los vencimientos
@app.route('/api/mpa/vencimientos', methods=['GET'])
def api_vencimientos_consolidados():
    """API consolidada para obtener vencimientos de SOAT, Técnico Mecánica y Licencias de Conducir"""
    # Temporalmente sin autenticación para pruebas
    # if not current_user.has_role('administrativo'):
    #     return jsonify({'error': 'Sin permisos'}), 403
    
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        vencimientos_consolidados = []
        
        # 1. Obtener vencimientos de SOAT
        query_soat = """
        SELECT 
            s.id_mpa_soat as id,
            s.placa,
            s.fecha_vencimiento,
            s.tecnico_asignado,
            ro.nombre as tecnico_nombre,
            'SOAT' as tipo,
            s.estado
        FROM mpa_soat s
        LEFT JOIN recurso_operativo ro ON s.tecnico_asignado = ro.id_codigo_consumidor
        WHERE s.fecha_vencimiento IS NOT NULL
          AND (
              s.tecnico_asignado IS NULL
              OR TRIM(s.tecnico_asignado) = ''
              OR ro.estado = 'Activo'
          )
        ORDER BY s.fecha_vencimiento ASC
        """
        
        cursor.execute(query_soat)
        soats = cursor.fetchall()
        
        for soat in soats:
            vencimientos_consolidados.append({
                'id': soat['id'],
                'tipo': 'SOAT',
                'placa': soat['placa'],
                'fecha_vencimiento': soat['fecha_vencimiento'].strftime('%Y-%m-%d') if soat['fecha_vencimiento'] else None,
                'tecnico_nombre': soat['tecnico_nombre'] or 'Sin asignar',
                'estado_original': soat['estado']
            })
        
        # 2. Obtener vencimientos de Técnico Mecánica
        query_tm = """
        SELECT 
            tm.id_mpa_tecnico_mecanica as id,
            tm.placa,
            tm.fecha_vencimiento,
            tm.tecnico_asignado,
            ro.nombre as tecnico_nombre,
            'Técnico Mecánica' as tipo,
            tm.estado
        FROM mpa_tecnico_mecanica tm
        LEFT JOIN recurso_operativo ro ON tm.tecnico_asignado = ro.id_codigo_consumidor
        WHERE tm.fecha_vencimiento IS NOT NULL
          AND (
              tm.tecnico_asignado IS NULL
              OR TRIM(tm.tecnico_asignado) = ''
              OR ro.estado = 'Activo'
          )
        ORDER BY tm.fecha_vencimiento ASC
        """
        
        cursor.execute(query_tm)
        tecnicos = cursor.fetchall()
        
        for tm in tecnicos:
            vencimientos_consolidados.append({
                'id': tm['id'],
                'tipo': 'Técnico Mecánica',
                'placa': tm['placa'],
                'fecha_vencimiento': tm['fecha_vencimiento'].strftime('%Y-%m-%d') if tm['fecha_vencimiento'] else None,
                'tecnico_nombre': tm['tecnico_nombre'] or 'Sin asignar',
                'estado_original': tm['estado']
            })
        
        # 3. Obtener vencimientos de Licencias de Conducir
        query_lc = """
        SELECT 
            lc.id_mpa_licencia_conducir as id,
            lc.fecha_vencimiento,
            lc.tecnico,
            ro.nombre as tecnico_nombre,
            'Licencia de Conducir' as tipo
        FROM mpa_licencia_conducir lc
        LEFT JOIN recurso_operativo ro ON lc.tecnico = ro.id_codigo_consumidor
        WHERE lc.fecha_vencimiento IS NOT NULL
          AND (
              lc.tecnico IS NULL
              OR TRIM(lc.tecnico) = ''
              OR ro.estado = 'Activo'
          )
        ORDER BY lc.fecha_vencimiento ASC
        """
        
        cursor.execute(query_lc)
        licencias = cursor.fetchall()
        
        for lc in licencias:
            vencimientos_consolidados.append({
                'id': lc['id'],
                'tipo': 'Licencia de Conducir',
                'placa': None,  # Las licencias no tienen placa
                'fecha_vencimiento': lc['fecha_vencimiento'].strftime('%Y-%m-%d') if lc['fecha_vencimiento'] else None,
                'tecnico_nombre': lc['tecnico_nombre'] or 'Sin asignar',
                'estado_original': None  # Las licencias no tienen campo estado
            })
        
        # 4. Calcular días restantes y estado para todos los vencimientos
        from datetime import datetime
        import pytz
        
        colombia_tz = pytz.timezone('America/Bogota')
        fecha_actual = datetime.now(colombia_tz).date()
        
        for vencimiento in vencimientos_consolidados:
            if vencimiento['fecha_vencimiento']:
                fecha_venc = datetime.strptime(vencimiento['fecha_vencimiento'], '%Y-%m-%d').date()
                dias_restantes = (fecha_venc - fecha_actual).days
                
                vencimiento['dias_restantes'] = dias_restantes
                
                # Determinar estado basado en días restantes
                if dias_restantes < 0:
                    vencimiento['estado'] = 'Vencido'
                elif dias_restantes <= 30:
                    vencimiento['estado'] = 'Próximo a vencer'
                else:
                    vencimiento['estado'] = 'Vigente'
            else:
                vencimiento['dias_restantes'] = None
                vencimiento['estado'] = 'Sin fecha'
        
        # 5. Ordenar por fecha de vencimiento (más próximos primero)
        vencimientos_consolidados.sort(key=lambda x: (
            x['fecha_vencimiento'] if x['fecha_vencimiento'] else '9999-12-31'
        ))
        
        return jsonify({
            'success': True,
            'data': vencimientos_consolidados,
            'total': len(vencimientos_consolidados)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API para obtener detalles de un vencimiento específico
@app.route('/api/mpa/vencimiento/<string:tipo>/<int:documento_id>', methods=['GET'])
def api_get_vencimiento_detalle(tipo, documento_id):
    """API para obtener detalles de un vencimiento específico"""
    # Temporalmente sin autenticación para pruebas
    # if not current_user.has_role('administrativo'):
    #     return jsonify({'error': 'Sin permisos'}), 403
    
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'error': 'Error de conexión a la base de datos'}), 500
            
        cursor = connection.cursor(dictionary=True)
        
        # Determinar la tabla y consulta según el tipo
        if tipo.lower() == 'soat':
            query = """
            SELECT 
                s.*,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula
            FROM mpa_soat s
            LEFT JOIN recurso_operativo ro ON s.tecnico_asignado = ro.id_codigo_consumidor
            WHERE s.id_mpa_soat = %s
            """
        elif tipo.lower() == 'tecnico_mecanica':
            query = """
            SELECT 
                tm.*,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula
            FROM mpa_tecnico_mecanica tm
            LEFT JOIN recurso_operativo ro ON tm.tecnico_asignado = ro.id_codigo_consumidor
            WHERE tm.id_mpa_tecnico_mecanica = %s
            """
        elif tipo.lower() == 'licencia_conducir':
            query = """
            SELECT 
                lc.*,
                ro.nombre as tecnico_nombre,
                ro.recurso_operativo_cedula as tecnico_cedula
            FROM mpa_licencia_conducir lc
            LEFT JOIN recurso_operativo ro ON lc.tecnico = ro.id_codigo_consumidor
            WHERE lc.id_mpa_licencia_conducir = %s
            """
        else:
            return jsonify({'success': False, 'error': 'Tipo de documento no válido'}), 400
        
        cursor.execute(query, (documento_id,))
        documento = cursor.fetchone()
        
        if not documento:
            return jsonify({'success': False, 'error': 'Documento no encontrado'}), 404
        
        # Formatear fechas y calcular días restantes
        from datetime import datetime
        import pytz
        
        colombia_tz = pytz.timezone('America/Bogota')
        fecha_actual = datetime.now(colombia_tz).date()
        
        # Formatear fechas
        for key, value in documento.items():
            if isinstance(value, datetime):
                documento[key] = value.strftime('%Y-%m-%d %H:%M:%S')
            elif hasattr(value, 'strftime'):  # Para objetos date
                documento[key] = value.strftime('%Y-%m-%d')
        
        # Calcular días restantes si hay fecha de vencimiento
        if documento.get('fecha_vencimiento'):
            try:
                fecha_venc = datetime.strptime(documento['fecha_vencimiento'], '%Y-%m-%d').date()
                dias_restantes = (fecha_venc - fecha_actual).days
                documento['dias_restantes'] = dias_restantes
                
                # Determinar estado
                if dias_restantes < 0:
                    documento['estado_calculado'] = 'Vencido'
                elif dias_restantes <= 30:
                    documento['estado_calculado'] = 'Próximo a vencer'
                else:
                    documento['estado_calculado'] = 'Vigente'
            except:
                documento['dias_restantes'] = None
                documento['estado_calculado'] = 'Sin fecha'
        
        return jsonify({
            'success': True,
            'data': documento,
            'tipo': tipo
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

# API de prueba con ruta diferente
@app.route('/api/mpa/test-vencimientos', methods=['GET'])
def api_test_vencimientos():
    """API de prueba para vencimientos"""
    return jsonify({
        'success': True,
        'data': [],
        'message': 'API de prueba funcionando correctamente'
    })

@app.route('/api/mi/vencimientos', methods=['GET'])
@login_required()
def api_mis_vencimientos():
    """Devuelve vencimientos próximos para el usuario actual:
    - SOAT y Tecnomecánica de sus vehículos asignados
    - Licencia de conducir del usuario
    Filtra por ventana de días (param "dias", default 45).
    """
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500

        cursor = connection.cursor(dictionary=True)

        dias_anticipacion = int(request.args.get('dias', 45))
        user_id = session.get('user_id') or session.get('id_codigo_consumidor')
        if not user_id:
            return jsonify({'success': False, 'message': 'Usuario no autenticado'}), 401

        vencimientos_items = []

        cursor.execute("SHOW TABLES LIKE 'mpa_soat'")
        soats = []
        if cursor.fetchone():
            query_soat = """
                SELECT 
                    s.placa,
                    s.fecha_vencimiento,
                    DATEDIFF(s.fecha_vencimiento, CURDATE()) AS dias_soat
                FROM mpa_soat s
                WHERE s.tecnico_asignado = %s
                  AND s.fecha_vencimiento IS NOT NULL
                  AND s.fecha_vencimiento NOT LIKE '0000-00-00%'
                  AND s.fecha_vencimiento > '1900-01-01'
                  AND s.fecha_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)
                ORDER BY s.fecha_vencimiento ASC
            """
            cursor.execute(query_soat, (user_id, dias_anticipacion))
            soats = cursor.fetchall()

        cursor.execute("SHOW TABLES LIKE 'mpa_tecnico_mecanica'")
        tecnomecanicas = []
        if cursor.fetchone():
            query_tm = """
                SELECT 
                    tm.placa,
                    tm.fecha_vencimiento,
                    DATEDIFF(tm.fecha_vencimiento, CURDATE()) AS dias_tm
                FROM mpa_tecnico_mecanica tm
                WHERE tm.tecnico_asignado = %s
                  AND tm.fecha_vencimiento IS NOT NULL
                  AND tm.fecha_vencimiento NOT LIKE '0000-00-00%'
                  AND tm.fecha_vencimiento > '1900-01-01'
                  AND tm.fecha_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)
                ORDER BY tm.fecha_vencimiento ASC
            """
            cursor.execute(query_tm, (user_id, dias_anticipacion))
            tecnomecanicas = cursor.fetchall()

        def estado_desde_dias(dias:int) -> str:
            if dias is None:
                return 'desconocido'
            if dias < 0:
                return 'vencido'
            if dias <= 7:
                return 'critico'
            if dias <= 30:
                return 'proximo'
            return 'vigente'

        # Armar items SOAT
        for s in soats:
            dias = s.get('dias_soat')
            fecha = s.get('fecha_vencimiento')
            vencimientos_items.append({
                'tipo': 'SOAT',
                'placa': s.get('placa'),
                'fecha_vencimiento': fecha.strftime('%Y-%m-%d') if fecha else None,
                'dias_restantes': dias,
                'estado': estado_desde_dias(dias)
            })

        # Armar items Tecnomecánica
        for tm in tecnomecanicas:
            dias = tm.get('dias_tm')
            fecha = tm.get('fecha_vencimiento')
            vencimientos_items.append({
                'tipo': 'Tecnomecánica',
                'placa': tm.get('placa'),
                'fecha_vencimiento': fecha.strftime('%Y-%m-%d') if fecha else None,
                'dias_restantes': dias,
                'estado': estado_desde_dias(dias)
            })

        cursor.execute("SHOW TABLES LIKE 'mpa_licencia_conducir'")
        licencias = []
        if cursor.fetchone():
            query_lic = """
                SELECT 
                    lc.tipo_licencia,
                    lc.fecha_vencimiento,
                    DATEDIFF(lc.fecha_vencimiento, CURDATE()) as dias_licencia
                FROM mpa_licencia_conducir lc
                WHERE lc.tecnico = %s
                  AND lc.fecha_vencimiento IS NOT NULL
                  AND lc.fecha_vencimiento NOT IN ('0000-00-00', '1900-01-01')
                  AND lc.fecha_vencimiento <= DATE_ADD(CURDATE(), INTERVAL %s DAY)
                ORDER BY lc.fecha_vencimiento ASC
            """
            cursor.execute(query_lic, (user_id, dias_anticipacion))
            licencias = cursor.fetchall()

        for lc in licencias:
            dias = lc.get('dias_licencia')
            vencimientos_items.append({
                'tipo': 'Licencia de Conducir',
                'placa': None,
                'tipo_licencia': lc.get('tipo_licencia'),
                'fecha_vencimiento': lc['fecha_vencimiento'].strftime('%Y-%m-%d') if lc['fecha_vencimiento'] else None,
                'dias_restantes': dias,
                'estado': estado_desde_dias(dias)
            })

        cursor.close()
        connection.close()

        items_filtrados = [i for i in vencimientos_items if i.get('fecha_vencimiento')]

        return jsonify({
            'success': True,
            'total': len(items_filtrados),
            'items': items_filtrados
        })

    except Exception as e:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except Exception:
            pass
        print(f"Error en /api/mi/vencimientos: {str(e)}")
        return jsonify({'success': False, 'message': f'Error al obtener vencimientos: {str(e)}'}), 500


@app.route('/api/operativo/vencimientos_tecnicos', methods=['GET'])
@login_required(role=['operativo', 'administrativo'])
def api_vencimientos_tecnicos_operativo():
    """Devuelve documentos vencidos de los técnicos a cargo de un supervisor (SOAT, Técnico Mecánica, Licencia)."""
    try:
        # Usar SIEMPRE el usuario logueado como supervisor responsable de técnicos
        supervisor = session.get('user_name', '')
        dias_param = request.args.get('dias', default='30')
        try:
            dias_ventana = int(dias_param)
        except Exception:
            dias_ventana = 30

        if not supervisor:
            return jsonify({'success': False, 'message': 'Usuario no identificado en sesión'}), 400

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor(dictionary=True)

        # SOAT por técnicos del supervisor
        # Mejora: considerar vínculos por técnico_asignado o por placa del vehículo asignado
        cursor.execute(
            """
            SELECT DISTINCT
                s.id_mpa_soat AS id,
                s.fecha_vencimiento,
                ro.id_codigo_consumidor AS tecnico_id,
                ro.nombre AS tecnico_nombre,
                'SOAT' AS tipo
            FROM capired.recurso_operativo ro
            LEFT JOIN capired.mpa_vehiculos mv ON mv.tecnico_asignado = ro.id_codigo_consumidor
            LEFT JOIN capired.mpa_soat s ON (s.tecnico_asignado = ro.id_codigo_consumidor OR (mv.placa IS NOT NULL AND s.placa = mv.placa))
            WHERE TRIM(UPPER(ro.super)) = TRIM(UPPER(%s)) AND ro.estado = 'Activo'
              AND s.fecha_vencimiento IS NOT NULL
              AND s.fecha_vencimiento NOT LIKE '0000-00-00%'
              AND s.fecha_vencimiento > '1900-01-01'
            """,
            (supervisor,)
        )
        soats = cursor.fetchall()

        # Técnico Mecánica por técnicos del supervisor
        cursor.execute(
            """
            SELECT DISTINCT
                tm.id_mpa_tecnico_mecanica AS id,
                tm.fecha_vencimiento,
                ro.id_codigo_consumidor AS tecnico_id,
                ro.nombre AS tecnico_nombre,
                'Técnico Mecánica' AS tipo
            FROM capired.recurso_operativo ro
            LEFT JOIN capired.mpa_vehiculos mv ON mv.tecnico_asignado = ro.id_codigo_consumidor
            LEFT JOIN capired.mpa_tecnico_mecanica tm ON (tm.tecnico_asignado = ro.id_codigo_consumidor OR (mv.placa IS NOT NULL AND tm.placa = mv.placa))
            WHERE TRIM(UPPER(ro.super)) = TRIM(UPPER(%s)) AND ro.estado = 'Activo'
              AND tm.fecha_vencimiento IS NOT NULL
              AND tm.fecha_vencimiento NOT LIKE '0000-00-00%'
              AND tm.fecha_vencimiento > '1900-01-01'
            """,
            (supervisor,)
        )
        tms = cursor.fetchall()

        # Licencias de conducir por técnicos del supervisor
        cursor.execute(
            """
            SELECT 
                lc.id_mpa_licencia_conducir AS id,
                lc.fecha_vencimiento,
                ro.id_codigo_consumidor AS tecnico_id,
                ro.nombre AS tecnico_nombre,
                'Licencia de Conducir' AS tipo
            FROM capired.mpa_licencia_conducir lc
            LEFT JOIN capired.recurso_operativo ro ON lc.tecnico = ro.id_codigo_consumidor
            WHERE TRIM(UPPER(ro.super)) = TRIM(UPPER(%s)) AND ro.estado = 'Activo'
              AND lc.fecha_vencimiento IS NOT NULL
              AND lc.fecha_vencimiento NOT LIKE '0000-00-00%'
              AND lc.fecha_vencimiento > '1900-01-01'
            """,
            (supervisor,)
        )
        lcs = cursor.fetchall()

        # Calcular estado y filtrar vencidos
        from datetime import datetime, date
        import re
        import pytz
        # Asegurar cálculo de hoy en zona horaria de Colombia para evitar desfases
        colombia_tz = pytz.timezone('America/Bogota')
        hoy = datetime.now(colombia_tz).date()

        def validar_fecha(fecha_val):
            if not fecha_val:
                return False, None
            if hasattr(fecha_val, 'date'):
                return True, fecha_val.date()
            s = str(fecha_val)
            if s == '0000-00-00' or not re.match(r'^\d{4}-\d{2}-\d{2}$', s):
                return False, None
            try:
                y, m, d = map(int, s.split('-'))
                return True, date(y, m, d)
            except Exception:
                return False, None

        vencidos = []
        for grupo in (soats, tms, lcs):
            for v in grupo:
                ok, fv = validar_fecha(v['fecha_vencimiento'])
                if not ok:
                    continue
                dias = (fv - hoy).days
                # Consistencia de bloqueo: Vencido solo cuando días restantes < 0
                estado = 'Vencido' if dias < 0 else ('Próximo a vencer' if dias <= dias_ventana else 'Vigente')
                if estado == 'Vencido':
                    vencidos.append({
                        'id': v['id'],
                        'tipo': v['tipo'],
                        'tecnico_id': v['tecnico_id'],
                        'tecnico_nombre': v['tecnico_nombre'],
                        'fecha_vencimiento': fv.strftime('%Y-%m-%d'),
                        'dias_restantes': dias,
                        'estado': estado
                    })

        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

        return jsonify({'success': True, 'data': vencidos, 'supervisor': supervisor, 'total_vencidos': len(vencidos)})

    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'}), 500
    except Exception as e:
        try:
            if 'cursor' in locals() and cursor:
                cursor.close()
            if 'connection' in locals() and connection and connection.is_connected():
                connection.close()
        except Exception:
            pass
        return jsonify({'success': False, 'message': f'Error: {str(e)}'}), 500

@app.route('/sgis/trabajo-seguro-rutinario')
@login_required()
def sgis_trabajo_seguro_rutinario_page():
    if session.get('user_role') not in ['tecnicos', 'operativo', 'administrativo', 'sstt', 'SSTT', 'tecnico', 'Tecnico']:
        flash('No tienes permisos para acceder a este módulo', 'error')
        return redirect(url_for('dashboard'))
    info = {}
    try:
        connection = get_db_connection()
        if connection:
            cursor = connection.cursor(dictionary=True)
            cursor.execute(
                """
                SELECT 
                    ro.nombre,
                    ro.cargo,
                    ro.carpeta AS area,
                    ro.ciudad,
                    ro.recurso_operativo_cedula AS cedula,
                    (
                        SELECT mv1.placa 
                        FROM capired.mpa_vehiculos mv1 
                        WHERE mv1.tecnico_asignado = ro.id_codigo_consumidor AND mv1.estado = 'Activo' 
                        ORDER BY mv1.id_mpa_vehiculos DESC 
                        LIMIT 1
                    ) AS placa
                FROM recurso_operativo ro
                WHERE ro.recurso_operativo_cedula = %s
                """,
                (session.get('user_cedula'),)
            )
            info = cursor.fetchone() or {}
            cursor.close()
            connection.close()
    except Exception:
        pass
    return render_template('modulos/sgis/trabajo_seguridad_rutina.html', info=info)

@app.route('/api/sgis/trabajo-seguro-rutinario/status', methods=['GET'])
@login_required_api()
def api_sgis_tsr_status():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_trabajos_seguridad_rutina (
                id_sgis_trabajo_seguridad_rutina INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                cargo VARCHAR(128) NULL,
                ciudad VARCHAR(128) NULL,
                placa VARCHAR(32) NULL,
                actividad_asociada VARCHAR(64) NULL,
                descripcion_tareas TEXT,
                observaciones TEXT,
                ot VARCHAR(10) NULL,
                cuenta VARCHAR(10) NULL,
                respuesta_1 VARCHAR(4),
                respuesta_2 VARCHAR(4),
                respuesta_3 VARCHAR(4),
                respuesta_4 VARCHAR(4),
                respuesta_5 VARCHAR(4),
                respuesta_6 VARCHAR(4),
                respuesta_7 VARCHAR(4),
                respuesta_8 VARCHAR(4),
                respuesta_9 VARCHAR(4),
                respuesta_10 VARCHAR(4),
                respuesta_11 VARCHAR(4),
                respuesta_12 VARCHAR(4),
                respuesta_13 VARCHAR(4),
                respuesta_14 VARCHAR(4),
                respuesta_15 VARCHAR(4),
                respuesta_16 VARCHAR(4),
                respuesta_17 VARCHAR(4),
                riesgo VARCHAR(128) NULL,
                peligro VARCHAR(128) NULL,
                consecuencia TEXT,
                control_propuesto TEXT,
                firma_trabajador LONGTEXT,
                firma_supervisor LONGTEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        cur_ddl = connection.cursor()
        cur_ddl.execute(ddl)
        try:
            cur_ddl.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN IF NOT EXISTS ot VARCHAR(10) NULL")
        except Exception:
            pass
        try:
            cur_ddl.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN IF NOT EXISTS cuenta VARCHAR(10) NULL")
        except Exception:
            pass
        try:
            connection.commit()
        except Exception:
            pass
        try:
            cur_ddl.close()
        except Exception:
            pass
        # Intentar eliminar índice único existente para permitir múltiples gestiones al día
        try:
            cur_idx = connection.cursor()
            cur_idx.execute("SELECT COUNT(*) FROM information_schema.statistics WHERE table_schema = DATABASE() AND table_name='sgis_trabajos_seguridad_rutina' AND index_name='uq_tecnico_dia_rutina'")
            has_idx = (cur_idx.fetchone() or [0])[0]
            cur_idx.close()
            if has_idx:
                try:
                    cur_drop = connection.cursor()
                    cur_drop.execute("ALTER TABLE sgis_trabajos_seguridad_rutina DROP INDEX uq_tecnico_dia_rutina")
                    connection.commit()
                    cur_drop.close()
                except Exception:
                    pass
        except Exception:
            pass
        uid = session.get('id_codigo_consumidor') or session.get('user_id')
        hoy = get_bogota_datetime().date()
        if not uid:
            return jsonify({'success': True, 'already_today': False})
        cursor = connection.cursor(dictionary=True)
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_trabajos_seguridad_rutina WHERE id_codigo_consumidor = %s AND fecha_dia = %s", (uid, hoy))
        row = cursor.fetchone() or {}
        c = int(row.get('c', 0) or 0)
        return jsonify({'success': True, 'count_today': c, 'limit_reached': c >= 10, 'already_today': c >= 1})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/trabajo-seguridad-rutina/riesgos', methods=['GET'])
@login_required_api()
def api_sgis_tsr_riesgos():
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur_ddl = connection.cursor()
        cur_ddl.execute(
            """
            CREATE TABLE IF NOT EXISTS sgis_riesgo_seguridad_rutina (
                id_sgis_riesgo_seguridad_rutina INT AUTO_INCREMENT PRIMARY KEY,
                riesgo VARCHAR(128) NOT NULL,
                peligro VARCHAR(128) NULL,
                consecuencia TEXT NULL,
                controles TEXT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        try:
            connection.commit()
        except Exception:
            pass
        try:
            cur_ddl.close()
        except Exception:
            pass
        cursor = connection.cursor(dictionary=True)
        try:
            cursor.execute("SELECT id_sgis_riesgo_seguridad_rutina AS id, riesgo, peligro, consecuencia, controles FROM sgis_riesgo_seguridad_rutina")
        except Exception:
            try:
                cursor.execute("SELECT id_sgis_riesgo_seguridad_rutina AS id, riesgo, peligro, consecuencia, controles FROM capired.sgis_riesgo_seguridad_rutina")
            except Exception:
                cursor.execute("SELECT id AS id, riesgo, peligro, consecuencia, controles FROM sgis_riesgo_seguridad_rutina")
        rows = cursor.fetchall()
        if not rows:
            cur_seed = connection.cursor()
            try:
                cur_seed.executemany(
                    "INSERT INTO sgis_riesgo_seguridad_rutina (riesgo, peligro, consecuencia, controles) VALUES (%s,%s,%s,%s)",
                    [
                        ('Caídas de altura', 'Alturas', 'Lesiones graves por caída', 'Uso de arnés, línea de vida, puntos de anclaje certificados'),
                        ('Golpes por objetos', 'Impactos', 'Contusiones o fracturas', 'Orden y aseo, delimitación del área, uso de casco'),
                        ('Electrocución', 'Energía eléctrica', 'Paro cardiorrespiratorio', 'Bloqueo y etiquetado, herramientas aisladas, verificación de desenergización'),
                        ('Cortes y pinchazos', 'Herramientas', 'Heridas en extremidades', 'Uso de guantes y herramientas en buen estado'),
                        ('Exposición a calor', 'Trabajo en caliente', 'Quemaduras', 'Avisos, extintor disponible, cortinas térmicas y EPP adecuado')
                    ]
                )
                connection.commit()
            except Exception:
                pass
            try:
                cur_seed.close()
            except Exception:
                pass
            cursor = connection.cursor(dictionary=True)
            cursor.execute("SELECT id_sgis_riesgo_seguridad_rutina AS id, riesgo, peligro, consecuencia, controles FROM sgis_riesgo_seguridad_rutina")
            rows = cursor.fetchall()
        data = []
        for r in rows:
            data.append({
                'id': r.get('id'),
                'riesgo': r.get('riesgo') or '',
                'peligro': r.get('peligro') or '',
                'consecuencia': r.get('consecuencia') or '',
                'controles': r.get('controles') or ''
            })
        return jsonify({'success': True, 'data': data})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/trabajo-seguridad-rutina', methods=['POST'])
@login_required_api()
def api_sgis_tsr_save():
    try:
        data = request.get_json() or {}
        respuestas = []
        for i in range(1, 18):
            v = (str(data.get(f'respuesta_{i}') or '').strip().upper())
            if v not in ('C','NC','N/A'):
                return jsonify({'success': False, 'error': f'Respuesta inválida o faltante: respuesta_{i}'}), 400
            respuestas.append(v)
        obs = (data.get('observaciones') or '').strip()
        any_nc = any(r == 'NC' for r in respuestas)
        if any_nc and not obs:
            return jsonify({'success': False, 'error': 'Observaciones requeridas por respuestas NC'}), 400
        ot = (data.get('ot') or '').strip()
        cuenta = (data.get('cuenta') or '').strip()
        if not re.fullmatch(r"\d{7,9}", ot or ''):
            return jsonify({'success': False, 'error': 'OT inválida: debe tener 7-9 dígitos numéricos'}), 400
        if not re.fullmatch(r"\d{6,8}", cuenta or ''):
            return jsonify({'success': False, 'error': 'Cuenta inválida: debe tener 6-8 dígitos numéricos'}), 400
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        ddl = (
            """
            CREATE TABLE IF NOT EXISTS sgis_trabajos_seguridad_rutina (
                id_sgis_trabajo_seguridad_rutina INT AUTO_INCREMENT PRIMARY KEY,
                id_codigo_consumidor INT NOT NULL,
                recurso_operativo_cedula VARCHAR(20) NULL,
                nombre VARCHAR(128) NULL,
                cargo VARCHAR(128) NULL,
                ciudad VARCHAR(128) NULL,
                placa VARCHAR(32) NULL,
                actividad_asociada VARCHAR(64) NULL,
                descripcion_tareas TEXT,
                observaciones TEXT,
                ot VARCHAR(10) NULL,
                cuenta VARCHAR(10) NULL,
                respuesta_1 VARCHAR(4),
                respuesta_2 VARCHAR(4),
                respuesta_3 VARCHAR(4),
                respuesta_4 VARCHAR(4),
                respuesta_5 VARCHAR(4),
                respuesta_6 VARCHAR(4),
                respuesta_7 VARCHAR(4),
                respuesta_8 VARCHAR(4),
                respuesta_9 VARCHAR(4),
                respuesta_10 VARCHAR(4),
                respuesta_11 VARCHAR(4),
                respuesta_12 VARCHAR(4),
                respuesta_13 VARCHAR(4),
                respuesta_14 VARCHAR(4),
                respuesta_15 VARCHAR(4),
                respuesta_16 VARCHAR(4),
                respuesta_17 VARCHAR(4),
                riesgo VARCHAR(128) NULL,
                peligro VARCHAR(128) NULL,
                consecuencia TEXT,
                control_propuesto TEXT,
                firma_trabajador LONGTEXT,
                firma_supervisor LONGTEXT,
                fecha_registro DATETIME,
                fecha_dia DATE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
            """
        )
        cur_ddl = connection.cursor()
        cur_ddl.execute(ddl)
        try:
            # Asegurar columnas ot y cuenta cuando la tabla ya existe
            cur_chk = connection.cursor()
            cur_chk.execute("SELECT COLUMN_NAME, DATA_TYPE FROM information_schema.columns WHERE table_schema = DATABASE() AND table_name = 'sgis_trabajos_seguridad_rutina'")
            rows = cur_chk.fetchall()
            cols = {}
            for r in rows:
                try:
                    cols[r[0]] = (r[1] or '').lower()
                except Exception:
                    cols[r[0]] = ''
            cur_chk.close()
            if 'ot' not in cols:
                cur_alter1 = connection.cursor()
                try:
                    cur_alter1.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN ot VARCHAR(10) NULL")
                    connection.commit()
                except Exception:
                    pass
                finally:
                    cur_alter1.close()
            if 'cuenta' not in cols:
                cur_alter2 = connection.cursor()
                try:
                    cur_alter2.execute("ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN cuenta VARCHAR(10) NULL")
                    connection.commit()
                except Exception:
                    pass
                finally:
                    cur_alter2.close()
            for c in ('firma_trabajador','firma_supervisor'):
                if c not in cols:
                    cur_alterf_add = connection.cursor()
                    try:
                        cur_alterf_add.execute(f"ALTER TABLE sgis_trabajos_seguridad_rutina ADD COLUMN {c} LONGTEXT NULL")
                        connection.commit()
                    except Exception:
                        pass
                    finally:
                        cur_alterf_add.close()
                else:
                    dt = cols.get(c)
                    if dt and dt != 'longtext':
                        cur_alterf_mod = connection.cursor()
                        try:
                            cur_alterf_mod.execute(f"ALTER TABLE sgis_trabajos_seguridad_rutina MODIFY COLUMN {c} LONGTEXT NULL")
                            connection.commit()
                        except Exception:
                            pass
                        finally:
                            cur_alterf_mod.close()
        except Exception:
            try:
                connection.rollback()
            except Exception:
                pass
        try:
            cur_ddl.close()
        except Exception:
            pass
        cursor = connection.cursor(dictionary=True)
        uid = session.get('id_codigo_consumidor')
        ced = session.get('user_cedula')
        cursor.execute("SELECT nombre, cargo, ciudad FROM recurso_operativo WHERE id_codigo_consumidor = %s", (uid,))
        urow = cursor.fetchone() or {}
        nombre = urow.get('nombre') or session.get('user_name')
        cargo = urow.get('cargo') or session.get('user_role')
        ciudad = urow.get('ciudad') or ''
        cursor.execute(
            """
            SELECT mv.placa FROM capired.mpa_vehiculos mv 
            WHERE mv.tecnico_asignado = %s AND mv.estado = 'Activo' 
            ORDER BY mv.id_mpa_vehiculos DESC LIMIT 1
            """,
            (uid,)
        )
        vrow = cursor.fetchone() or {}
        placa = vrow.get('placa') or ''
        fecha = get_bogota_datetime()
        fecha_dia = fecha.date()
        cursor.execute("SELECT COUNT(*) AS c FROM sgis_trabajos_seguridad_rutina WHERE id_codigo_consumidor=%s AND fecha_dia=%s", (uid, fecha_dia))
        row = cursor.fetchone() or {}
        c = int(row.get('c',0) or 0)
        if c >= 10:
            return jsonify({'success': False, 'error': 'Límite diario alcanzado: máximo 10 gestiones'}), 409
        firma_trabajador = data.get('firma_trabajador') or data.get('firma_base64') or None
        actividad = (data.get('actividad_asociada') or '').strip()
        desc_tareas = (data.get('descripcion_tareas') or '').strip()
        riesgo_sel = data.get('riesgo') or ''
        peligro_sel = data.get('peligro') or ''
        consecuencia_txt = data.get('consecuencia') or ''
        control_txt = data.get('control_propuesto') or data.get('controles') or ''
        cursor.execute(
            """
            INSERT INTO sgis_trabajos_seguridad_rutina (
                id_codigo_consumidor, recurso_operativo_cedula, nombre, cargo, ciudad, placa,
                actividad_asociada, descripcion_tareas, observaciones, ot, cuenta,
                respuesta_1, respuesta_2, respuesta_3, respuesta_4, respuesta_5, respuesta_6, respuesta_7,
                respuesta_8, respuesta_9, respuesta_10, respuesta_11, respuesta_12, respuesta_13, respuesta_14,
                respuesta_15, respuesta_16, respuesta_17,
                riesgo, peligro, consecuencia, control_propuesto,
                firma_trabajador, fecha_registro, fecha_dia
            ) VALUES (
                %s,%s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,%s,%s,
                %s,%s,%s,%s,%s,%s,%s,
                %s,%s,%s,
                %s,%s,%s,%s,
                %s,%s,%s
            )
            """,
            (
                uid, ced, nombre, cargo, ciudad, placa,
                actividad, desc_tareas, obs, ot, cuenta,
                respuestas[0], respuestas[1], respuestas[2], respuestas[3], respuestas[4], respuestas[5], respuestas[6],
                respuestas[7], respuestas[8], respuestas[9], respuestas[10], respuestas[11], respuestas[12], respuestas[13],
                respuestas[14], respuestas[15], respuestas[16],
                riesgo_sel, peligro_sel, consecuencia_txt, control_txt,
                firma_trabajador, fecha, fecha_dia
            )
        )
        connection.commit()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
    finally:
        if 'cursor' in locals():
            try:
                cursor.close()
            except Exception:
                pass
        if 'connection' in locals() and connection:
            try:
                connection.close()
            except Exception:
                pass

@app.route('/api/sgis/trabajo-seguridad-rutina/<int:tsr_id>', methods=['GET'])
@login_required_api()
def api_sgis_tsr_get(tsr_id: int):
    try:
        conn = get_db_connection()
        if conn is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = conn.cursor(dictionary=True)
        cur.execute(
            """
            SELECT 
                id_sgis_trabajo_seguridad_rutina AS id,
                id_codigo_consumidor,
                recurso_operativo_cedula AS cedula,
                nombre,
                cargo,
                ciudad,
                placa,
                actividad_asociada,
                descripcion_tareas,
                observaciones,
                ot,
                cuenta,
                respuesta_1, respuesta_2, respuesta_3, respuesta_4, respuesta_5, respuesta_6, respuesta_7,
                respuesta_8, respuesta_9, respuesta_10, respuesta_11, respuesta_12, respuesta_13, respuesta_14,
                respuesta_15, respuesta_16, respuesta_17,
                riesgo, peligro, consecuencia, control_propuesto,
                fecha_registro,
                fecha_dia
            FROM sgis_trabajos_seguridad_rutina
            WHERE id_sgis_trabajo_seguridad_rutina = %s
            LIMIT 1
            """,
            (tsr_id,)
        )
        row = cur.fetchone()
        cur.close(); conn.close()
        if not row:
            return jsonify({'success': False, 'error': 'Registro no encontrado'}), 404
        # Normalizar formato de fechas
        try:
            if row.get('fecha_registro'):
                row['fecha_registro'] = row['fecha_registro'].strftime('%Y-%m-%d %H:%M:%S')
        except Exception:
            pass
        try:
            if row.get('fecha_dia'):
                row['fecha_dia'] = row['fecha_dia'].strftime('%Y-%m-%d')
        except Exception:
            pass
        return jsonify({'success': True, 'data': row})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/dev/login', methods=['POST'])
def dev_login():
    try:
        # Solo disponible en modo debug
        if not app.debug:
            return jsonify({'message': 'No disponible en producción'}), 403
        data = request.get_json(force=True) or {}
        name = (data.get('user_name') or '').strip()
        cedula = (data.get('user_cedula') or '').strip()
        role = (data.get('user_role') or 'operativo').strip()
        if not name:
            return jsonify({'message': 'user_name requerido'}), 400
        session['user_id'] = data.get('user_id') or cedula or 'dev'
        session['user_name'] = name
        session['user_cedula'] = cedula
        session['user_role'] = role
        return jsonify({'success': True, 'message': 'Sesión de desarrollo creada', 'user_name': name, 'user_role': role})
    except Exception as e:
        return jsonify({'message': 'Error en dev login', 'error': str(e)}), 500

# Submódulo: Novedades asistencia (vista calendario por mes)
@app.route('/administrativo/novedades', methods=['GET'], endpoint='administrativo_novedades')
@login_required
def administrativo_novedades():
    """Renderiza el submódulo de Novedades asistencia"""
    try:
        # Datos iniciales: mes actual
        now = get_bogota_datetime()
        current_year = now.year
        current_month = now.month
        return render_template(
            'modulos/administrativo/novedades_asistencia.html',
            current_year=current_year,
            current_month=f"{current_month:02d}"
        )
    except Exception as e:
        return render_template('error.html', mensaje='Error al cargar Novedades', error=str(e))

# API: matriz mensual de novedades de asistencia
@app.route('/api/asistencia/novedades', methods=['GET'], endpoint='api_asistencia_novedades')
@login_required
def api_asistencia_novedades():
    """Devuelve matriz de asistencia por usuario y día del mes.
    Verde: tiene registro de asistencia.
    Rojo: registro con carpeta_dia=0 o carpeta=0 (ausencia injustificada).
    """
    try:
        year = request.args.get('year', type=int)
        month = request.args.get('month', type=int)

        now = get_bogota_datetime()
        if not year:
            year = now.year
        if not month:
            month = now.month

        # Determinar cantidad de días del mes
        import calendar
        days_in_month = calendar.monthrange(year, month)[1]

        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'})

        cursor = connection.cursor(dictionary=True)

        # Usuarios con asistencia registrada en el mes (indexar por cédula, nombre desde recurso_operativo)
        cursor.execute(
            """
            SELECT DISTINCT a.cedula AS usuario_id,
                            COALESCE(ro.nombre, a.tecnico) AS nombre
            FROM asistencia a
            LEFT JOIN recurso_operativo ro ON ro.recurso_operativo_cedula = a.cedula
            WHERE YEAR(a.fecha_asistencia) = %s AND MONTH(a.fecha_asistencia) = %s
            ORDER BY nombre
            """,
            (year, month)
        )
        usuarios = cursor.fetchall() or []

        # Registros por día para el mes (clave por cédula) usando SOLO carpeta_dia
        # Además, recolectar los valores de carpeta_dia para mostrarlos en tooltips
        cursor.execute(
            """
            SELECT a.cedula AS usuario_id,
                   DATE(a.fecha_asistencia) AS fecha,
                   MAX(CASE WHEN TRIM(COALESCE(a.carpeta_dia, '')) = '0' THEN 1 ELSE 0 END) AS tiene_cero,
                   COUNT(*) AS registros,
                   GROUP_CONCAT(DISTINCT TRIM(COALESCE(a.carpeta_dia, '')) ORDER BY TRIM(COALESCE(a.carpeta_dia, '')) SEPARATOR '|') AS carpetas_raw
            FROM asistencia a
            WHERE YEAR(a.fecha_asistencia) = %s AND MONTH(a.fecha_asistencia) = %s
            GROUP BY a.cedula, DATE(a.fecha_asistencia)
            """,
            (year, month)
        )
        registros = cursor.fetchall() or []

        # Indexar por usuario y día con detalle de carpetas
        por_usuario = {}
        for r in registros:
            uid = r['usuario_id']
            dia = int(str(r['fecha']).split('-')[-1])
            valor = None
            if (r['registros'] or 0) > 0:
                valor = 0 if r['tiene_cero'] == 1 else 1
            raw = (r.get('carpetas_raw') or '')
            # Convertir el GROUP_CONCAT en lista, filtrando vacíos
            carpetas_list = [c for c in raw.split('|') if c]
            por_usuario.setdefault(uid, {})[dia] = {
                'valor': valor,
                'carpetas': carpetas_list if carpetas_list else None
            }

        # Construir matriz
        matriz = []
        for u in usuarios:
            fila = []
            fila_carpetas = []
            for d in range(1, days_in_month + 1):
                item = por_usuario.get(u['usuario_id'], {}).get(d, None)
                valor = item['valor'] if isinstance(item, dict) else item
                carpetas = (item.get('carpetas') if isinstance(item, dict) else None)
                fila.append(valor)
                fila_carpetas.append(carpetas)
            matriz.append({
                'cedula': u['usuario_id'],
                'tecnico': u['nombre'],
                'dias': fila,
                'carpetas': fila_carpetas
            })

        return jsonify({
            'success': True,
            'year': year,
            'month': month,
            'days_in_month': days_in_month,
            'usuarios': matriz
        })
    except mysql.connector.Error as e:
        return jsonify({'success': False, 'message': f'Error de base de datos: {str(e)}'})
    except Exception as e:
        return jsonify({'success': False, 'message': f'Error: {str(e)}'})
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()
        if 'connection' in locals() and connection and connection.is_connected():
            connection.close()

@app.route('/administrativo/porcentajes-analistas', methods=['GET'])
@login_required
def administrativo_porcentajes_analistas():
    try:
        if session.get('user_role') != 'administrativo':
            return redirect(url_for('login'))
        now = get_bogota_datetime()
        current_year = now.year
        current_month = now.month
        return render_template('modulos/administrativo/porcentajes_analistas.html', current_year=current_year, current_month=f"{current_month:02d}")
    except Exception as e:
        return render_template('error.html', mensaje='Error al cargar Porcentajes Analistas', error=str(e))

@app.route('/api/administrativo/porcentajes-analistas', methods=['GET', 'POST'])
@login_required
def api_administrativo_porcentajes_analistas():
    method = request.method
    if method == 'GET':
        if session.get('user_role') not in ('administrativo','lider'):
            return jsonify({'success': False, 'message': 'Permisos insuficientes'}), 403
        periodo = (request.args.get('periodo') or '').strip()
        try:
            now_bog = datetime.now(TIMEZONE)
            year = now_bog.year
            month = now_bog.month
            if periodo:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0]); month = int(parts[1])
        except Exception:
            pass
        try:
            connection = get_db_connection()
            if connection is None:
                return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            schema = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
            cmeta = connection.cursor()
            cmeta.execute(
                """
                SELECT COLUMN_NAME FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_porcentaje_analistas'
                """,
                (schema,)
            )
            col_rows = cmeta.fetchall() or []
            cols = {r[0] if isinstance(r, tuple) else list(r.values())[0] for r in col_rows}
            cmeta.close()
            cursor = connection.cursor(dictionary=True)
            # Construir SELECT seguro según columnas existentes
            sel_cols = []
            def has(c):
                return c in cols
            # Identificadores comunes
            if has('id_operaciones_porcentaje_analistas'):
                sel_cols.append('id_operaciones_porcentaje_analistas AS id')
            elif has('id'):
                sel_cols.append('id')
            # Periodo
            if has('periodo_year'):
                sel_cols.append('periodo_year')
            if has('periodo_month'):
                sel_cols.append('periodo_month')
            # Campos esperados
            if has('seccion'):
                sel_cols.append('seccion')
            if has('analista'):
                sel_cols.append('analista')
            if has('porcentaje'):
                sel_cols.append('porcentaje')
            if has('moneda'):
                sel_cols.append('moneda')
            # Fechas
            if has('fecha_registro'):
                sel_cols.append('fecha_registro')
            elif has('updated_at'):
                sel_cols.append('updated_at')
            if not sel_cols:
                cursor.close(); connection.close()
                return jsonify({'success': True, 'items': [], 'periodo_year': year, 'periodo_month': month})
            base_sql = "SELECT " + ", ".join(sel_cols) + " FROM operaciones_porcentaje_analistas"
            params = []
            period_clauses = []
            if has('periodo_year') and has('periodo_month'):
                period_clauses.append("(periodo_year=%s AND periodo_month=%s)")
                params.extend([year, month])
                period_clauses.append("(periodo_year IS NULL AND periodo_month IS NULL)")
            elif has('fecha_registro'):
                period_clauses.append("(YEAR(fecha_registro)=%s AND MONTH(fecha_registro)=%s)")
                params.extend([year, month])
            and_filters = []
            analista_q = (request.args.get('analista') or '').strip()
            seccion_q = (request.args.get('seccion') or '').strip()
            if analista_q and has('analista'):
                and_filters.append("analista=%s"); params.append(analista_q)
            if seccion_q and has('seccion'):
                and_filters.append("seccion=%s"); params.append(seccion_q)
            if period_clauses or and_filters:
                base_sql += " WHERE "
                if period_clauses:
                    base_sql += "(" + " OR ".join(period_clauses) + ")"
                    if and_filters:
                        base_sql += " AND " + " AND ".join(and_filters)
                else:
                    base_sql += " AND ".join(and_filters)
            if has('analista'):
                base_sql += " ORDER BY analista"
            elif has('fecha_registro'):
                base_sql += " ORDER BY fecha_registro"
            cursor.execute(base_sql, tuple(params))
            rows = cursor.fetchall() or []
            # Normalizar claves
            items = []
            for it in rows:
                out = {
                    'id': it.get('id'),
                    'periodo_year': it.get('periodo_year'),
                    'periodo_month': it.get('periodo_month'),
                    'seccion': it.get('seccion'),
                    'analista': it.get('analista'),
                    'porcentaje': it.get('porcentaje'),
                    'moneda': it.get('moneda'),
                    'fecha_registro': it.get('fecha_registro') or it.get('updated_at'),
                }
                items.append(out)
            cursor.close(); connection.close()
            return jsonify({'success': True, 'items': items, 'periodo_year': year, 'periodo_month': month})
        except Error as e:
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            return jsonify({'success': False, 'message': str(e)}), 500
    else:
        if session.get('user_role') != 'administrativo':
            return jsonify({'success': False, 'message': 'Permisos insuficientes'}), 403
        data = None
        try:
            if request.is_json:
                data = request.get_json(force=True)
            else:
                data = request.form.to_dict()
        except Exception:
            data = {}
        analista = (data.get('analista') or '').strip()
        periodo = (data.get('periodo') or '').strip()
        try:
            now_bog = datetime.now(TIMEZONE)
            year = now_bog.year
            month = now_bog.month
            if periodo:
                parts = periodo.split('-')
                if len(parts) == 2:
                    year = int(parts[0]); month = int(parts[1])
        except Exception:
            pass
        seccion = (data.get('seccion') or '').strip() or 'efectividad'
        try:
            pct = data.get('porcentaje'); mon = data.get('moneda')
            if pct is None:
                pct = data.get('efectividad')
            s_pct = str(pct or '').strip().replace('%','').replace(',','.')
            pct_val = float(s_pct) if s_pct != '' else None
            mon_val = str(mon or '').strip() or None
        except Exception:
            pct_val = None; mon_val = None
        if not analista or pct_val is None or mon_val is None:
            return jsonify({'success': False, 'message': 'Datos incompletos'}), 400
        try:
            connection = get_db_connection()
            if connection is None:
                return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
            cursor = connection.cursor()
            # Detectar columnas para construir INSERT/UPDATE
            schema = os.getenv('MYSQL_DB') or (db_config.get('database') or 'capired')
            cmeta = connection.cursor()
            cmeta.execute(
                """
                SELECT COLUMN_NAME FROM information_schema.columns
                WHERE table_schema=%s AND table_name='operaciones_porcentaje_analistas'
                """,
                (schema,)
            )
            cols = {r[0] if isinstance(r, tuple) else list(r.values())[0] for r in cmeta.fetchall() or []}
            cmeta.close()
            # Intentar UPDATE si existe registro con mismo analista/periodo/seccion
            where_parts = []
            params = []
            if 'analista' in cols:
                where_parts.append('analista=%s'); params.append(analista)
            if 'seccion' in cols:
                where_parts.append('seccion=%s'); params.append(seccion)
            if 'periodo_year' in cols and 'periodo_month' in cols:
                where_parts.append('periodo_year=%s AND periodo_month=%s'); params.extend([year, month])
            if 'moneda' in cols and mon_val is not None:
                where_parts.append('moneda=%s'); params.append(mon_val)
            update_sql = None
            if 'porcentaje' in cols and 'moneda' in cols:
                update_sql = "UPDATE operaciones_porcentaje_analistas SET porcentaje=%s, moneda=%s WHERE " + " AND ".join(where_parts)
                upd_params = [pct_val, mon_val] + params
            elif 'porcentaje_efectividad' in cols and 'porcentaje_presupuesto' in cols:
                update_sql = "UPDATE operaciones_porcentaje_analistas SET porcentaje_efectividad=%s, porcentaje_presupuesto=%s WHERE " + " AND ".join(where_parts)
                upd_params = [pct_val, mon_val] + params
            rowcount = 0
            if update_sql and where_parts:
                cursor.execute(update_sql, tuple(upd_params))
                rowcount = cursor.rowcount
            if rowcount == 0:
                # Hacer INSERT
                if 'porcentaje' in cols and 'moneda' in cols:
                    fields = ['analista', 'seccion', 'porcentaje', 'moneda']
                    vals = [analista, seccion, pct_val, mon_val]
                    if 'periodo_year' in cols and 'periodo_month' in cols:
                        fields += ['periodo_year','periodo_month']
                        vals += [year, month]
                    cursor.execute(
                        f"INSERT INTO operaciones_porcentaje_analistas ({', '.join(fields)}) VALUES ({', '.join(['%s']*len(vals))})",
                        tuple(vals)
                    )
                elif 'porcentaje_efectividad' in cols and 'porcentaje_presupuesto' in cols:
                    fields = ['analista', 'seccion', 'porcentaje_efectividad', 'porcentaje_presupuesto']
                    vals = [analista, seccion, pct_val, mon_val]
                    if 'periodo_year' in cols and 'periodo_month' in cols:
                        fields += ['periodo_year','periodo_month']
                        vals += [year, month]
                    cursor.execute(
                        f"INSERT INTO operaciones_porcentaje_analistas ({', '.join(fields)}) VALUES ({', '.join(['%s']*len(vals))})",
                        tuple(vals)
                    )
            connection.commit()
            cursor.close(); connection.close()
            return jsonify({'success': True, 'message': 'Guardado'})
        except Error as e:
            return jsonify({'success': False, 'message': str(e)}), 500
        except Exception as e:
            return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/administrativo/porcentajes-analistas/opciones', methods=['GET'])
@login_required
def api_administrativo_porcentajes_analistas_opciones():
    if session.get('user_role') != 'administrativo':
        return jsonify({'success': False, 'message': 'Permisos insuficientes'}), 403
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'message': 'Error de conexión a la base de datos'}), 500
        cursor = connection.cursor()
        cursor.execute(
            "SELECT DISTINCT nombre FROM recurso_operativo WHERE estado='Activo' AND (cargo='ANALISTA' OR cargo='ANALISTA LOGISTICA') ORDER BY nombre"
        )
        analistas = [r[0] for r in cursor.fetchall() or []]
        cursor.close(); connection.close()
        return jsonify({'success': True, 'analistas': analistas})
    except Error as e:
        return jsonify({'success': False, 'message': str(e)}), 500

if __name__ == '__main__':
    # Handlers de error para evitar exposición de información y listados
    @app.errorhandler(404)
    def handle_404(e):
        try:
            if request.path.startswith('/api/'):
                return jsonify({'success': False, 'message': 'Recurso no encontrado'}), 404
            return render_template('error.html', code=404, message='Recurso no encontrado'), 404
        except Exception:
            return 'Recurso no encontrado', 404

    @app.errorhandler(500)
    def handle_500(e):
        try:
            if request.path.startswith('/api/'):
                return jsonify({'success': False, 'message': 'Error interno del servidor'}), 500
            return render_template('error.html', code=500, message='Error interno del servidor'), 500
        except Exception:
            return 'Error interno del servidor', 500

    @app.errorhandler(405)
    def handle_405(e):
        try:
            if request.path.startswith('/api/'):
                return jsonify({'success': False, 'message': 'Método no permitido'}), 405
            return render_template('error.html', code=405, message='Método no permitido'), 405
        except Exception:
            return 'Método no permitido', 405

    @app.after_request
    def add_security_headers(response):
        try:
            if request.is_secure:
                response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
                csp = response.headers.get('Content-Security-Policy', '')
                if 'upgrade-insecure-requests' not in csp:
                    response.headers['Content-Security-Policy'] = (csp + ' ' if csp else '') + 'upgrade-insecure-requests'
        except Exception:
            pass
        return response

    # Deshabilitar modo debug por defecto para evitar fugas de información
    import os
    debug_mode = os.environ.get('FLASK_DEBUG', '0') == '1'

    ssl_cert = os.environ.get('SSL_CERT_FILE')
    ssl_key = os.environ.get('SSL_KEY_FILE')

    if ssl_cert and ssl_key and os.path.exists(ssl_cert) and os.path.exists(ssl_key):
        app.config['PREFERRED_URL_SCHEME'] = 'https'
        app.config['SESSION_COOKIE_SECURE'] = True
        app.config['REMEMBER_COOKIE_SECURE'] = True
        app.run(debug=debug_mode, host='0.0.0.0', port=8080, ssl_context=(ssl_cert, ssl_key))
    else:
        app.run(debug=debug_mode, host='0.0.0.0', port=8080)
# Alias para analistas (mismo comportamiento)
@app.route('/analistas/ordenes', methods=['GET'])
@app.route('/api/analistas/ordenes', methods=['GET'])
@login_required_api(role=['analista','analistas'])
def api_analistas_list_ordenes_alias():
    return api_tecnicos_list_ordenes()
# Alias detalle para analistas
@app.route('/analistas/ordenes/detalle/<ot>', methods=['GET'])
@app.route('/api/analistas/ordenes/detalle/<ot>', methods=['GET'])
@login_required_api(role=['analista','analistas'])
def api_analistas_get_orden_detalle_alias(ot):
    return api_tecnicos_get_orden_detalle(ot)
# Alias creación para analistas
@app.route('/analistas/ordenes', methods=['POST'])
@app.route('/api/analistas/ordenes', methods=['POST'])
@login_required_api(role=['analista','analistas'])
def api_analistas_create_orden_alias():
    return api_tecnicos_create_orden()
# Alias tecnologías para analistas
@app.route('/analistas/tecnologias', methods=['GET'])
@app.route('/api/analistas/tecnologias', methods=['GET'])
@login_required_api(role=['analista','analistas'])
def api_analistas_list_tecnologias_alias():
    return api_tecnicos_list_tecnologias()
# Alias categorías para analistas
@app.route('/analistas/categorias/<string:tecnologia>', methods=['GET'])
@app.route('/api/analistas/categorias/<string:tecnologia>', methods=['GET'])
@login_required_api(role=['analista','analistas'])
def api_analistas_list_categorias_alias(tecnologia):
    return api_tecnicos_list_categorias(tecnologia)
# Alias códigos para analistas
@app.route('/analistas/codigos/tecnologia/<string:tecnologia>', methods=['GET'])
@app.route('/analistas/codigos/tecnologia/<string:tecnologia>/categoria/<path:categoria>', methods=['GET'])
@app.route('/api/analistas/codigos', methods=['GET'])
@login_required_api(role=['analista','analistas'])
def api_analistas_list_codigos_alias(tecnologia=None, categoria=None):
    return api_tecnicos_list_codigos(tecnologia, categoria)
@app.route('/api/logistica/computadores/update-modelo', methods=['POST'])
@app.route('/logistica/computadores/update-modelo', methods=['POST'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_update_modelo():
    data = request.get_json() or {}
    cid = int(data.get('id') or 0)
    modelo = (data.get('modelo') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute("UPDATE log_computadores SET modelo=%s WHERE id=%s", (modelo, cid))
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/logistica/computadores/update', methods=['POST'])
@app.route('/logistica/computadores/update', methods=['POST'])
@login_required_api(role=['logistica','administrativo'])
def api_log_computadores_update():
    data = request.get_json() or {}
    cid = int(data.get('id') or 0)
    marca = (data.get('marca') or '').strip()
    modelo = (data.get('modelo') or '').strip()
    descripcion = (data.get('descripcion') or '').strip()
    cantidad = int(data.get('cantidad') or 1)
    serial = (data.get('serial') or '').strip()
    costo = float(data.get('costo') or 0)
    observacion = (data.get('observacion') or '').strip()
    try:
        connection = get_db_connection()
        if connection is None:
            return jsonify({'success': False, 'error': 'Error de conexión a la base de datos'}), 500
        cur = connection.cursor()
        cur.execute(
            "UPDATE log_computadores SET marca=%s, modelo=%s, descripcion=%s, cantidad=%s, serial=%s, costo=%s, observacion=%s WHERE id=%s",
            (marca, modelo, descripcion, cantidad, serial, costo, observacion, cid)
        )
        connection.commit()
        cur.close(); connection.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
@app.route('/api/sgis/debug-session', methods=['GET'])
def api_sgis_debug_session():
    try:
        return jsonify({
            'success': True,
            'data': {
                'user_id': session.get('user_id'),
                'id_codigo_consumidor': session.get('id_codigo_consumidor'),
                'user_role': session.get('user_role'),
                'user_name': session.get('user_name'),
                'user_cedula': session.get('user_cedula')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
